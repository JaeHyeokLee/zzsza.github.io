<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>어쩐지 오늘은</title>
    <description>메모가 습관인 데이터쟁이입니다
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 02 Mar 2020 20:31:47 +0900</pubDate>
    <lastBuildDate>Mon, 02 Mar 2020 20:31:47 +0900</lastBuildDate>
    <generator>Jekyll v3.8.4</generator>
    
      <item>
        <title>글 쓰는 개발자 모임 - 글또 4기 다짐</title>
        <description>&lt;ul&gt;
  &lt;li&gt;제가 운영하고 있는 글 쓰는 개발자 모임, 글또 4기 다짐 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;글또-4기&quot;&gt;글또 4기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;벌써 4기째!&lt;/li&gt;
  &lt;li&gt;매 기수가 끝나고, 새로운 기수가 시작되면 다양한 생각이 들곤합니다&lt;/li&gt;
  &lt;li&gt;이번 기수는 저번 기수보다 더 많은 분들이 지원해주셨습니다. 그 중, 69명과 함께 합니다!
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://zzsza.github.io/diary/2019/07/07/2019-half-retrospect/&quot;&gt;3기 회고&lt;/a&gt; 글에 4기에 80명 정도 함께하려나..? 했는데 그정도는 아니였네요!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사람들이 많아진 만큼, 서로에게 좋은 영향력을 끼치면 좋을 것 같네요 :)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;4기를-시작하며-준비한-것&quot;&gt;4기를 시작하며 준비한 것&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;로고
    &lt;center&gt;&lt;img src=&quot;https://www.dropbox.com/s/huqovop20qxb3gh/symbol.png?raw=1&quot; /&gt;&lt;/center&gt;

    &lt;ul&gt;
      &lt;li&gt;우선 로고를 만들었습니다!&lt;/li&gt;
      &lt;li&gt;글또 1~3기를 하신 &lt;a href=&quot;https://feel5ny.github.io/&quot;&gt;김나영님&lt;/a&gt;께서 이쁜 로고를 만들어주셨습니다&lt;/li&gt;
      &lt;li&gt;예전부터 만들고 싶었는데, 이제 로고가 생겨서 너무 기쁘네요-! 조만간 스티커를 만들 예정입니다 :)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;글또 관련 문서
    &lt;center&gt;&lt;img src=&quot;https://www.dropbox.com/s/7rdttf1uecw3y0o/Screenshot%202020-02-29%2020.43.32.png?raw=1&quot; /&gt;&lt;/center&gt;

    &lt;ul&gt;
      &lt;li&gt;글또 관련 규칙을 발표 자료로 유지했는데, 이번에 Notion에 글을 작성했습니다!&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://bit.ly/geultto&quot;&gt;글또 노션&lt;/a&gt;에서 확인할 수 있고, 가이드 문서, 자료 모음 등 다양한 부분을 계속 보강할 예정입니다&lt;/li&gt;
      &lt;li&gt;글또 활동을 하지 않아도, 이런 모임을 만들고 싶은 분들에게 좋은 영향력을 드리고 싶습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;온라인 OT
    &lt;ul&gt;
      &lt;li&gt;과거 기수에선 계속 첫 모임은 오프라인!을 고집해왔습니다&lt;/li&gt;
      &lt;li&gt;하지만 이번엔 약 70명의 글또분들이 계시고, 코로나로 인해 모임을 하기 어렵다고 판단했습니다&lt;/li&gt;
      &lt;li&gt;따라서 유튜브 온라인에서 오리엔테이션을 진행했습니다&lt;/li&gt;
      &lt;li&gt;영상은 &lt;a href=&quot;https://youtu.be/P3pl3SSazFM&quot;&gt;유튜브&lt;/a&gt;에서 확인할 수 있습니다&lt;/li&gt;
      &lt;li&gt;온라인으로 진행한 부분이 생각보다 신선하고 긍정적인 피드백이 있어서, 종종 온라인으로 같이 피드백, 의논 등을 해볼까 생각하고 있습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;규칙 개정 및 업무 자동화
    &lt;ul&gt;
      &lt;li&gt;기수가 지나며 점점 개선해야 할 규칙들을 개정하고 있습니다&lt;/li&gt;
      &lt;li&gt;1) 다른 직군 피드백이 아닌, 같은 팀 내 피드백 하도록 변경&lt;/li&gt;
      &lt;li&gt;2) 많이 헷갈릴 수 있는 피드백 부분 개선 =&amp;gt; 자동화팀에서 구현해주실 예정&lt;/li&gt;
      &lt;li&gt;3) 블로그 글 대신 유튜브 글도 허용하도록 규칙 개정 =&amp;gt; 이 부분은 실제로 하실 분이 얼마나 계실지 모르겠지만! 일단 컨텐츠의 다양성을 존중하기로 했습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;이번엔-무슨-글을-작성할-것인가&quot;&gt;이번엔 무슨 글을 작성할 것인가?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사실 저는 글또 1~3기를 하며 한번도 예치금을 잃어본 적이 없어서(Pass도 한번도 쓰지 않은 것 같네요) 예치금 없이 Pass 꼭 해야지! 이런 생각은 없습니다&lt;/li&gt;
  &lt;li&gt;다만 이번엔 글의 퀄리티를 더 높이기 위한 노력을 하려고 합니다
    &lt;ul&gt;
      &lt;li&gt;다양한 요소를 엮은 통찰력 있는 글 작성&lt;/li&gt;
      &lt;li&gt;실제 업무하며 겪을 수 있는 내용을 일반화해서 글 작성&lt;/li&gt;
      &lt;li&gt;리더십, 동기부여에 관한 글&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기술적 부분에 대해 작성하고 싶은 테마는 아래와 같습니다
    &lt;ul&gt;
      &lt;li&gt;여전히 MLOps. 아직도 다양한 방법론이 있고, 그걸 어떻게 블럭같이 엮을지는 시도가 필요한 상태&lt;/li&gt;
      &lt;li&gt;Operation Research와 Machine Learning의 결합&lt;/li&gt;
      &lt;li&gt;Graph 이론&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그 외에 개발 분야가 아닌 책의 후기도 블로그에 남기고 싶습니다!(일단 읽기라도 해야..)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;이번엔-유튜브를-진짜-시작할-것인가&quot;&gt;이번엔 유튜브를 진짜 시작할 것인가?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사실 유튜브를 진짜!!!!! 하려고 다짐했습니다&lt;/li&gt;
  &lt;li&gt;채널도 만들었습니다. 일명 &lt;a href=&quot;https://www.youtube.com/channel/UCYyAaezBGEVmXcnink6nY9Q&quot;&gt;카일스쿨&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;주로 이야기할 내용은 다음과 같습니다
    &lt;ul&gt;
      &lt;li&gt;1) 신입 데이터 분석가가 알면 좋을 내용(어떻게 일할 것인가, 업무의 방식, 데이터 시각화, 간단한 개발 상식 등)
        &lt;ul&gt;
          &lt;li&gt;머신러닝이나 통계학 내용은 인터넷에 매우 많은데, 이 부분은 부족한 것 같아 꾸준히 영상으로 남길 예정입니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) 데이터 관련 커리어에 대한 이야기(취업, 이직 등)
        &lt;ul&gt;
          &lt;li&gt;특히 회사를 어떻게 찾아보고, 어떻게 준비할 것인가에 대한 제 전략을 공유할 예정입니다. 실제로 꽤- 많이 효과보았고, 면접을 많이 보는 사람의 입장도 섞을 예정입니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;3) Google Cloud Platform
        &lt;ul&gt;
          &lt;li&gt;GCP를 사용한지 벌써 4년이 넘었습니다. 이제 AWS보다 GCP가 더 익숙하네요&lt;/li&gt;
          &lt;li&gt;GCP 관련 유튜브 자료는 영어론 많지만, 한국어론 아직 적습니다. 지인은 글로벌하게 영어로 하라고 했지만 저는 일단 한국분들도 많이 GCP를 알 수 있도록 최대한 쉽게 설명하는 영상을 만드려고 합니다&lt;/li&gt;
          &lt;li&gt;특히 BigQuery부터 시작할 생각입니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;기타 MLOps나 Operation Research는 제 여건이 된다면..&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최소 2주에 영상 1개는 올리고 싶네요. 과연 어떻게 될지..!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;취업-컨설팅&quot;&gt;취업 컨설팅&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/70e6spuzzk9ib6m/Screenshot%202020-02-29%2021.01.43.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;글또 4기분들 중 희망자에 한해서(주로 데이터 직군) 취업 컨설팅을  합니다&lt;/li&gt;
  &lt;li&gt;이미 희망자를 모두 받았고, 자신에 대해 작성하는 시간을 가졌습니다&lt;/li&gt;
  &lt;li&gt;유튜브 영상에도 이야기할 예정이지만, 그래도 글또분들의 성장을 지켜보고 싶어 따로 컨설팅하기로 했습니다&lt;/li&gt;
  &lt;li&gt;6개월 내 취업이란 목표를 가지고 있는데, 모두 좋은 곳으로 가실 수 있도록 열심히 돕도록 하겠습니다!&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 29 Feb 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/diary/2020/02/29/geultto-4th/</link>
        <guid isPermaLink="true">http://localhost:4000/diary/2020/02/29/geultto-4th/</guid>
        
        <category>diary</category>
        
        
        <category>diary</category>
        
      </item>
    
      <item>
        <title>What If Tool 논문 리뷰 및 사용 방법?</title>
        <description>&lt;ul&gt;
  &lt;li&gt;~~~ 도구인 What If Tool(WIT) 논문 리뷰 및 사용 방법에 대해 작성한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;https://www.groundai.com/project/the-what-if-tool-interactive-probing-of-machine-learning-models/1 여기서 보구 번역기 해도될듯&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;what-if-tool이란&quot;&gt;What If Tool이란?&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;머신러닝 시스템을 개발하고 deploy하는 큰 문제는 input의 다양함에 따라 성능이 어떻게 되는지 이해하는지가 중요함. 이 도전 때문에 What If Tool을 만들었고, 코딩을 최소화하고 데이터를 조사하고, 시각화하고, ML 시스템을 분석한다&lt;/p&gt;

&lt;p&gt;What if Tool을 사용하면 실무자는 가상의 상황에서 성능을 테스트하고 다양한 데이터 feature의 중요성을 분석해 여러 모델 및 input 데이터 하위 집합에서 모델 동작을 시각화할 수 있음&lt;/p&gt;

&lt;p&gt;실무자들은 ML 공정성(fairness) 지표에 따라 시스템을 측정할 수 있음. 도구의 디자인을 설명하고 다른 조직의 실제 사용량에 대해 보고함&lt;/p&gt;

&lt;h3 id=&quot;1-introduction&quot;&gt;1. Introduction&lt;/h3&gt;

&lt;p&gt;머신러닝 작업에서 그들의 모델 성능이 좋은지 나쁜지 이해하고 싶어함.&lt;/p&gt;

&lt;p&gt;이 데이터 포인트가 내 예측에 얼마나 변화를 주는가? 내 모델은 여러 그룹에서 다양한 퍼포먼스를 내는지?&lt;/p&gt;

&lt;p&gt;WIT 툴은 모델을 이해할 수 있는 인터랙티브한 도구임&lt;/p&gt;

&lt;p&gt;도구를 사용하기 위해서 트레인 모델과 샘플 데이터셋만 있으면 됨. Tool은 Tensorboard의 일부로 사용할 수 있고, Jupyter나 Colab에서 사용할 수 있음&lt;/p&gt;

&lt;p&gt;WIT는 iterative what if 탐색을 제공한다.&lt;/p&gt;

&lt;p&gt;유저는 counterfactual(만약 ~ 다면) 추론을 하고 dicision boundaries를 조사하고, 데이터 포인트에 대한 일반적인 변경 사항이 예측에 미치는 영향을 탐색해 모델이 어떻게 동작하는지 시뮬레이션 할 수 있음&lt;/p&gt;

&lt;p&gt;입력 데이터 및 모델 성능의 유연한 시각화를 지원하고 사용자가 다른 관점으로 볼 수 있도록 해줌&lt;/p&gt;

&lt;p&gt;이런 시각화의 중요한 motivation은 데이터 세트의 다른 feature를 조합해 조각화하는 것임. (여러 feature의 조합)&lt;/p&gt;

&lt;p&gt;intersectional analysis, 교차 분석이라 부르고 이런 분석은 모델의 fairness 조사와 관련된 문제를 이해하는데 중요함&lt;/p&gt;

&lt;p&gt;WIT는 로컬(단일 데이터 포인트에 대한 decision 분석) 및 전체(전체에 대한 모델 동작 이해)를 모두 지원함. 또한 다양한 데이터 및 모델 유형을 지원함&lt;/p&gt;

&lt;p&gt;이 paper에선 도구의 디자인에 대해 설명하고 ML 시스템 분석에 실제로 적용되는 방법을 시나리오로 안내함. 사용자는 실제 시스템에 대한 놀라운 사실을 발견할 수 있었음. 결과는 가설 탐색을 지원하는 것이  ML 시스템의 동작을 이해하는 강력한 방법임을 제안함&lt;/p&gt;

&lt;h3 id=&quot;2-related-work&quot;&gt;2. Related Work&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;WIT는 ML 모델 이해하는 프레임워크와 유연한 시각화 플랫폼 2개의 영역을 가지고 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;21-model-understaging-frameworks&quot;&gt;2.1 Model understaging frameworks&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;WIT는 black box의 범주에 속함&lt;/li&gt;
  &lt;li&gt;모델의 내부에 의존하지 않지만 사용자가 입력 및 출력만 probe할 수 있도록 설계됨&lt;/li&gt;
  &lt;li&gt;이 제한은 실제 제약 조건(모델 내부에 항상 액세스 할 수 있는 것은 아니라는)을 반영하지만 매우 일반적인 것을 의미함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다른 여러 시스템이 블랙박스 방식을 취함&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Uber의 Manifold는 WIT와 동일한 기능을 제공함. 예를 들어 두 모델을 비교할 수 있는 정교한 시각화 세트가 있음.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/w8nyh8osh45nc5j/Screenshot%202020-02-17%2021.24.34.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/EnsembleMatrix-final.pdf&quot;&gt;EnsembleMatrix&lt;/a&gt;는 앙상블을 구성하는 모델을 비교하기 위해 고안된 반면 &lt;a href=&quot;https://arxiv.org/abs/1807.06228&quot;&gt;RuleMatrix&lt;/a&gt;는 간단한 규칙으로 ML 모델을 설명하려고 시도함&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/41wmac0ygvxc7n5/Screenshot%202020-02-17%2021.23.59.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/modeltracker-redesigning-performance-analysis-tools-for-machine-learning/&quot;&gt;ModelTracker&lt;/a&gt;는 WIT와 유사한 시스템으로, 샘플 데이터에서 모델 동작을 풍부하게 시각화함&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/opur8mgxixh4442/Screenshot%202020-02-17%2021.23.24.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://josuakrause.github.io/info/prospector.html&quot;&gt;Procpector&lt;/a&gt;도 WIT와 유사한데, 블랙박스 모델을 눈으로 검사할 수 있는 도구. 특정 데이터 포인트를 드릴 다운해 feature 값을 조작해 모델 예측에 미치는 영향을 확인할 수 있음. Prospector는 단일 클래스 예측 모델에 대한 input feature의 직교성에 의존하지만, WIT는 잠재적으로 상효 연관되거나 혼동된 여러 기능에 대한 교차 분석을 제공함&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/88qjx9ksjfbis3g/Screenshot%202020-02-17%2021.22.29.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기타 유사한 시스템은 &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2019/01/19_gamut_chi.pdf&quot;&gt;GAMut&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/44gam0fgxcsvmb0/Screenshot%202020-02-17%2021.21.41.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/ctdd3mqa9bycfok/Screenshot%202020-02-17%2021.22.01.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;툴의 중요한 motivation은 모델 이해와 사전 시각화 작업을 일반화하려는 것임
WIT의 주요 기능은 모델에서 mL 공정성 메트릭을 계산할 수 있음. IBM Ai Fairness 360, Audit AI, GAMut 도 유사한 기능을 제공함. 인터랙티브하게 최적화 과정을 적용해 사후 훈련 분류 임계값을 조정해 메트릭을 향상시킴&lt;/p&gt;

&lt;h3 id=&quot;22-flexibla-visualization-platform&quot;&gt;2.2 Flexibla visualization platform&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;WIT는 DAtapoint Editor tab이 있음. 이 부분은 Facets Dive으로 구성됨. 이걸 사용하면 여러 속성의 교차를 탐색해 input 데이터와 모델 결과의 사용자가 원하는대로 볼 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;X축, Y축 색상에 대한 인코딩을 빠르게 보여주는 것은 tableau에서 제공하는 일부 기능의 단순한 버전이고, 동일한 기능을 부드러운 애니메이션을 사용해 사용자가 인코딩간 전환을 이해하는데 도움이 되는 Micrsoft pivot tool도 있음&lt;/p&gt;

&lt;p&gt;Facets Dive는 local에 의존해 inmemory storage와 계산 기반으로 함. 민감한 데이터를 보호할 수 있음. 액세스가 제한되어 분석을 위해 원격 서버로 전송하는 것은 불가능함. 원활한 탐색도 가능&lt;/p&gt;

&lt;h3 id=&quot;3-background-and-overall-design&quot;&gt;3. BACKGROUND AND OVERALL DESIGN&lt;/h3&gt;
&lt;h4 id=&quot;31-user-needs&quot;&gt;3.1 User Needs&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1) 최소한의 코드로 다양한 가설을 테스트하고 싶음&lt;/li&gt;
  &lt;li&gt;2) 시각화를 모델 이해를 위한 매개체로 사용하고 싶음&lt;/li&gt;
  &lt;li&gt;3) 모드의 내부 작업에 액세스하지 않고 가상 테스트
    &lt;ul&gt;
      &lt;li&gt;WIT는 모델을 블랙박스로 다루어 “나이의 가치를 높이는 것이 모델의 예측 점수에 어떤 영향을 미칠까?” 또는 “데이터 포인트에서 다른 결과를 위해 무엇을 변경해야 하는가?”와 같은 질문에 답하기 위해 가상의 엔드투엔드 모델 행동에 대한 설명을 생성하도록 도와야 한다. 가설로 사용자는 하나 이상의 지정된 치수를 따라 데이터 지점의 동요에 대한 모델 성능을 테스트할 수 있다. 모델 내부를 이용할 수 없다면, 가설을 사용하여 생성된 설명은 모델에 구애받지 않고 동요에 일반화된다. 이는 설명과 표현의 유연성을 증가시킨다. 특히 평가되는 모델이 매우 복잡하기 때문에 의미 있게 해석할 수 없는 경우 [27]. 가설은 새로운 추측과 What-If 시나리오에 대한 모델 추론 결과의 조건 테스트 시 특히 강력하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4) 모델 성능에 대한 탐색적 교차 분석 수행&lt;/li&gt;
  &lt;li&gt;사용자는 종종 모형이 예기치 않게 수행되는 데이터의 하위 집합에 관심을 갖는다. 예를 들어, Buolamwini와 Gebru[9]는 특징만 아닌 교차로 부분군의 정확도를 조사하였고, 상업적으로 이용할 수 있는 이미지 분류기 3개가 시험 데이터에서 어두운 여성 부분군에서 가장 낮은 성능을 나타냈다고 밝혔다. 모델이 하위 그룹에서 높은 정확도를 달성하더라도, 잘못된 양의 비율과 거짓된 음의 비율은 크게 달라서 실제 결과를 초래할 수 있다[7]. 이러한 하위 집합을 정의하는 방법은 여러 가지가 있으므로 탐색 데이터 분석을 위한 시각화는 입력 데이터 유형, 모델 작업 및 최적화 전략에 대한 유연성, 확장성 및 사용자 지정을 유지해야 한다. 인스턴스(instance), 형상(feature), 부분 집합(subset) 및 결과 수준의 보완적인 뷰는 동일한 데이터 집합에서 여러 모델의 성능을 비교할 때 특히 통찰력이 뛰어나다.&lt;/li&gt;
  &lt;li&gt;5) 여러 모델에 대한 잠재적 성능 개선 평가&lt;/li&gt;
  &lt;li&gt;모델 개발에서는 분류 임계값을 변경하는 등 변화의 영향을 추적하기 어려울 수 있다. 예를 들어, 인구통계학적 패리티에 대한 임계값을 최적화하면 모든 그룹이 “유익한” 분류의 동일한 부분을 받도록 보장할 수 있으며, 반면 진정한 양의 비율이 낮은 하위 그룹은 불리하게 작용할 수 있다[13]. 훈련 데이터나 모델 하이퍼파라미터의 성능을 향상시키기 위해 변경하기 전에 다양한 비용에 대한 다양한 최적화 전략을 현지 및 전 세계적으로 테스트하고자 할 수 있다. 사용자는 분석을 오프라인으로 전환할 필요 없이 소규모 데이터 세트의 탐색 공간에서 바람직하지 않은 모델 동작을 완화하는 전략을 테스트하여 모델 성능을 대화형으로 디버그할 수 있어야 한다. 사용자가 모델의 변경을 시험하는 밀접하게 관련된 방법은 “제어” 모델의 성능을 벤치마크의 “실험” 버전에 비교하는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;흠 모델 하나 만들어봤는데 잘 안되네.. OTL&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;논문
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1907.04135.pdf&quot;&gt;https://arxiv.org/pdf/1907.04135.pdf&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Github
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/PAIR-code/what-if-tool&quot;&gt;https://github.com/PAIR-code/what-if-tool&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;아직 xgboost, sklearn 같은 곳에 직접 할 순 없음. ML Engine을 사용해야 할듯&lt;/li&gt;
  &lt;li&gt;공식 홈페이지의 What if tool 설명
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.tensorflow.org/tensorboard/what_if_tool&quot;&gt;https://www.tensorflow.org/tensorboard/what_if_tool&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ML Engine에서 What if Tool 사용하기
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/ml-engine/docs/using-what-if-tool?hl=ko&quot;&gt;https://cloud.google.com/ml-engine/docs/using-what-if-tool?hl=ko&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Video
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?time_continue=6&amp;amp;v=hpYl8WLYeKo&amp;amp;feature=emb_title&quot;&gt;https://www.youtube.com/watch?time_continue=6&amp;amp;v=hpYl8WLYeKo&amp;amp;feature=emb_title&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;송호연님 영상
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=ZAS2FwlLTNE&quot;&gt;https://www.youtube.com/watch?v=ZAS2FwlLTNE&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Notebook에서 사용하는 예제
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/tensorflow/tensorboard/blob/master/tensorboard/plugins/interactive_inference/README.md#notebook-mode-details&quot;&gt;https://github.com/tensorflow/tensorboard/blob/master/tensorboard/plugins/interactive_inference/README.md#notebook-mode-details&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Google 블로그 글
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://ai.googleblog.com/2018/09/the-what-if-tool-code-free-probing-of.html&quot;&gt;https://ai.googleblog.com/2018/09/the-what-if-tool-code-free-probing-of.html&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;블로그 글
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://towardsdatascience.com/using-what-if-tool-to-investigate-machine-learning-models-913c7d4118f&quot;&gt;https://towardsdatascience.com/using-what-if-tool-to-investigate-machine-learning-models-913c7d4118f&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모델 비교 Colab
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://colab.research.google.com/github/PAIR-code/what-if-tool/blob/master/WIT_Toxicity_Text_Model_Comparison.ipynb&quot;&gt;https://colab.research.google.com/github/PAIR-code/what-if-tool/blob/master/WIT_Toxicity_Text_Model_Comparison.ipynb&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예제
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://pair-code.github.io/what-if-tool/uci.html&quot;&gt;https://pair-code.github.io/what-if-tool/uci.html&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 17 Feb 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/mlops/2020/02/17/what-if-tool/</link>
        <guid isPermaLink="true">http://localhost:4000/mlops/2020/02/17/what-if-tool/</guid>
        
        <category>feature</category>
        
        
        <category>mlops</category>
        
      </item>
    
      <item>
        <title>BigQuery non-partition Table을 partition Table로 옮기기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;BigQuery의 non-partitioned Table을 partition Table로 옮기는 방법에 대해 작성한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;bigquery-partitioned-tables&quot;&gt;BigQuery Partitioned Tables&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;BigQuery엔 파티션을 기반으로 저장하는 Table이 있음&lt;/li&gt;
  &lt;li&gt;데이터를 보다 쉽게 관리하고, 쿼리할 수 있게 해줌&lt;/li&gt;
  &lt;li&gt;파티션을 추가하는 경우 장점은 다음과 같음
    &lt;ul&gt;
      &lt;li&gt;Query 탐색 범위를 줄임(=쿼리 탐색 비용 감소)
        &lt;ul&gt;
          &lt;li&gt;BigQuery는 쿼리가 데이터를 탐색하는 양만큼 비용을 부과함&lt;/li&gt;
          &lt;li&gt;파티션이 걸린 경우 해당 파티션 범위만 탐색하기 때문에 비용이 덜 부과될 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Query 속도가 빨라짐(=쿼리 성능 증가)
        &lt;ul&gt;
          &lt;li&gt;BigQuery에서 데이터의 양에 따라 쿼리 소요 시간이 달라짐&lt;/li&gt;
          &lt;li&gt;데이터의 양이 적으면 더 빠르게 결과가 나타남&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Partition 나누는 기준
    &lt;ul&gt;
      &lt;li&gt;1) Ingestion time(수집 시간) : 데이터 수집(로드) 날짜를 기준으로 파티션 나눔&lt;/li&gt;
      &lt;li&gt;2) DATE/TIMESTAMP : Date나 Timestamp로 파티션을 나눔&lt;/li&gt;
      &lt;li&gt;3) Integer(정수 범위) : 정수 값을 기준으로 파티션을 나눔&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;테이블 샤딩
    &lt;ul&gt;
      &lt;li&gt;날짜/타임스탬프로 파티션을 나눈 테이블이 아닌 Table 이름에 suffix를 붙여서 테이블을 샤딩할 수 있음&lt;/li&gt;
      &lt;li&gt;예: firebase 데이터가 저장되는 analytics_XXX 데이터셋의 Table들(analytics_XXX.events_20200211 등)&lt;/li&gt;
      &lt;li&gt;날짜/타임스탬프로 파티션을 나눈 테이블이 샤딩된 테이블보다 성능이 뛰어남&lt;/li&gt;
      &lt;li&gt;샤딩 테이블을 만들 땐 BigQuery가 각 테이블의 스키마 및 메타데이터 복사본을 유지해야 하고, 각 쿼리 대상 테이블의 권한을 확인해야 함
        &lt;ul&gt;
          &lt;li&gt;쿼리 오버헤드가 추가되고 쿼리 성능에 영향을 미침&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;따라서 샤딩보다 날짜/타임스탬프로 파티션을 나눈 테이블 사용하는 것이 좋음&lt;/li&gt;
      &lt;li&gt;샤딩된 테이블은 쿼리시 최대 1,000개의 테이블만 참조할 수 있고, 날짜/타임스탬프로 파티션을 나눈 테이블은 최대 4,000개의 파티션을 가질 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;non-partitioned-table을-partitioned-table로-복사하기&quot;&gt;Non-partitioned Table을 Partitioned Table로 복사하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;특정 Task를 반복해서 수행하는 경우
    &lt;ul&gt;
      &lt;li&gt;예를 들어 서비스의 Raw 데이터를 가공해 테이블에 적재하는 경우&lt;/li&gt;
      &lt;li&gt;처음부터 만든다면 아예 Partitioned Table로 만들어서 Airflow 등에서 실행시키면 됨&lt;/li&gt;
      &lt;li&gt;단, 이미 서비스가 어느정도 운영한 후에 특정 시점에 데이터를 Migration하고 그 다음 날부터 Airflow DAG을 돌리고 싶은 경우 과거 데이터를 한번에 복사해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;과거 데이터를 복사할 때, BigQuery UI에서 쿼리를 날리고 Table로 저장하는 방법이 있음
    &lt;ul&gt;
      &lt;li&gt;그러나 “Incompatible table partitioning specification when copying to the column partitioned table” Error가 발생함&lt;/li&gt;
      &lt;li&gt;Partition Spec이 호환되지 않아 발생한 문제&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;터미널에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;bq query&lt;/code&gt;를 사용함
    &lt;ul&gt;
      &lt;li&gt;bq query가 길어질 것 같아 쉘스크립트 작성(query_to_partition_table.sh)&lt;/li&gt;
      &lt;li&gt;bq query는 Query의 결과를 Table로 바로 저장해주고, 파티션 옵션도 설정할 수 있음&lt;/li&gt;
      &lt;li&gt;destination_table의 뒤를 수정하고 맨 아래 SELECT 부분을 수정하면 됨&lt;/li&gt;
      &lt;li&gt;time_partitioning_field는 date_kr이고, require_partition_filter=True를 주면 쿼리할 때 항상 WHERE 절에 파티션 필터를 걸어야 함
        &lt;ul&gt;
          &lt;li&gt;BigQuery를 안정적으로 운영하기 위해 이 옵션은 꼭 주는 것을 추천&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
bq &lt;span class=&quot;nt&quot;&gt;--location&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;US query &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--destination_table&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;dataset&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;.&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;table&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--time_partitioning_field&lt;/span&gt; date_kr &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--require_partition_filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;True &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--use_legacy_sql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;s1&quot;&gt;'
SELECT 
  *, date_kr
FROM Table
'&lt;/span&gt;	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;실행&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  bash query_to_partition_table.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;혹시 Error가 발생한다면&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;bq command가 제대로 작동하는지?
        &lt;ul&gt;
          &lt;li&gt;작동하지 않으면 Cloud SDK를 설치&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sdk/docs/?hl=ko&quot;&gt;공식 문서&lt;/a&gt; 참고해서 설치하면 됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;gcloud에 원하는 프로젝트 설정이 되어있는지?
        &lt;ul&gt;
          &lt;li&gt;아래 명령어를 통해 현재 로컬에 설치된 gcloud 설정을 확인
            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud config configurations list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;원하는 프로젝트의 설정이 없다면 gcloud init을 통해 새 설정을 추가&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;SELECT 쿼리에서 ‘‘을 사용하는 경우
        &lt;ul&gt;
          &lt;li&gt;예 : SELECT * FROM Table WHERE event_name=’user_engagement’&lt;/li&gt;
          &lt;li&gt;&quot;”로 수정해야 함. 쉘 스크립트에선 ‘‘와 ““이 다름&lt;/li&gt;
          &lt;li&gt;스택오버플로우의 &lt;a href=&quot;https://stackoverflow.com/questions/6697753/difference-between-single-and-double-quotes-in-bash&quot;&gt;Difference between single and double quotes in Bash&lt;/a&gt; 글에 자세히 나옴&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Google Cloud Platform Document
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/bigquery/docs/managing-partitioned-tables#copying_partitioned_tables&quot;&gt;Managing partitioned tables&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 11 Feb 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/gcp/2020/02/11/bigquery_query_to_partition_table/</link>
        <guid isPermaLink="true">http://localhost:4000/gcp/2020/02/11/bigquery_query_to_partition_table/</guid>
        
        <category>BigQuery</category>
        
        
        <category>gcp</category>
        
      </item>
    
      <item>
        <title>머신러닝 프레임워크 Hopsworks</title>
        <description>&lt;ul&gt;
  &lt;li&gt;머신러닝 프레임워크 Hopsworks를 설치하고 사용하며 작성한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;설치&quot;&gt;설치&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;이준범님의 &lt;a href=&quot;https://beomi.github.io/2020/02/03/Lookup-HopsWorks/&quot;&gt;블로그&lt;/a&gt;를 보면 AWS에서 설치하는 과정에 나옴&lt;/li&gt;
  &lt;li&gt;GCP에서 설치할 예정이며, &lt;a href=&quot;https://hopsworks.readthedocs.io/en/latest/getting_started/setups/hopsworks_gcp.html&quot;&gt;Document&lt;/a&gt;ㄹ를 참고함&lt;/li&gt;
  &lt;li&gt;프로젝트 셋팅
    &lt;ul&gt;
      &lt;li&gt;GCP 계정을 만들고, 프로젝트 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Hopsworks Image 생성
    &lt;ul&gt;
      &lt;li&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 05 Feb 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/mlops/2020/02/05/hopsworks/</link>
        <guid isPermaLink="true">http://localhost:4000/mlops/2020/02/05/hopsworks/</guid>
        
        <category>feature</category>
        
        
        <category>mlops</category>
        
      </item>
    
      <item>
        <title>Machine Learning의 Feature Store란?</title>
        <description>&lt;ul&gt;
  &lt;li&gt;머신러닝의 Feature Store에 대해 작성한 글입니다
    &lt;ul&gt;
      &lt;li&gt;Feature Store가 왜 필요한지?와 어떤 종류들이 있는지? 등에 대해 작성했습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;머신러닝의-모델링-과정&quot;&gt;머신러닝의 모델링 과정&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;머신러닝 모델링 업무의 큰 흐름은 다음과 같음
    &lt;ul&gt;
      &lt;li&gt;데이터 적재&lt;/li&gt;
      &lt;li&gt;데이터 EDA 및 분석&lt;/li&gt;
      &lt;li&gt;Feature Engineering&lt;/li&gt;
      &lt;li&gt;모델링(모델 선정, 하이퍼 파라미터 튜닝, metric 선정 과정 포함)&lt;/li&gt;
      &lt;li&gt;Test Set에 성능 개선되었는지 확인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모델이 완성되면, 그 후에 실제 서비스에 활용하기 위해 아래와 같은 과정을 거침(Production, Serving 과정)
    &lt;ul&gt;
      &lt;li&gt;실시간 데이터 적재 확인&lt;/li&gt;
      &lt;li&gt;실시간 데이터에 기반한 Feature Engineering&lt;/li&gt;
      &lt;li&gt;모델 학습&lt;/li&gt;
      &lt;li&gt;필요시 모델 업데이트&lt;/li&gt;
      &lt;li&gt;Inference&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;production시-발생할-수-있는-문제&quot;&gt;Production시 발생할 수 있는 문제&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1) 데이터 스트리밍 파이프라인 존재 유무
    &lt;ul&gt;
      &lt;li&gt;데이터 ETL 파이프라인은 초반엔 배치성으로 생성해 관리하는 경우가 있음(더 쉽고, 빠르게 가능)&lt;/li&gt;
      &lt;li&gt;이 경우, 모델을 Production화하기 위해 데이터를 실시간으로 적재해야 함&lt;/li&gt;
      &lt;li&gt;Kafka, Redis, GCP Pub/Sub, REST API 등을 활용해 데이터를 적재&lt;/li&gt;
      &lt;li&gt;단, 예측하려는 문제에 따라 실시간보다 배치성으로 예측해도 괜찮은 경우가 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2) Feature Engineering 소요되는 시간
    &lt;ul&gt;
      &lt;li&gt;실시간으로 생성되는 데이터를 기반으로 Feature Engineering 수행&lt;/li&gt;
      &lt;li&gt;Spark나 BigQuery 같은 SQL 기반으로 전처리할 수도 있고, Python의 Pandas 등을 사용할 수도 있음&lt;/li&gt;
      &lt;li&gt;그러나 Feature Engneering의 연산이 복잡한 경우, Feature를 생성하는 시간이 오래 걸릴 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3) 오프라인과 온라인에서 사용한 Feature의 차이
    &lt;ul&gt;
      &lt;li&gt;오프라인 : 실시간이 아닌 데이터를 사용하는 환경(주로 배치성)&lt;/li&gt;
      &lt;li&gt;온라인 : 실시간으로 데이터가 스트리밍되는 환경&lt;/li&gt;
      &lt;li&gt;오프라인은 주로 배치성으로 적재되기 때문에, 그 과정에서 미리 복잡한 연산을 해서 저장할 수 있음. 그러나 온라인 적재는 복잡한 연산을 하지 못하거나(혹은 개발 리소스의 부족으로) 따로 처리해야할 수 있음&lt;/li&gt;
      &lt;li&gt;같은 로직으로 처리하려 했으나, 처리하는 시간에 따라 값이 다르게 계산되는 경우가 존재함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4) 데이터 프로토콜의 부재
    &lt;ul&gt;
      &lt;li&gt;데이터를 실시간으로 적재하는 부분은 데이터 엔지니어 직군이, 모델링을 위해 데이터 전처리하는 부분은 데이터 사이언티스트(혹은 머신러닝 엔지니어)가 진행하는데, 두 조직의 프로토콜이 없는 경우도 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;5) 서비스에서 많은 머신러닝 모델이 생기는 경우
    &lt;ul&gt;
      &lt;li&gt;머신러닝 모델이 소수인 경우(1-2개) 단일 모델을 위해 시스템을 구축하는 것은 비효율적이라 판단할 수 있음&lt;/li&gt;
      &lt;li&gt;하지만 모델이 많아지고, 동일한 Feature를 사용할 경우엔 각각의 모델링 과정에서 Feature Engineering을 진행하면 모델의 개수만큼 연산을 진행해야 함&lt;/li&gt;
      &lt;li&gt;즉, 재사용성이 떨어짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;6) 과거 Feature를 사용해야 하는 경우
    &lt;ul&gt;
      &lt;li&gt;보통 시간과 관련된 Feature들이 많은데, 이 Feature들은 시간이 지나며 점점 값이 바뀜(1월 1일 시점에 최근 1시간 전 데이터와 1월 5일 시점에 최근 1시간 전 데이터는 다름)&lt;/li&gt;
      &lt;li&gt;이럴 경우 index가 있거나, Backfill 기능이 있어야 함
        &lt;ul&gt;
          &lt;li&gt;혹시 잠시 Feature 관련 코드가 장애날 경우에 과거 값을 계산해야할 수 있음&lt;/li&gt;
          &lt;li&gt;Backfill : 간단히 말해서 예전 데이터를 계산&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;feature-store&quot;&gt;Feature Store&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;발생할 수 있는 문제들을 위해 Feature Store를 구축&lt;/li&gt;
  &lt;li&gt;Feature Store Layer를 추가한다고 표현함
    &lt;ul&gt;
      &lt;li&gt;Feature Store의 오픈소스는 Hopsworks와 feast가 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터를 Train, Serving 할 때 모두 사용할 수 있도록 통합해서 저장함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;feature-store-예시&quot;&gt;Feature Store 예시&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;다양한 회사들이 자신들이 구축한 Feature Store에 대해 발표함
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://featurestore.org/&quot;&gt;featurestore.org&lt;/a&gt;에 다양한 Feature Store에 대한 영상들이 있음&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/pv1z1likpl2rred/Screenshot%202020-02-02%2021.04.36.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;많은 회사들이 비슷한 개념으로 개발함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Hopsworks의 Feature Store
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.logicalclocks.com/featurestorepage&quot;&gt;Document&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://uploads-ssl.webflow.com/5c9b9758feba5a6f9e8a6dda/5d92b35b15962a46c7ce9c5f_feature%20store%20whitepaper%201-0.pdf&quot;&gt;WHITE PAPER&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/cpd34cfddgof93j/Screenshot%202020-02-02%2020.15.05.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;White Paper(백서)를 참고하면 어떤 구조로 만들었는지 나옴&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/89pqyiyholerbpq/Screenshot%202020-02-02%2020.10.16.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Offline Features와 Online Features를 저장함&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/yduxbp05nyuljlm/Screenshot%202020-02-02%2020.16.16.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Hopsworks의 End to End System&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Gojek의 Feast
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/gojek/feast&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/vmcs1codtvxoncm/Screenshot%202020-02-02%2020.17.58.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Offline은 BigQuery에 저장하고, Online은 BigTable에 저장함&lt;/li&gt;
      &lt;li&gt;Google Cloud Platform과 공동으로 개발한 프로그램
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/blog/products/ai-machine-learning/introducing-feast-an-open-source-feature-store-for-machine-learning&quot;&gt;Introducing Feast: an open source feature store for machine learning&lt;/a&gt; 글에 나와있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Uber의 Michelangelo
    &lt;ul&gt;
      &lt;li&gt;우버의 머신러닝 플랫폼으로 Feature Store 및 다양한 기능이 제공됨&lt;/li&gt;
      &lt;li&gt;Uber Techblog &lt;a href=&quot;https://eng.uber.com/michelangelo/&quot;&gt;Meet Michelangelo: Uber’s Machine Learning Platform&lt;/a&gt;, &lt;a href=&quot;https://eng.uber.com/michelangelo-model-representation/&quot;&gt;Evolving Michelangelo Model Representation for Flexibility at Scale&lt;/a&gt;에 나와있음&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/dumuvgwgcl1u4f1/Screenshot%202020-02-02%2020.21.04.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;AirBnB의 Zipline
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://databricks.com/session/zipline-airbnbs-machine-learning-data-management-platform&quot;&gt;Zipline: Airbnb’s Machine Learning Data Management Platform&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/e7qc7yqy8htub6f/Screenshot%202020-02-02%2020.25.46.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Netflix의 Metaflow
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/Netflix/metaflow&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/qu09q2o1wts59li/Screenshot%202020-02-02%2020.28.53.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/d87xc5zn2xe8a37/Screenshot%202020-02-02%2020.29.16.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Airflow의 Dependency를 정의하는 것을 코드로 진행하는듯&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/i5y6j70ldyijj0z/Screenshot%202020-02-02%2020.39.18.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://featurestore.org&quot;&gt;featurestore.org&lt;/a&gt;에 나와있는 Feature Store Comparison 정리한 표
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/qtencu283usl0m6/Screenshot%202020-02-02%2021.03.27.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;hopsworks&quot;&gt;Hopsworks&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.logicalclocks.com/&quot;&gt;Homepage&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;Hopsworks는 전체 프레임워크 단위고, Feature Store가 그 중에 한 부분&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://hopsworks.readthedocs.io/en/latest/getting_started/gettingstarted.html&quot;&gt;링크&lt;/a&gt;에 AWS, GCP, 단일 인스턴스에 설치하는 방법에 대해 나와있음&lt;/li&gt;
  &lt;li&gt;Feature Store
    &lt;ul&gt;
      &lt;li&gt;Feature Store와 함께 프로젝트 생성
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/jmhbzgfmgwhht7t/Screenshot%202020-02-02%2020.46.02.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;등록된 Feature Groups을 볼 수 있음. Cached, On Demand 타입인지, Version, 분포(파란색 버튼) 등을 볼 수 있음
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/st7qg91mvi33h29/Screenshot%202020-02-02%2020.48.22.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Feature Unit Testing Page
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/foc0t1nqfo6ufqj/Screenshot%202020-02-02%2020.51.32.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/291dsicqwclvogf/Screenshot%202020-02-02%2020.52.53.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;Feature의 Constraint를 추가할 수 있음. 이 조건들로 데이터 Validation을 실행함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Feature 추가하기&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from hops import featurestore
  featurestore.insert_into_featuregroup(features_df, featuregroup_name)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Feature 가져오기&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from hops import featurestore
  features_df = featurestore.get_features([&quot;average_attendance&quot;, &quot;average_player_age&quot;])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Airflow를 사용해 Validation 후, 작업하기도 함
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/logicalclocks/hops-examples/tree/master/airflow&quot;&gt;Github&lt;/a&gt; 참고&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  validation = HopsworksLaunchOperator(dag=dag,
                                       project_name=PROJECT_NAME,
                                       # Arbitrary task name
                                       task_id=&quot;validation_job&quot;,
                                       job_name=VALIDATION_JOB_NAME)
		
  # Fetch validation result
  result = HopsworksFeatureValidationResult(dag=dag,
                                            project_name=PROJECT_NAME,
                                            # Arbitrary task name
                                            task_id=&quot;parse_validation&quot;,
                                            feature_group_name=FEATURE_GROUP_NAME)
		
  # Run first the validation job and then evaluate the result
  validation &amp;gt;&amp;gt; result
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;그 외에도 hopsworks는 데이터 공유하기, 노트북 환경 생성, 제플린, 텐서보드 등 다양한 기능을 제공함
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/z7jhxbr23i3vftc/Screenshot%202020-02-02%2020.56.19.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;gojek의-feast&quot;&gt;Gojek의 feast&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.feast.dev/&quot;&gt;공식 문서&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;사용 예시
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/d2p211o55bky7v3/Screenshot%202020-02-02%2020.57.42.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/qefoqo5f0ksnj16/Screenshot%202020-02-02%2020.58.42.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;설치는 Docker Composer, Google Kubernetes Engine(GKE)에서 하는 방법에 대해 &lt;a href=&quot;https://docs.feast.dev/installing-feast/overview&quot;&gt;공식 문서&lt;/a&gt;에 나와있음
    &lt;ul&gt;
      &lt;li&gt;BigQuery, Dataflow, Cloud Storage 등 GCP 친화적으로 보임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;어떻게-해야할까&quot;&gt;어떻게 해야할까?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;현재 주어진 요구사항에 따라 다른 접근이 필요&lt;/li&gt;
  &lt;li&gt;처음부터 Feature Store를 구축하면 좋으나, 지속적으로 모델링하며 어떤 요구사항이 있을지 알 수 없음&lt;/li&gt;
  &lt;li&gt;따라서 처음엔 나이브하게 시작하는 것도 좋다고 생각
    &lt;ul&gt;
      &lt;li&gt;자주 사용하는 Feature를 Airflow 등에서 스케쥴링&lt;/li&gt;
      &lt;li&gt;1시간별 수요를 Table로 N분 단위로 스케줄링해서 특정 Table에 저장&lt;/li&gt;
      &lt;li&gt;그러다가 점점 모델이 많아질 때 고도화하면 좋을듯&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Feature Store도 중요하지만, Data가 들어올 때 Validation 체크하는 것도 매우 중요함&lt;/li&gt;
  &lt;li&gt;Hopsworks를 직접 실행시켜서 아이디어를 얻은 후, 직접 개발하는 것이 더 좋을 수 있음(Hopsworks는 엄청 큰데, 모두 회사에 필요할까?란 고민이 필요)&lt;/li&gt;
  &lt;li&gt;다음 글은 Hopsworks를 직접 띄워서, 어떤 구성 요소가 있고 어떻게 활용할지에 대해 작성하겠습니다 :)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://featurestore.org/&quot;&gt;featurestore.org&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://youtu.be/EI2QisCvEM4&quot;&gt;The Feature Store - Jim Dowling&lt;/a&gt; : Hopsworks에 대한 영상&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://technology.condenast.com/story/accelerating-machine-learning-with-the-feature-store-service&quot;&gt;Accelerating Machine Learning with the Feature Store Service&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/blog/products/ai-machine-learning/introducing-feast-an-open-source-feature-store-for-machine-learning&quot;&gt;Introducing Feast: an open source feature store for machine learning&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://towardsdatascience.com/feature-stores-components-of-a-data-science-factory-f0f1f73d39b8&quot;&gt;Feature Stores: Components of a Data Science Factory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.logicalclocks.com/blog/feature-store-the-missing-data-layer-in-ml-pipelines&quot;&gt;Feature Store: The missing data layer in ML pipelines?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@changshe/rethinking-feature-stores-74963c2596f0&quot;&gt;Rethinking Feature Stores&lt;/a&gt;
-&lt;a href=&quot;https://github.com/gojek/feast&quot;&gt;gojek feast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 02 Feb 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/mlops/2020/02/02/feature-store/</link>
        <guid isPermaLink="true">http://localhost:4000/mlops/2020/02/02/feature-store/</guid>
        
        <category>feature</category>
        
        
        <category>mlops</category>
        
      </item>
    
      <item>
        <title>Voila를 사용해 Jupyter Notebook Dashboard 만들기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Jupyter notebook에서 voila를 사용해 대시보드 만드는 방법에 대해 작성한 글입니다
    &lt;ul&gt;
      &lt;li&gt;R의 Shiny처럼 Python Jupyter Notebook에선 Voila를 사용하면 빠르게 웹에 대시보드를 띄울 수 있습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;voila를-사용하게-된-이유&quot;&gt;Voila를 사용하게 된 이유&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;대시보드는 다양한 대체 수단이 많음
    &lt;ul&gt;
      &lt;li&gt;Tableau, 스프레드시트, Superset, Metabase 등&lt;/li&gt;
      &lt;li&gt;대부분의 경우엔 BI 도구를 활용해도 충분함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;종종 발생하는 경우
    &lt;ul&gt;
      &lt;li&gt;1) 지도에 데이터를 뿌려야 할 경우, 지도 표현을 잘 제공한다면 문제되지 않지만 지도를 잘 지원해주는 BI 도구는 적음&lt;/li&gt;
      &lt;li&gt;2) 파이썬으로 전처리를 해야할 경우
        &lt;ul&gt;
          &lt;li&gt;위 두가지 경우 Jupyter Notebook에 코드를 작성하고 주기적으로 html으로 저장할 수 있음&lt;/li&gt;
          &lt;li&gt;그러나 html이 아닌 ipywidget 등을 사용해 특정 시점의 데이터를 볼 수 있도록 만들려면 노트북에서 결과를 한번 실행해야 함(html 추출시 ipywidget은 같이 추출되지 않음)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;3) 노트북에서 시각화, 지표 확인을 모두 하고싶은 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Voila를 사용하면 ipywidget과 노트북을 같이 렌더링해줌
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://plot.ly/dash/&quot;&gt;Dash&lt;/a&gt;나 &lt;a href=&quot;https://github.com/plotly/jupyterlab-dash&quot;&gt;julyterlab-dash&lt;/a&gt;도 있지만 쉬운 사용성은 아니라 생각해 Voila를 선택함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.jupyter.org/voil%C3%A0-is-now-an-official-jupyter-subproject-87d659583490&quot;&gt;블로그 글&lt;/a&gt;에 따르면 Jupyter의 하위 프로젝트로 통합되었다고 함
    &lt;ul&gt;
      &lt;li&gt;아직 0.1.20 버전이지만 추후 더 발전할 가능성이 있다고 생각&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;voila의-특징&quot;&gt;Voila의 특징&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1) Jupyter Notebook 결과를 쉽게 웹에 띄울 수 있음&lt;/li&gt;
  &lt;li&gt;2) Ipywidget, Ipyleaflet 등 사용 가능&lt;/li&gt;
  &lt;li&gt;3) Jupyter Notebook의 Extension 있음(=노트북에서 바로 대시보드로 변환 가능)&lt;/li&gt;
  &lt;li&gt;4) Python, Julia, C++ 코드 지원&lt;/li&gt;
  &lt;li&gt;5) 고유의 템플릿을 생성 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;설치&quot;&gt;설치&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Mac OS 기준&lt;/li&gt;
  &lt;li&gt;jupyter client 업그레이드
    &lt;ul&gt;
      &lt;li&gt;cannot import name ‘secure_write’ from ‘jupyter_core.paths’ 에러가 발생할 경우 jupyter_client 업그레이드&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pip3 install --upgrade jupyter_client
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pip로 설치&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pip3 install voila
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JupyterLab preview extension 설치(JupyterLab 사용시만)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  jupyter labextension install @jupyter-voila/jupyterlab-preview 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;혹시 &lt;code class=&quot;highlighter-rouge&quot;&gt;jupyter-labextension&lt;/code&gt; not found Error가 발생한다면 jupyterlab을 설치하지 않은 것&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pip3 install jupyterlab
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;notebook이나 jupyter_server extension 설치&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  jupyter serverextension enable voila --sys-prefix
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;아래 명령어로 voila/extension이 enabled인지 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  jupyter nbextension list
	
  # jupyter_server의 경우
  jupyter serverextension list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;사용-방법&quot;&gt;사용 방법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;간단한 Jupyter Notebook 파일 생성(이름 : voila_test)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import ipywidgets as widgets
	
  slider = widgets.FloatSlider(description='$x$', value=4)
  text = widgets.FloatText(disabled=True, description='$x^2$')
	
  def compute(*ignore):
      text.value = str(slider.value ** 2)
	
  slider.observe(compute, 'value')
	
  widgets.VBox([slider, text])
	
	
  import pandas as pd
	
  iris = pd.read_csv('https://raw.githubusercontent.com/mwaskom/seaborn-data/master/iris.csv')
  iris.tail()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/j860wjyczof67qn/Screenshot%202020-01-05%2023.35.54.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1) voila로 노트북 렌더링(코드 안보임)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  voila voila_test.ipynb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;localhost:8866로 접근하면 아래 결과를 확인할 수 있음&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/nwadtjn90g91y10/Screenshot%202020-01-05%2023.38.04.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2) voila로 노트북 렌더링(코드 보임)
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--strip_sources=False&lt;/code&gt; 조건을 주면 기존 노트북의 코드도 보임(셀 실행은 불가능)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  voila voila_test.ipynb --strip_sources=False
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9kpk06i1iopb8p5/Screenshot%202020-01-05%2023.50.44.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3) voila 폴더 실행&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  voila
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;현재 폴더에 있는 파일을 voila로 실행할 수 있음&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/x9qxh3ng2m5vggh/Screenshot%202020-01-05%2023.49.17.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4) Notebook의 Extension 클릭
    &lt;ul&gt;
      &lt;li&gt;노트북 실행 후 Voila 클릭하면 1)과 같은 결과가 바로 보임&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/197ea45xswots7y/Screenshot%202020-01-05%2023.45.18.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;옵션이 더 궁금하다면 터미널에서 아래 명령어 입력&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  voila --help
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;사용하며-체득한-tip&quot;&gt;사용하며 체득한 Tip&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Voila 실행시 셀 타임아웃 제한이 있음
    &lt;ul&gt;
      &lt;li&gt;기본적으로 한 셀을 실행하는데 30초 소요되면 Timeout Error 발생(터미널 로그에만 남고 웹은 계속 진행중 처럼 나옴)&lt;/li&gt;
      &lt;li&gt;voila 실행시 아래 명령어를 사용해 타임아웃을 늘릴 수 있음&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/voila-dashboards/voila/pull/240&quot;&gt;참고한 Github Pull request&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  voila --ExecutePreprocessor.timeout=180
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;보안 이슈 해결하기
    &lt;ul&gt;
      &lt;li&gt;해당 &lt;a href=&quot;https://github.com/voila-dashboards/voila/issues/216&quot;&gt;이슈&lt;/a&gt;를 보면 oauth 기능을 추가할 예정인듯&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/jupyterhub/oauthenticator&quot;&gt;oauthenticator&lt;/a&gt;를 사용해 직접 만들까 고민하다 Notebook의 암호를 사용하는 방법을 생각함&lt;/li&gt;
      &lt;li&gt;암호 생성
        &lt;ul&gt;
          &lt;li&gt;터미널에서 Python3 실행 후, 아래 커맨드 입력&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from IPython.lib import passwd
  passwd()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;ul&gt;
          &lt;li&gt;‘sha1:~~’ 복사하기&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;jupyter_notebook_config.py 생성&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  vi ~/.jupyter/jupyter_notebook_config.py
		
  c = get_config()
  c.NotebookApp.password = 'sha1:~~~ 붙여넣기'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;notebook을 재실행하면 암호 입력하게 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;특정 nbextension이 404 발생하는 경우
    &lt;ul&gt;
      &lt;li&gt;voila로 직접 노트북 파일 실행시 특정 nbextension(pydeck쪽)이 404가 발생해서 아래 명령어로 해결&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  voila your_notebook.ipynb --enable_nbextensions=True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;jupyter notebook extension에서 voila를 실행할 경우엔 인자를 줄 수 없고, notebook 실행시 옵션을 줘야함. &lt;a href=&quot;https://voila.readthedocs.io/en/stable/customize.html#configure-voila-for-the-jupyter-server&quot;&gt;[참고 문서]&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  jupyter notebook --ExecutePreprocessor.timeout=180 --VoilaConfiguration.enable_nbextensions=True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;사용-예시&quot;&gt;사용 예시&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://voila-gallery.org/services/gallery/&quot;&gt;Voila Gallery&lt;/a&gt;에 여러 예시가 존재함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/jssv5xfyznzb2yz/Screenshot%202020-01-06%2000.05.26.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/dhaitz/machine-learning-interactive-visualization&quot;&gt;machine-learning-interactive-visualization&lt;/a&gt;이 눈에 띄어서 소스를 clone한 후 실행해봄
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/fe3wsipsq6vkttq/Screenshot%202020-01-06%2000.35.21.gif?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/bloomberg/bqplot&quot;&gt;bqplot&lt;/a&gt;도 Voila를 사용해 쉽게 대시보드화 할 수 있음&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/voila-dashboards/voila-vuetify&quot;&gt;volia-vuetify&lt;/a&gt;엔 VuetifyJS를 사용한 대시보드 템플릿을 볼 수 있음
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/46192475/59274938-9c144f00-8c5b-11e9-961e-c33854b6e50a.gif&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;배포&quot;&gt;배포&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://voila.readthedocs.io/en/stable/deploy.html&quot;&gt;공식 문서&lt;/a&gt;를 보면 &lt;a href=&quot;mybinder.org&quot;&gt;mybinder.org&lt;/a&gt;, Heroku, Google App Engine 등에서 배포하는 방법이 간단히 나와있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;voila-architecture&quot;&gt;Voila Architecture&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/28pggskzariqlb5/Screenshot%202020-01-05%2023.54.31.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/voila-dashboards/voila&quot;&gt;Voila Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.jupyter.org/and-voil%C3%A0-f6a2c08a4a93&quot;&gt;And voila&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.jupyter.org/voil%C3%A0-is-now-an-official-jupyter-subproject-87d659583490&quot;&gt;Voilà is now a Jupyter subproject&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/maartenbreddels/voila-demo&quot;&gt;voila demo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=VtchVpoSdoQ&quot;&gt;Dashboarding with Jupyter Notebooks, Voila and Widgets&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=L91rd1D6XTA&quot;&gt;Turn any Notebook into a Deployable Dashboard&lt;/a&gt; : 이건 Panel 이야기긴한데, 비교할만한 대상인듯&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 06 Jan 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/development/2020/01/06/jupyter_notebook_voila_dashboard/</link>
        <guid isPermaLink="true">http://localhost:4000/development/2020/01/06/jupyter_notebook_voila_dashboard/</guid>
        
        <category>python</category>
        
        
        <category>development</category>
        
      </item>
    
      <item>
        <title>Julia Language 프로그래밍 언어 기본 문법 정리</title>
        <description>&lt;ul&gt;
  &lt;li&gt;프로그래밍 언어인 Julia Language 기본 문법에 대한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;julia&quot;&gt;Julia&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/jz1efghzgj0u39l/Screenshot%202019-12-27%2017.58.28.png?raw=1&quot; height=&quot;100&quot; weight=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Julia는 MIT에서 개발한 언어로 2012년에 처음 개발함&lt;/li&gt;
  &lt;li&gt;Two langauge problem
    &lt;ul&gt;
      &lt;li&gt;Performance(fortan, c, asm) vs Productivity(python, ruby, matlab) vs Generality&lt;/li&gt;
      &lt;li&gt;이런 문제를 해결하고자 Julia를 만듬&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;looks like python, feels like lisp, runs like C
    &lt;ul&gt;
      &lt;li&gt;Julia는 C만큼 빠름
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/kmybg4myv1ffds2/Screenshot%202019-12-26%2023.05.34.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Julia는 R, Matlab, Python 같이 high level로 수치 계산하기 좋고, 일반 범용 목적의 프로그래밍도 지원함&lt;/li&gt;
      &lt;li&gt;메타프로그래밍을 할 수 있음(macros, multiple dispatch)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;수치 해석(Numerical Analysis), 최적화(Optimization) 문제 등 고성능이 필요한 수학적 계산 처리를 주로 품&lt;/li&gt;
  &lt;li&gt;index 숫자가 1부터 시작함&lt;/li&gt;
  &lt;li&gt;Python에서 Julia 실행 가능 : &lt;a href=&quot;https://github.com/JuliaPy/pyjulia&quot;&gt;pyjulia&lt;/a&gt; 사용&lt;/li&gt;
  &lt;li&gt;Julia에서 Python 실행 가능 : PyCall 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;julia-사용-사례&quot;&gt;Julia 사용 사례&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Celeste
    &lt;ul&gt;
      &lt;li&gt;Sloan Digital Sky Survey Data로 178 terabytes&lt;/li&gt;
      &lt;li&gt;천문학 이미지 분석하기 위해 Julia를 활용함&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://juliacomputing.com/case-studies/celeste.html&quot;&gt;Parallel Supercomputing for Astronomy&lt;/a&gt;에 자세한 내용이 나옴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용하는 회사
    &lt;ul&gt;
      &lt;li&gt;2018년 기준이고 지금은 더 많을듯&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/hdwhw213xd3b483/Screenshot%202019-12-26%2023.27.22.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;julia-설치하기&quot;&gt;Julia 설치하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Mac OS 기준&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  brew cask install julia
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;터미널에서 Julia를 입력한 후 아래와 같은 내용이 뜨면 성공&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/e96v3lgc4m8mz3m/Screenshot%202019-12-26%2022.42.37.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;jupyter-notebook에서-julia-사용하기&quot;&gt;Jupyter Notebook에서 Julia 사용하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;IJulia 사용&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;터미널에서 Julia를 입력해서 Julia prompt로 이동 후 아래 명령어 입력&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ENV[&quot;PYTHON&quot;] = &quot;&quot;
  ENV[&quot;JUPYTER&quot;] = &quot;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IJulia 설치(Julia Prompt에서 실행)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  using Pkg
  Pkg.add(&quot;IJulia&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IJulia 실행(Julia Prompt에서 실행)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  using IJulia
  notebook()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;이제 익숙한 Jupyter Notebook이 보이고 Julia 커널을 사용할 수 있게됨
    &lt;ul&gt;
      &lt;li&gt;최초 실행 이후엔 Jupyter Notebook으로 실행해도 줄리아 커널이 보임&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/qcmvn0cu006ukw7/Screenshot%202019-12-26%2022.46.49.png?raw=1&quot; height=&quot;200&quot; weight=&quot;300&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;package-설치&quot;&gt;Package 설치&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;패키지 Import는 using을 사용&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pkg를 사용해 패키지 설치&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  usisg Pkg
  Pkg.add(&quot;PackageName&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;기본-문법&quot;&gt;기본 문법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;함수의 Document를 보고 싶은 경우
    &lt;ul&gt;
      &lt;li&gt;함수 앞에 ?를 붙임&lt;/li&gt;
      &lt;li&gt;?println&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/v14vr3pwljjd1oj/Screenshot%202019-12-26%2023.39.16.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;쉘 커맨드를 사용하고 싶은 경우
    &lt;ul&gt;
      &lt;li&gt;;를 앞에 붙임&lt;/li&gt;
      &lt;li&gt;;ls&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;print
    &lt;ul&gt;
      &lt;li&gt;println() 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Assert
    &lt;ul&gt;
      &lt;li&gt;@assert하고 식을 씀. 파이썬에서 assert a == 1 이런 느낌인데 골뱅이만 추가됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;variable&quot;&gt;Variable&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;type 확인하기
    &lt;ul&gt;
      &lt;li&gt;typeof() 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;타입 변환은 파이썬처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;float(365)&lt;/code&gt;로 할수도 있고, &lt;code class=&quot;highlighter-rouge&quot;&gt;parse(Float64, &quot;365&quot;)&lt;/code&gt;로 할수도 있음&lt;/li&gt;
  &lt;li&gt;신기한 부분은 이모지에 변수 할당할 수 있음(Super generic)&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ho22ch9ptifp264/Screenshot%202019-12-26%2023.41.57.png?raw=1&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;string&quot;&gt;String&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&quot;”나 “”” “&quot;”를 사용함
    &lt;ul&gt;
      &lt;li&gt;후자의 경우 문자열 내에서 따옴표를 사용할 수 있고, 전자는 불가능(Error 발생)&lt;/li&gt;
      &lt;li&gt;'’는 character고 string이 아님&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &quot;Here, we get an &quot;error&quot; because it's ambiguous where this string ends &quot;

  &quot;&quot;&quot;Look, Mom, no &quot;errors&quot;!!! &quot;&quot;&quot;
	
  typeof('a')

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;String Interpolation
    &lt;ul&gt;
      &lt;li&gt;Python의 F string같이 값을 넣고 흘려버리기&lt;/li&gt;
      &lt;li&gt;달러 기호 &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt;를 사용함&lt;/li&gt;
      &lt;li&gt;$() 안에 연산도 할 수 있음&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  name = &quot;kyle&quot;
  num_fingers = 10
  num_toes = 10
	
  println(&quot;Hello, my name is $name.&quot;)
  println(&quot;I have $num_fingers fingers and $num_toes toes.&quot;)
  println(&quot;That is $(num_fingers + num_toes) digits in all!!&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;String Concatenation
    &lt;ul&gt;
      &lt;li&gt;string끼리 합칠 경우엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;string()&lt;/code&gt;을 사용&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  s3 = &quot;How many cats &quot;;
  s4 = &quot;is too many cats?&quot;;
  😺 = 10

  string(s3, s4)
  string(&quot;I don't know, but &quot;, 😺, &quot; is too few.&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;String 반복
    &lt;ul&gt;
      &lt;li&gt;Python에선 “hi”*100처럼 했지만 Julia에선 “hi”^100으로 가능함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;data-structures&quot;&gt;Data Structures&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Tuple
    &lt;ul&gt;
      &lt;li&gt;Tuple은 생성하고 바꿀 수 없음&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt;로 만듬&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;순서가 지정된 요소를 묶어 튜플로 만들 수 있음&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  myfavoriteanimals = (&quot;penguins&quot;, &quot;cats&quot;, &quot;sugargliders&quot;)
		
  myfavoriteanimals[1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;NamedTuples
        &lt;ul&gt;
          &lt;li&gt;각각의 요소가 이름이 있는 Tuple&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  myfavoriteanimals = (bird = &quot;penguins&quot;, mammal = &quot;cats&quot;, marsupial = &quot;sugargliders&quot;)

  myfavoriteanimals[1]
		
  myfavoriteanimals.bird
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Dictionaries
    &lt;ul&gt;
      &lt;li&gt;Python의 dictinary랑 비슷한듯. key-pair 존재&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Dict()&lt;/code&gt;으로 만들고, =&amp;gt;를 사용함&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  myphonebook = Dict(&quot;Jenny&quot; =&amp;gt; &quot;867-5309&quot;, &quot;Ghostbusters&quot; =&amp;gt; &quot;555-2368&quot;)
  myphonebook[&quot;Jenny&quot;]
  myphonebook[&quot;Kramer&quot;] = &quot;555-FILK&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pop!&lt;/code&gt;을 쓰면 값이 나옴(원본 dict엔 사라짐) 느낌표가 있다니 신기함&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pop!(myphonebook, &quot;Kramer&quot;)
  myphonebook
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;Tuple이나 Array와 다르게 dictionaries는 정렬되지 않아서 index로 접근할 수 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Arrays
    &lt;ul&gt;
      &lt;li&gt;Array는 mutable하고 dict과 다르게 순서가 있음&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt;로 만듬&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  myfriends = [&quot;Ted&quot;, &quot;Robyn&quot;, &quot;Barney&quot;, &quot;Lily&quot;, &quot;Marshall&quot;]
		
  mixture = [1, 1, 2, 3, &quot;Ted&quot;, &quot;Robyn&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;push!&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;pop!&lt;/code&gt; 사용 가능&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;ND Array도 생성할 수 있음&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  numbers = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]
	
  rand(4, 3)
  rand(4, 3, 2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;복사는 &lt;code class=&quot;highlighter-rouge&quot;&gt;copy()&lt;/code&gt;를 사용해 가능&lt;/li&gt;
      &lt;li&gt;array의 길이는 &lt;code class=&quot;highlighter-rouge&quot;&gt;length()&lt;/code&gt; 사용&lt;/li&gt;
      &lt;li&gt;array의 요소 합은 &lt;code class=&quot;highlighter-rouge&quot;&gt;sum()&lt;/code&gt; 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;loops&quot;&gt;Loops&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;while loops와 for loops이 있음 : 모두 end를 써야함&lt;/li&gt;
  &lt;li&gt;while loops
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;사용 방식&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  while *condition*
 		*loop body*
  end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;예시 : indent에 둔감함&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  n = 0
  while n &amp;lt; 10
 		n += 1 #  n = n + 1
  				println(n)
  end
  n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;세미 콜론(;)을 사용하면 줄바뀜 효과를 얻음&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  n = 0
  while n &amp;lt; 10; n += 1 
  				println(n)
  end
  n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  myfriends = [&quot;Ted&quot;, &quot;Robyn&quot;, &quot;Barney&quot;, &quot;Lily&quot;, &quot;Marshall&quot;]
		
  i = 1
  while i &amp;lt;= length(myfriends)
      friend = myfriends[i]
      println(&quot;Hi $friend, it's great to see you!&quot;)
      i += 1
  end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;for loops
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;사용 방식&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  for *var* in *loop iterable*
  		*loop body*
  end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;예시(1:10은 python에서 range(1, 10)과 동일)&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  for n in 1:10
      println(n)
  end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  myfriends = [&quot;Ted&quot;, &quot;Robyn&quot;, &quot;Barney&quot;, &quot;Lily&quot;, &quot;Marshall&quot;]
		
  for friend in myfriends
      println(&quot;Hi $friend, it's great to see you!&quot;)
  end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;2중 for문을 더 쉽게 쓸 수 있음&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  m, n = 5, 5
  A = fill(0, (m, n))
  for i in 1:m
      for j in 1:n
          A[i, j] = i + j
      end
  end
  A
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  B = fill(0, (m, n))
  for i in 1:m, j in 1:n
      B[i, j] = i + j
  end
  B
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Array comprehension(Python의 list comprehension 느낌) =&amp;gt; Julia 스타일&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  [ x+y for x in 1:10, y in 2:5]
		
  C = [i + j for i in 1:m, j in 1:n]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;conditionals&quot;&gt;Conditionals&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;if문&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  if *condition 1*
      *option 1*
  elseif *condition 2*
      *option 2*
  else
      *option 3*
  end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;fizzbuzz 예시
        &lt;ul&gt;
          &lt;li&gt;&amp;amp;&amp;amp;는 AND를 뜻함&lt;/li&gt;
          &lt;li&gt;%는 나머지를 뜻함&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  N=15
		
  if (N % 3 == 0) &amp;amp;&amp;amp; (N % 5 == 0) # `&amp;amp;&amp;amp;` means &quot;AND&quot;; % computes the remainder after division
      println(&quot;FizzBuzz&quot;)
  elseif N % 3 == 0
      println(&quot;Fizz&quot;)
  elseif N % 5 == 0
      println(&quot;Buzz&quot;)
  else
      println(N)
  end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ternary operators(삼항 연산) : 오 신기함
    &lt;ul&gt;
      &lt;li&gt;a ? b : c&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이건 아래와 동의어임&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  if a
      b
  else
      c
  end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;예시&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  x = 10
  y = 5
	
  if x &amp;gt; y
      x
  else
      y
  end
	
  (x &amp;gt; y) ? x : y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;short-circuit evaluation
    &lt;ul&gt;
      &lt;li&gt;a &amp;amp;&amp;amp; b&lt;/li&gt;
      &lt;li&gt;if a and b가 true일 경우 true를 return함
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  false &amp;amp;&amp;amp; (println(&quot;hi&quot;); true)
  true &amp;amp;&amp;amp; (println(&quot;hi&quot;); true)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;error()&lt;/code&gt;를 사용하면 Error 발생&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  true || println(&quot;hi&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;||&lt;/code&gt; operator는 or을 뜻함&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  true || println(&quot;hi&quot;)
  false || println(&quot;hi&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;functions&quot;&gt;Functions&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;주요 Topic
    &lt;ul&gt;
      &lt;li&gt;함수 정의하는 방법&lt;/li&gt;
      &lt;li&gt;Duck-typing 하는 방법 : 타입을 미리 정의하는게 아닌 실행되었을 때 타입 정의. &lt;a href=&quot;https://nesoy.github.io/articles/2018-02/Duck-Typing&quot;&gt;덕타이핑이란?&lt;/a&gt; 글 참고&lt;/li&gt;
      &lt;li&gt;Mutating vs non-mutating function&lt;/li&gt;
      &lt;li&gt;Some higher order functions&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;함수 정의&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  function sayhi(name)
 		println(&quot;Hi $name, it's great to see you!&quot;)
  end
	
  function f(x)
      x^2
  end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;1줄로 할 수도 있음&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sayhi2(name) = println(&quot;Hi $name, it's great to see you!&quot;)
	
  f2(x) = x^2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;함수 인자 타입 지정
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;::&lt;/code&gt; 사용하며 타입 선언이 없으면 기본적으로 Any 타입으로 지정됨&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  foo(x::Int, y::Int) = println(&quot;My inputs x and y are both integer!&quot;)
		
  foo(3, 4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;anonymous(익명) 함수 : = 를 사용해서 -&amp;gt; 결과를 낸다. Tuple도 사용 가능&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sayhi3 = name -&amp;gt; println(&quot;Hi $name, it's great to see you!&quot;)
	
  f3 = x -&amp;gt; x^2
		
  sayhi4 = (firstname, lastname) -&amp;gt; println(&quot;Hi $firstname $lastname, it's greate to see you!&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Duck-typing
    &lt;ul&gt;
      &lt;li&gt;Julia는 모든 입력이 의미가 있다고 생각함&lt;/li&gt;
      &lt;li&gt;string으로 들어갈 것이라 예상했던 것이 int가 들어가도 작동함&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sayhi(55595472)
	
  A = rand(3, 3)
  f(A)
  f(&quot;hi&quot;)
	
  # vector 연산은 ^ 연산이 구현되지 않아서 아래 명령어는 오류 발생
  v = rand(3)
  f(v)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Mutating vs non-mutating functions
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;!&lt;/code&gt;를 붙이는 차이&lt;/li&gt;
      &lt;li&gt;sort는 원본 데이터는 변하지 않지만, sort!는 변함. 마치 pandas에서 replace=True가 기본적으로 들어간게 ! 붙인거 같은 느낌&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  v = [3, 5, 2]
  sort(v)
  v
	
  sort!(v)
  v
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Some higher order functions(고차 함수)
    &lt;ul&gt;
      &lt;li&gt;map
        &lt;ul&gt;
          &lt;li&gt;해당 함수를 전달한 데이터의 모든 요소에 적용함&lt;/li&gt;
          &lt;li&gt;map(f, [1, 2, 3]) =&amp;gt; [f(1), f(2), f(3)] 이렇게 됨&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  map(x -&amp;gt; x^3, [1, 2, 3])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;broadcast
        &lt;ul&gt;
          &lt;li&gt;map의 일반적인 형태&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  broadcast(f, [1, 2, 3])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;함수 뒤에 &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;을 붙일 경우에도 broadcast됨&lt;/p&gt;

            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  f.([1, 2, 3])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;연산 차이&lt;/p&gt;

            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  A = [i + 3*j for j in 0:2, i in 1:3]
			
  f(A)
  # A^2 = A*A 행렬 곱
			
  f.(A)
  # 각 요소들의 제곱
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;아래 두 코드는 동일한 결과가 나타남&lt;/p&gt;

            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  broadcast(x -&amp;gt; x + 2 * f(x) / x, A)
	
  A .+ 2 .* f.(A) ./ A
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;packages&quot;&gt;Packages&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://pkg.julialang.org/docs/&quot;&gt;https://pkg.julialang.org/docs/&lt;/a&gt;에서 사용 가능한 패키지를 확인할 수 있음&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;패키지 설치(Pkg : 패키지 관리자)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  using Pkg
  Pkg.add(&quot;Example&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;패키지 사용&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  using &quot;package name&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;using을 하면 그 안에 있는 함수를 사용할 수 있음&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Palette 사용하는 예시&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Pkg.add(&quot;Colors&quot;)
  using Colors
  palette = distinguishable_colors(100)
  rand(palette, 3, 3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/fszncwj4003c2eq/Screenshot%202019-12-27%2015.02.10.png?raw=1&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;plotting&quot;&gt;Plotting&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;그래프를 그리는 방식은 정말 다양함(PyPlot을 부를수도 있고, Plots 사용할수도 있음)&lt;/li&gt;
  &lt;li&gt;Plots는 다양한 백엔드를 지원하는데, GR과 UnicodePlots을 사용해볼 예정
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://docs.juliaplots.org/latest/backends/&quot;&gt;Plots Backent&lt;/a&gt; 참고&lt;/li&gt;
      &lt;li&gt;gr을 빌드할 때 너무 오래 걸려서 &lt;a href=&quot;https://discourse.julialang.org/t/too-much-time-taken-to-build-gr/22798/5&quot;&gt;링크&lt;/a&gt;를 찾아봄&lt;/li&gt;
      &lt;li&gt;Using Plots시 Permission Error가 떠서 PyPlot을 사용함&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import Pkg; Pkg.add(&quot;Plots&quot;)
  using Plots
	
  globaltemperatures = [14.4, 14.5, 14.8, 15.2, 15.5, 15.8]
  numpirates = [45000, 20000, 15000, 5000, 400, 17];
	
  gr()
	
	
  plot(numpirates, globaltemperatures, label=&quot;line&quot;)  
  scatter!(numpirates, globaltemperatures, label=&quot;points&quot;)
	
	
  xlabel!(&quot;Number of Pirates [Approximate]&quot;)
  ylabel!(&quot;Global Temperature (C)&quot;)
  title!(&quot;Influence of pirate population on global warming&quot;)
	
  xflip!()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Pkg.add(&quot;PyPlot&quot;)
  using PyPlot
	
  globaltemperatures = [14.4, 14.5, 14.8, 15.2, 15.5, 15.8]
  numpirates = [45000, 20000, 15000, 5000, 400, 17];
	
  plot(numpirates, globaltemperatures, label=&quot;line&quot;) 
  scatter(numpirates, globaltemperatures, label=&quot;points&quot;, color=&quot;red&quot;)
  xlabel(&quot;Number of Pirates [Approximate]&quot;)
  ylabel(&quot;Global Temperature (C)&quot;)
  title(&quot;Influence of pirate population on global warming&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/tlqsuw9omjw2l2j/Screenshot%202019-12-27%2015.32.39.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;multiple-dispatch&quot;&gt;Multiple Dispatch&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;아마 생소한 개념. &lt;a href=&quot;http://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;위키피디아&lt;/a&gt; 참고
    &lt;ul&gt;
      &lt;li&gt;함수의 인자 타입에 따라 다른 함수 호출&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  foo(x::String, y::String) = println(&quot;My inputs x and y are both strings!&quot;)
	
  foo(&quot;hello&quot;, &quot;hi!&quot;)


  foo(3, 4)
  # MethodError: no method matching foo(::Int64, ::Int64)
	
  foo(x::Int, y::Int) = println(&quot;My inputs x and y are both integers!&quot;)
  foo(3, 4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;method()&lt;/code&gt;를 사용하면 함수에 대한 내용이 나옴
    &lt;ul&gt;
      &lt;li&gt;generic function with 2 methods : 2가지 메서드를 가진 함수 객체를 뜻함&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  methods(foo)
	
  &amp;gt;&amp;gt;&amp;gt; 2 methods for generic function foo:
  &amp;gt;&amp;gt;&amp;gt; foo(x::Int64, y::Int64) in Main at In[8]:1
  &amp;gt;&amp;gt;&amp;gt; foo(x::String, y::String) in Main at In[5]:1
	
  foo(x::Number, y::Number) = println(&quot;My inputs x and y are both numbers!&quot;)
	
  foo(x, y) = println(&quot;I accept inputs of any type!&quot;)

  v = rand(3)
  foo(v, v)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;method(+)를 입력해서 + 구현을 확인해볼 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;generic function을 호출할 때 어떤 메소드가 전달되는지 확인하려면 @which 매크로를 사용할 수 있음&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @which foo(3, 4)
	
  &amp;gt;&amp;gt;&amp;gt; foo(x::Int64, y::Int64) in Main at In[8]:1
	
  @which 3.0 + 3.0
  &amp;gt;&amp;gt;&amp;gt; +(x::Float64, y::Float64) in Base at float.jl:395
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;간단한 내용만 본거고, 더 궁금하면 &lt;a href=&quot;https://github.com/JuliaComputing/JuliaBoxTutorials/blob/master/introductory-tutorials/intro-to-julia/10.1%20Multiple%20dispatch.ipynb&quot;&gt;Github&lt;/a&gt; 참고하면 좋음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;dataframe&quot;&gt;Dataframe&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;데이터를 조작하기 위해 &lt;a href=&quot;https://juliadata.github.io/DataFrames.jl/stable/&quot;&gt;Dataframes.jl&lt;/a&gt; 활용&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pandas와 비슷한 느낌&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import Pkg; Pkg.add(&quot;DataFrames&quot;)
  using DataFramesusing DataFrames
	
  df = DataFrame(A = 1:4, B = [&quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;df.col&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;df[!, :col]&lt;/code&gt;을 통해 열에 직접 액세스 가능
    &lt;ul&gt;
      &lt;li&gt;후자는 열 이름을 변수에 전달할 수 있어 유용함. 열 이름은 Symbol(“col”)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;names(df)&lt;/code&gt;로 이름을 확인할 수 있음&lt;/li&gt;
      &lt;li&gt;df[!, :col]은 복사하지 않고 원본을 컨트롤하고, df[:, :col]은 사본을 얻음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Dataframe을 만들고 하나씩 붙이는 것도 가능(Column끼리)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  df = DataFrame()
  df.A = 1:8
  df.B = [&quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;M&quot;, &quot;F&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/c9l1ot450aacjqd/Screenshot%202019-12-27%2017.13.22.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Row끼리 합치기 : &lt;code class=&quot;highlighter-rouge&quot;&gt;push!&lt;/code&gt; 사용&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  df = DataFrame(A = Int[], B = String[])
  push!(df, (1, &quot;M&quot;))
  push!(df, [2, &quot;N&quot;])
  push!(df, Dict(:B =&amp;gt; &quot;F&quot;, :A =&amp;gt; 3))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/732p2rg6ndx5vra/Screenshot%202019-12-27%2017.14.50.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;저장하기&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  using Pkg
  Pkg.add(&quot;CSV&quot;)
  using CSV

  CSV.write(&quot;dataframe.csv&quot;, df)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Filtering : Pandas랑 느낌 비슷한데 점을 추가함(각 요소별 연산) : .&amp;gt;, in. 등&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  df = DataFrame(A = 1:2:1000, B = repeat(1:10, inner=50), C = 1:500)
  df[df.A .&amp;gt; 500, :]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Describe
    &lt;ul&gt;
      &lt;li&gt;describe(df)로 가능&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  df = DataFrame(A = 1:4, B = [&quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;])
  describe(df)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/fft3ne8kz8aj0d2/Screenshot%202019-12-27%2017.23.04.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Aggregate : aggregate(df, 연산)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  df = DataFrame(A = 1:4, B = 4.0:-1.0:1.0)
  aggregate(df, sum)
  aggregate(df, [sum, prod])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/pgzuekq3v87ji0n/Screenshot%202019-12-27%2017.23.21.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;특정 값 변경하기&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  df.A[1] = 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CSV Read&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  using Pkg
  Pkg.add(&quot;CSV&quot;)
  using CSV
	
  DataFrame(CSV.File(input))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DelimitedFiles(CSV 읽기)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  using DelimitedFiles
  P,H = readdlm(&quot;programminglanguages.csv&quot;,header=true)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Join
    &lt;ul&gt;
      &lt;li&gt;join 인자 안에 kind = :inner, :left 등을 사용할 수 있음&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  people = DataFrame(ID = [20, 40], Name = [&quot;John Doe&quot;, &quot;Jane Doe&quot;])
  jobs = DataFrame(ID = [20, 40], Job = [&quot;Lawyer&quot;, &quot;Doctor&quot;])
  join(people, jobs, on = :ID)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/w3prfwcsfwx1r6e/Screenshot%202019-12-27%2017.26.30.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그 외에도 Split-apply-combine을 위해 by 등을 사용함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;최적화-라이브러리&quot;&gt;최적화 라이브러리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.juliaopt.org/&quot;&gt;JuliaOpt&lt;/a&gt; 쪽에 자료 많음&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.juliaopt.org/&quot;&gt;JuMP.jl&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;CVX는 &lt;a href=&quot;https://github.com/JuliaOpt/Convex.jl&quot;&gt;Convex.jl&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JuMP 예시 코드&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  using JuMP, GLPK

  # 모델 생성
  m = Model(with_optimizer(GLPK.Optimizer))
	
  # Variable 선언
  @variable(m, 0&amp;lt;= x1 &amp;lt;=10)
  @variable(m, x2 &amp;gt;=0)
  @variable(m, x3 &amp;gt;=0)
	
  # 목적 함수 
  @objective(m, Max, x1 + 2x2 + 5x3)
	
  # 제약 조건 설정
  @constraint(m, constraint1, -x1 +  x2 + 3x3 &amp;lt;= -5)
  @constraint(m, constraint2,  x1 + 3x2 - 7x3 &amp;lt;= 10)
	
  # Optimization Model 출력
  print(m)
	
  # 최적화 문제 풀기
  JuMP.optimize!(m)

  # Optimal Solution Print
  println(&quot;Optimal Solutions:&quot;)
  println(&quot;x1 = &quot;, JuMP.value(x1))
  println(&quot;x2 = &quot;, JuMP.value(x2))
  println(&quot;x3 = &quot;, JuMP.value(x3))
	
  # Optimal dual variables Print
  println(&quot;Dual Variables:&quot;)
  println(&quot;dual1 = &quot;, JuMP.shadow_price(constraint1))
  println(&quot;dual2 = &quot;, JuMP.shadow_price(constraint2))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;vscode-extension&quot;&gt;VSCode Extension&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/julia-vscode/julia-vscode&quot;&gt;julia-vscode&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;권창현님의 &lt;a href=&quot;https://www.chkwon.net/julia/&quot;&gt;Julia Programming for Operation Research&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.julialang.org/en/v1/&quot;&gt;Julia 공식 Document&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=8h8rQyEpiZA&amp;amp;t=&quot;&gt;Intro to Julia tutorial (version 1.0)&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/madeleineudell/intro-to-julia&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;이분의(교수되신듯) &lt;a href=&quot;https://github.com/udellgroup/orie7191&quot;&gt;강의&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ucidatascienceinitiative.github.io/IntroToJulia/Html/WhyJulia&quot;&gt;Intro to Julia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 27 Dec 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/development/2019/12/27/julia_basic/</link>
        <guid isPermaLink="true">http://localhost:4000/development/2019/12/27/julia_basic/</guid>
        
        <category>julia</category>
        
        
        <category>development</category>
        
      </item>
    
      <item>
        <title>머신러닝 엔지니어의 2019년 회고</title>
        <description>&lt;ul&gt;
  &lt;li&gt;2019년을 되돌아보며 작성한 회고 글입니다
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://zzsza.github.io/diary/2019/07/07/2019-half-retrospect/&quot;&gt;2019년 상반기 회고&lt;/a&gt;는 키워드 위주로 간단히 작성했고, 이번엔 월별 정리 + 키워드 정리를 하려고 합니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;제가 어떤 사람인지 궁금하시면 아래 자료들을 보시면 좋을듯 합니다
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://zzsza.github.io/diary/2019/04/05/how-to-study-datascience/&quot;&gt;데이터 사이언티스트가 되기 위해 진행한 다양한 노력들&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://zzsza.github.io/diary/2017/12/30/2017-retrospect/&quot;&gt;2017년 회고, 2018년 계획&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://zzsza.github.io/diary/2018/12/22/2018-retrospect/&quot;&gt;2018년 회고, 2019년 다짐&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://zzsza.github.io/diary/2018/10/26/gap-year-and-socar/&quot;&gt;Gap Year 및 쏘카 이직 이야기&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://zzsza.github.io/diary/2019/07/07/2019-half-retrospect/&quot;&gt;2019년 상반기 회고 및 글또 3기 시작&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2019년-월별-정리&quot;&gt;2019년 월별 정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;2019년을 되돌아보니 “성장하는 서비스에서 다양한 업무를 빠르게 진행했고, 머신러닝이 아닌 최적화(Constraint Programming 등)라는 도구에 대해 알아간 해, 매니저 역량을 확인하고 팀원들의 성장을 고민한 해”라고 정의할 수 있을 것 같습니다&lt;/li&gt;
  &lt;li&gt;쏘카에 입사하고 본격적으로 일을 진행한 1년이였고(2018년엔 9월 입사라 준비 단계 정도라 생각하고..) 너무 빠르게 변하는 상황에서 나름 잘 적응하며 지냈습니다&lt;/li&gt;
  &lt;li&gt;월별 정리는 키워드 위주로 작성하겠습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1월&quot;&gt;1월&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;학습
    &lt;ul&gt;
      &lt;li&gt;시뮬레이터 개발&lt;/li&gt;
      &lt;li&gt;시계열 수요 예측 및 Serving 프로토타입 개발&lt;/li&gt;
      &lt;li&gt;AWS Lambda와 Terraform을 사용한 API 개발&lt;/li&gt;
      &lt;li&gt;Hashing을 사용한 AB Test Split&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정서적 안정감
    &lt;ul&gt;
      &lt;li&gt;정서를 느낄 시간 없이 빠르게 지나감. 정서적 안정감 좋음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기타
    &lt;ul&gt;
      &lt;li&gt;일기장을 보니 책을 쓰려는 생각이 있어 여러 출판사를 만나고 다님
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://github.com/Team-Neighborhood/I-want-to-study-Data-Science/wiki&quot;&gt;I Want to Study Data Science&lt;/a&gt; 글을 작성한 후, 출판사에게 많은 연락을 받음&lt;/li&gt;
          &lt;li&gt;정작 회사 일이 바빠서 쓰진 않았지만, 컨텐츠에 대해 고민해본 시기(과연 내 책이 팔릴까? 등)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;딥모닝 : PR12(아침에 PR12 영상 1개씩 매일 보는 모임)을 웅원이와 만들고 진행함. 아침에 성실하게 살기 위한 노력이였음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2월&quot;&gt;2월&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;학습
    &lt;ul&gt;
      &lt;li&gt;일 잘하시는 팀원분이 최적화 개념을 알려주셔서 그 쪽을 주로 공부함(Mixed Integer Programming, Constraint Programming, Google OR-tools)&lt;/li&gt;
      &lt;li&gt;지리 데이터를 파악해야 해서 QGIS나 SHP 파일 다루는 쪽도 공부 시작&lt;/li&gt;
      &lt;li&gt;2월 말에 팀 개편으로 두 팀의 팀장이 됨
        &lt;ul&gt;
          &lt;li&gt;데이터 사이언스팀 + 타다데이터팀&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;데이터 그룹에선 3개월 수습 기간에 발표를 통해 정규직 전환이 결정되는데, 이 정규직 전환을 잘할 수 있도록 + 수습 발표 전 스트레스를 케어하기 위해 “멘탈 붕괴 방지 위원회”를 만들어 수습 발표 전에 사전 발표 및 피드백을 진행함 =&amp;gt; 여태까지 계속 진행 중&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정서적 안정감
    &lt;ul&gt;
      &lt;li&gt;2월 말에 너무 피곤하고 뭔가 번아웃 위기가 온 것 같아 고민해보니, 책 집필을 해보려고 초안 작성하는 시간에 스트레스를 너무 받음
        &lt;ul&gt;
          &lt;li&gt;블로그에 글 작성하는 것과 책은 정말 큰 차이가 있다는 것을 깨닫고, 시간적 여유가 생기면 책을 쓰기로 하고 잠정 중단&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기타
    &lt;ul&gt;
      &lt;li&gt;AutoML 도구인 데이터로봇을 사용할 기회가 생겨서 많이 사용해보니, Tabular 데이터의 AutoML은 조만간 빠르게 대중화될 수 있다고 생각&lt;/li&gt;
      &lt;li&gt;패스트캠퍼스 시계열 예측 강의를 수강하며 전통적인 시계열 예측 방법론에 대해 익힘&lt;/li&gt;
      &lt;li&gt;GDG Campus에서 진행한 Daily 만년 Junior들의 이야기 - 델리만주에서 데이터 사이언스 입문에 대해 발표함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3월&quot;&gt;3월&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;학습
    &lt;ul&gt;
      &lt;li&gt;TF가 아닌 팀이 되었고, 팀장 역할에 대한 고민
        &lt;ul&gt;
          &lt;li&gt;팀장이 개인 성과를 내야하는걸까? 팀의 성과가 잘 나오도록 하면 되는게 아닐까?&lt;/li&gt;
          &lt;li&gt;팀원과 경쟁하지 말자, 팀원을 포용하자(내가 항상 옳진 않고 상대방의 의견이 맞을 수 있다. 왜 그렇게 생각하는지 맥락을 듣자)&lt;/li&gt;
          &lt;li&gt;성과를 가로채는 그런 느낌의 팀장이 되지 말자(해당 팀원이 진행한 일을 윗분에게 잘 어필하고, 인정받을 수 있도록 돕자)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;팀 정기 회고를 진행해서 팀 운영 방식이나 개선할 수 있는 포인트를 찾아 계속 개선했음&lt;/li&gt;
      &lt;li&gt;GCP의 Composer(Airflow의 managed service)를 사용해 머신러닝 파이프라인 구축&lt;/li&gt;
      &lt;li&gt;시계열 데이터를 프러덕션할 때 주의할 점에 대한 깨달음&lt;/li&gt;
      &lt;li&gt;데이터 그룹의 학습하는 문화를 만들기 위해 &lt;a href=&quot;https://github.com/zzsza/Perfect-Guide-about-Machine-Learning-Study&quot;&gt;파이썬 머신러닝 완벽 가이드 기반 스터디&lt;/a&gt;를 만듬
        &lt;ul&gt;
          &lt;li&gt;Github에 자세히 적어놨지만, 간단히 작성하면 누가 공부해와서 발표하는 방식이 아닌 일과 시간에 같이 모여서 책 읽고 토론하는 시간.&lt;/li&gt;
          &lt;li&gt;이 스터디는 데이터 분석에 대해서만 알고, 머신러닝에 대해선 잘 모르는 분들을 빠르게 베이스라인을 끌어올리기 위해 진행함&lt;/li&gt;
          &lt;li&gt;5월 말까지 꾸준히 진행했음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정서적 안정감
    &lt;ul&gt;
      &lt;li&gt;개인 업무에 집중하다가 공식적으로 팀장 역할을 하며 역할에 대해 고민한 시간이 많음. 이 시간이 정서적 안정감에 영향을 준 것은 아니지만 자신에 대한 방향성을 고민하게 해줌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기타
    &lt;ul&gt;
      &lt;li&gt;지인분들과 함께 &lt;a href=&quot;https://www.youtube.com/channel/UCdLZ0MsYS4hmqFgOYCB6C9w&quot;&gt;딥놀&lt;/a&gt; 유튜브 시작! 혼자 하면 안할 확률이 컸는데, 함께해서 시너지나는 모임&lt;/li&gt;
      &lt;li&gt;마이크로소프트웨어 396호에 글쓰는 개발자 모임 - 글또 관련 내용을 기고. 잡지에 글을 써보는 경험도 처음이라 재미있었지만, 그만큼 신경을 더 써야해서 살짝 스트레스도 있었음&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://festa.io/events/191&quot;&gt;Write The Docs Seoul&lt;/a&gt;에서 &lt;a href=&quot;https://www.slideshare.net/zzsza/ss-137831892&quot;&gt;글쓰는 개발자 모임, 글또&lt;/a&gt;의 주제로 발표함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4월&quot;&gt;4월&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;학습
    &lt;ul&gt;
      &lt;li&gt;Uber의 &lt;a href=&quot;https://zzsza.github.io/data/2019/03/31/uber-h3/&quot;&gt;H3&lt;/a&gt;, &lt;a href=&quot;https://zzsza.github.io/data/2019/04/01/uber-keplergl/&quot;&gt;Kepler.gl&lt;/a&gt;에 대해 깊게 알아보고, 블로그 글도 작성함&lt;/li&gt;
      &lt;li&gt;메타휴리스틱 방법론이 신기해서, Genetic Algorithm에 대해 공부하고 적용하려 했으나, Constraint Programming이 더 효율적이라 판단해 적용하진 않음&lt;/li&gt;
      &lt;li&gt;VCNC 데이터팀에 새로 입사하신 분이 계셔서, 케어하다보니 거의 3팀의 매니저 같은 역할을 함&lt;/li&gt;
      &lt;li&gt;Airflow를 사용해 로그를 BigQuery로 보내는 파이프라인&lt;/li&gt;
      &lt;li&gt;Interpretable Machine Learning에 대해 공부함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정서적 안정감
    &lt;ul&gt;
      &lt;li&gt;두 팀의 팀장 + 채용 등의 업무가 추가되서 정말 정신없었음. 하루에 기본 미팅(Daily)가 2개니 그냥 미팅 미팅의 연속&lt;/li&gt;
      &lt;li&gt;정서적 안정감이 하락하고 있는 것이 팀장 겸직인 것 같아 4월 말에 하나의 팀만 집중하는 것이 좋을 것 같다고 그룹장님에게 말씀드림. 그 결과 5월까진 천천히 차기 팀장님에게 인수인계+서포트 하고 6월부터 완전히 하나의 팀만 맡기로&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기타
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://zzsza.github.io/diary/2019/04/05/how-to-study-datascience/&quot;&gt;데이터 사이언티스트가 되기 위해 진행한 다양한 노력들&lt;/a&gt;에 대한 글을 작성함. 많은 분들이 궁금해하셔서 작성했는데, 구글에서 “데이터 사이언티스트” 검색시 상단에 나와서 뿌듯&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;5월&quot;&gt;5월&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;학습
    &lt;ul&gt;
      &lt;li&gt;데이터사이언스팀의 팀장님에게 인수인계하고, 5월엔 잘 운영될 수 있도록 서포트를 함. 남은 시간엔 빠르게 성장하고 있는 타다에 집중함&lt;/li&gt;
      &lt;li&gt;모빌리티에선 어떤 종류의 문제를 푸는지, 어떤 논문이 있는지 한번쯤 정리하면 좋을 것 같아 &lt;a href=&quot;https://github.com/zzsza/Awesome-Mobility-Machine-Learning-Contents&quot;&gt;Awesome Mobility Machine Learning Contents&lt;/a&gt;에 정리함&lt;/li&gt;
      &lt;li&gt;앞선 시기에 진행한 업무들을 더 잘 &amp;amp; 깊게 하도록 진행함&lt;/li&gt;
      &lt;li&gt;쏘카에 GIS 장인이신 신수현님이 데이터 분석한 것을 듣고 “지리 데이터에 기반한 분석도 새롭고 신선하다”고 생각함&lt;/li&gt;
      &lt;li&gt;날씨 데이터를 수집하기 위해 공공 데이터 부분을 자세하게 파악함&lt;/li&gt;
      &lt;li&gt;Serving을 어떻게 효율적으로 할까 고민하다 Kubeflow를 테스트해봄
        &lt;ul&gt;
          &lt;li&gt;아직 버전이 낮지만 추후엔 꽤 유용해질 것 같다는 생각을 함&lt;/li&gt;
          &lt;li&gt;다만 사용하기 위해 구성원들이 모두 Docker에 대해 잘 알고, 모델을 엄청 적극적으로 활용해야 유용할 것 같단 생각을 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;서버 코드를 읽기 위해 코틀린을 살짝 공부함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정서적 안정감
    &lt;ul&gt;
      &lt;li&gt;팀장 겸직이 해제되서 심리적으로 안정감이 다시 올라감. 여러 업무를 할 수 있어도, 그래도 하나의 집중하는 편이 좋다고 생각함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기타
    &lt;ul&gt;
      &lt;li&gt;웅원이와 함께 스타트업 머신러닝 플레이어(스머플) 모임을 만들어 진행함. 주로 스타트업에서 ML을 적용할 때 이슈, 채용은 어떻게 할까? 등에 대해 논의함&lt;/li&gt;
      &lt;li&gt;웅원이가 있는 당근마켓에 가서 &lt;a href=&quot;https://www.slideshare.net/zzsza/bigquery-147073606&quot;&gt;BigQuery의 모든 것&lt;/a&gt;을 발표하고 옴. 271쪽을 3시간만에 끝내려는건 역시 무리였으나! 핵심은 다 전달하고 옴
        &lt;ul&gt;
          &lt;li&gt;해당 자료는 19년 12월 기준 조회수 11,000회 정도&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;6월&quot;&gt;6월&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;학습
    &lt;ul&gt;
      &lt;li&gt;GCP에서 Instance Template을 활용해 인스턴스를 다량으로 생성하고 실행하는 쉘 스크립트 작성&lt;/li&gt;
      &lt;li&gt;당근마켓에서 발표한 내용을 기반으로 사내에서 BigQuery 강의함
        &lt;ul&gt;
          &lt;li&gt;지역 사업팀도 계셔서 온라인으로 라이브 방송을 진행함&lt;/li&gt;
          &lt;li&gt;쏘카엔 데이터 그룹 제외하고도 80명이 넘는 분들이 이미 SQL을 날리고 있는데, 수준의 편차가 너무 심해서 발표를 아주 쉬운 단계(거의 엑셀 기초부터..?) vs 고급 단계로 나눠서 해야될 것 같다고 느낌 =&amp;gt; 이 부분은.. 그 이후 바빠서 못했지만 내년엔 더 진행을..!&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;머신러닝 엔지니어링엔 TDD가 자주 사용되지 않지만, Test Code를 작성하도록 방식을 만듬&lt;/li&gt;
      &lt;li&gt;팀내 코드 리뷰를 도입해 코드도 나름 빡세게 리뷰함&lt;/li&gt;
      &lt;li&gt;BigQuery GIS에 좌표 데이터를 넣는데 자꾸 오류가 나서 끝없이 디버깅해보니 “좌표계”에 대한 개념이 중요한 것을 깨달음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정서적 안정감
    &lt;ul&gt;
      &lt;li&gt;딱히 문제 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기타
    &lt;ul&gt;
      &lt;li&gt;한빛미디어가 주최한 데브그라운드에서 &lt;a href=&quot;https://www.slideshare.net/zzsza/mobility-x-data&quot;&gt;Mobility X Data : 모빌리티 산업의 도전 과제&lt;/a&gt;에 대해 발표함
        &lt;ul&gt;
          &lt;li&gt;사람들이 모빌리티 데이터에 흥미를 가질 수 있도록, 카쉐어링과 라이드헤일링에서 겪는 문제에 대해 말함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;글또 3기 모집을 시작했는데, 지원자가 거의 80명이였음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;7월&quot;&gt;7월&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;학습
    &lt;ul&gt;
      &lt;li&gt;MLOps에 매우 관심이 커져서 공부함. 일단 실험을 위한 플랫폼인 Sacred에 대해 깊게 공부하고 글 작성함&lt;/li&gt;
      &lt;li&gt;회사 업무에 몰입해서 진짜 정신없이 7월 삭제됨&lt;/li&gt;
      &lt;li&gt;상반기 회고 결과 업무를 약간 천천히 한 것 같기도..? 란 생각에 7월엔 셀프 관리를 더 잘 진행함&lt;/li&gt;
      &lt;li&gt;6월에 한빛미디어에서 발표하고, 끝나니 바로 DSTS에서 발표해야 해서 시간이 적었지만 업무와 발표 준비 시간을 잘 분배했음(하지만 마감에 벼락치기가 최고)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정서적 안정감
    &lt;ul&gt;
      &lt;li&gt;딱히 문제 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기타
    &lt;ul&gt;
      &lt;li&gt;Edwith &lt;a href=&quot;https://www.edwith.org/sparktutorial&quot;&gt;PySpark를 활용한 데이터분석&lt;/a&gt; 퍼블리싱&lt;/li&gt;
      &lt;li&gt;글또 3기 시작(3기 멤버 : 약 40명)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;8월&quot;&gt;8월&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;학습
    &lt;ul&gt;
      &lt;li&gt;개발 업무를 했고, 실서비스에 적용되는 것들을 만들었음
        &lt;ul&gt;
          &lt;li&gt;장애가 전혀 나지 않도록 설계하고, 혹시 최악의 경우를 방지할 부분도 미리 대비함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;서비큐라님의 쿠버네티스 교육을 듣고 왔는데, 쿠버네티스를 더 잘 이해할 수 있게됨&lt;/li&gt;
      &lt;li&gt;채용 행사에 데이터 직군 상담하기 위해 서울대, 고려대 등을 돌아다님. 많은 분들과 이야기했음(참고로 쏘카 전문연 가능한 기업!)&lt;/li&gt;
      &lt;li&gt;신입/인턴 면담
        &lt;ul&gt;
          &lt;li&gt;그로스해커스와 쏘카가 프로젝트를 같이 하게되서 풀타임 인턴과 프로젝트 하시는 분들이 계셨는데, 이분들을 위해 어떤 것을 해볼까 고민하다 모두 만나뵙고 커리어에 대한 이야기를 나눔&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정서적 안정감
    &lt;ul&gt;
      &lt;li&gt;딱히 문제 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기타
    &lt;ul&gt;
      &lt;li&gt;DSTS2019에서 &lt;a href=&quot;https://www.slideshare.net/zzsza/tf-9-160560910&quot;&gt;TF에서 팀 빌딩까지 9개월의 기록 : 성장하는 조직을 만드는 여정&lt;/a&gt;에 대해 발표함
        &lt;ul&gt;
          &lt;li&gt;기술적인 발표가 아닌 성장하는 조직에 대해 발표했는데, 생각보다 많은 분들이 좋아해주셨음. 이 발표 자료를 보시고 IT회사들의 리더분들이 연락옴&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;9월&quot;&gt;9월&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;학습
    &lt;ul&gt;
      &lt;li&gt;카이스트에 채용 행사 참여. 카이스트 공부하기 정말 좋아보임&lt;/li&gt;
      &lt;li&gt;첫 미국 출장. Oreilly Strata New York에 다녀옴&lt;/li&gt;
      &lt;li&gt;차량 하드웨어는 어떤 방식으로 통신하는지 알게 됨&lt;/li&gt;
      &lt;li&gt;쏘카 테크 블로그를 만들고, 이 블로그를 운영하는 역할을 CTO님에게 받음. 아직 초반기지만 작성한 글을 리뷰하는 시스템을 구축함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정서적 안정감
    &lt;ul&gt;
      &lt;li&gt;작성할 순 없지만 요청 업무가 매우 많아져서(=비즈니스가 엄청 성장하고 있기 때문에) 그 부분을 쳐내는데 시간을 많이 사용함. 팀원들은 본래 집중할 Task을 할 수 있도록 잡무를 거의 제가 처리함&lt;/li&gt;
      &lt;li&gt;정서적 안정감이 낮아짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기타
    &lt;ul&gt;
      &lt;li&gt;데이터 그룹과 좋은 관계를 맺은 그로스해커스분들을 위해 &lt;a href=&quot;https://www.slideshare.net/zzsza/ss-173453051&quot;&gt;성장을 좋아하는 사람이, 성장하고 싶은 사람에게&lt;/a&gt;에 대해 발표함
        &lt;ul&gt;
          &lt;li&gt;어떤 방향성을 가지고 성장해야 하는지에 대해 이야기함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;10월&quot;&gt;10월&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;학습
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://zzsza.github.io/mlops/2019/10/06/fullstack-deeplearning-bootcamp/&quot;&gt;Full Stack Deep Learning Bootcamp 정리&lt;/a&gt;함. 이 강의는 정말 여러 내용을 담고 있는데, 프러덕션 부분까지 담아서 매우 좋음&lt;/li&gt;
      &lt;li&gt;데이터야놀자 행사에 직접 발표하는게 아닌, 팀원분들이 발표할 수 있도록 도움. &lt;a href=&quot;https://zzsza.github.io/diary/2019/10/20/helping-presentation/&quot;&gt;팀원 성장시키기 : 발표 컨설팅&lt;/a&gt; 참고&lt;/li&gt;
      &lt;li&gt;미국에서 스트라타 행사를 듣고 최적화쪽은 Julia를 많이 사용하는 것을 보고 심심할 때 Julia로 최적화 문제를 풀어봄. 언어는 언어일 뿐인데 왜 Julia에 최적화 레퍼런스가 많을까?에 대해 고민함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정서적 안정감
    &lt;ul&gt;
      &lt;li&gt;뭔가 바쁘게 들어온 일을 처리하고, 미팅도 많이 했는데 되돌아보면 한 일이 없는거 아닌가?란 생각에 약간의 현타. 집중할 일에 집중해야 하는게 아닐까?란 생각이 들어 업무 방식을 변경함&lt;/li&gt;
      &lt;li&gt;패스트캠퍼스 머신러닝 온라인 강의에서 프로젝트 부분 촬영하느라 정서적으로 여유가 없었음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;11월&quot;&gt;11월&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;학습
    &lt;ul&gt;
      &lt;li&gt;데이터 그룹에서 신입/인턴 비율이 높아지는데 그분들을 위한 맞춤 교육이 따로 없어서 &lt;a href=&quot;https://github.com/zzsza/kyle-school&quot;&gt;카일 스쿨&lt;/a&gt;을 만들어 교육함
        &lt;ul&gt;
          &lt;li&gt;일은 왜 하는가? 번아웃을 어떻게 대처할 것인가? 올바른 자세(허리 펴!), 파이썬 시각화 등까지 진행했고 앞으론 개발적인 부분을 알려줄 예정&lt;/li&gt;
          &lt;li&gt;저는 남을 돕기 위해(성장시키기, 유저 입장에서 좋은 서비스를 경험하도록) 일을 하고 있는 것을 발표 자료 준비하며 다시 깨달음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Uber에서 만든 Deck.gl을 Python에서 활용할 수 있는 &lt;a href=&quot;https://zzsza.github.io/data/2019/11/24/pydeck/&quot;&gt;pydeck&lt;/a&gt;+ipywidget에 대해 공부하고 사내 전파함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정서적 안정감
    &lt;ul&gt;
      &lt;li&gt;시 간 순 삭! (블로그에 글 2개밖에 작성하지 않았던 시기)&lt;/li&gt;
      &lt;li&gt;닌텐도 스위치를 구입해 포켓몬 실드를 즐김. 게임하다보니 여유가 생기고 마음이 평온해지는 것을 느끼며, 아 사람은 가끔 좀 쉬어야지.. 라는 생각이 듬&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기타
    &lt;ul&gt;
      &lt;li&gt;유동현님이 제안주셔서 &lt;a href=&quot;https://event-us.kr/startupdaily/event/12769&quot;&gt;Career Talk&lt;/a&gt;에서 데이터 관련 세부 직군 소개 및 방향 제시에 대해 발표하고 옴&lt;/li&gt;
      &lt;li&gt;Google Cloud Summit Seoul 2019 - 고객 패널과 함께 알아보는 Google Cloud Platform에 발표함
        &lt;ul&gt;
          &lt;li&gt;코엑스에서 600명 넘는 분들 앞에서 발표할 수 있는 기회였습니다! 제가 여태까지 발표한 장소 중 제일 거대했습니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;GDG Pangyo에서 진행한 &lt;a href=&quot;https://www.facebook.com/GDG.Pangyo/videos/512428869490079/&quot;&gt;ML Pipeliners&lt;/a&gt; 멘토링 진행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;12월&quot;&gt;12월&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;학습
    &lt;ul&gt;
      &lt;li&gt;cs224w를 공부하기 시작. Graph 관점으로 문제를 풀어보기 위한 도전&lt;/li&gt;
      &lt;li&gt;Tensorflow 2.0 다시 공부 중&lt;/li&gt;
      &lt;li&gt;Google BigQuery : The Definitive Guide 책을 번역하는 중. 책 내용은 한번 봤는데, 번역하는 일은 또 빡세다는 것을 느끼는 중&lt;/li&gt;
      &lt;li&gt;쏘카 데이터그룹 테크 밋업 준비 및 홍보함. 직접 발표하진 않았지만 사람들이 좋아할 소재를 찾아 제안함&lt;/li&gt;
      &lt;li&gt;Airflow를 더 강력하게 쓰는 중. 소스코드를 까보며 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정서적 안정감
    &lt;ul&gt;
      &lt;li&gt;Task 외에 추가된 업무가 너무 많아 요새 고민하는 중. 극강의 매니저 역할을 해야하는 것일까? Task를 직접 진행해야 할까? 아직도 정답은 내리지 못했지만 이 부분에 대해 계속 고민하다보니 정서적 안정감이 종종 변하고 있음. 앞으로 미래에 어떤 사람이 될지 고민하는 중&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기타
    &lt;ul&gt;
      &lt;li&gt;글또 3기가 12월부로 종료되었고, 1월 중 ~ 2월부터 글또 4기를 시작할 예정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;키워드-정리&quot;&gt;키워드 정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;올해 몇 가지 키워드를 추려보면 다음과 같습니다
    &lt;ul&gt;
      &lt;li&gt;팀장의 역할&lt;/li&gt;
      &lt;li&gt;최적화(Optimization)&lt;/li&gt;
      &lt;li&gt;MLOps&lt;/li&gt;
      &lt;li&gt;딥놀 유튜브&lt;/li&gt;
      &lt;li&gt;Notion&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;팀장의-역할&quot;&gt;팀장의 역할&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;생각보다 낮은 연차에 팀장을 맡으며 고민이 많아졌습니다. “어떤 팀장이 되야할까?”
    &lt;ul&gt;
      &lt;li&gt;제가 예전에 같이 있었던 상사, 팀장님들은 어떤 사람이었는지 생각해보며 저는 어떤 상사를 원했는지 고민했습니다&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/d5d7eyddx93c68j/Screenshot%202019-12-25%2014.50.38.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;저는 “팀원 개인의 욕구를 잘 충족해주고, 잘 성장할 수 있도록 돕고 필요한 경우 문제 해결을 잘 도와주는 팀장”을 하기로 결정했고, 매달 정기 면담을 통해 팀원들의 성격 + 욕구를 파악해 팀원들의 욕구를 충족시킬 수 있도록 노력했습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;아마 팀원들의 동기 부여를 잘 주고, 팀원들이 만족하고 있다고 생각합니다&lt;/li&gt;
  &lt;li&gt;앞으론 더 잘 성장하도록 돕고, 저도 업무를 주도적으로 하며 그 지식을 공유하는게 중요하지 않을까? 생각하고 있습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;최적화&quot;&gt;최적화&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 사이언스쪽엔 보통 머신러닝/딥러닝 위주로 많은 분들이 공부하고 있습니다
    &lt;ul&gt;
      &lt;li&gt;저 또한 그랬는데, 최적화 방법론이 현실의 문제를 효율적으로 푸는 경우도 있는 것을 깨달았습니다&lt;/li&gt;
      &lt;li&gt;머신러닝과 최적화 방법을 혼합하면 비즈니스 문제를 효율적으로 풀 수 있습니다. 예를 들면 제품의 수요가 예측될 경우, 그 수요값에 기반해 생산 계획을 수립할 수 있습니다
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/lidckefqhm7iofd/Screenshot%202019-12-25%2014.45.41.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;이런 문제들은 예측 모델링의 결과값이 최적화의 Input으로 들어가게 됩니다. 그 후, 시나리오에 따라 전략이 결정됩니다
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/0znzos17qrhmjxp/Screenshot%202019-12-25%2014.45.57.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;mlops&quot;&gt;MLOps&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;머신러닝/딥러닝이 인기를 끌며 점점 많은 분들이 공부하고 있습니다. 실제 모델링 코드는 몇줄 안되지만 Production화하기 위해선 여러 개발 작업이 필요합니다&lt;/li&gt;
  &lt;li&gt;이런 부분을 자동화하기 위해 다양한 도구들이 나오고 있고, 대표적으로 Serving, Auto ML, Experiment 관리 등이 있습니다&lt;/li&gt;
  &lt;li&gt;이 부분은 데이터 엔지니어링, 개발에 관심갖던 제 성향에 잘 맞아 꾸준히 공부하고 있습니다&lt;/li&gt;
  &lt;li&gt;아마 Google에서 많은 Application을 계속 출시할 것으로 예상됩니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;딥놀-유튜브&quot;&gt;딥놀 유튜브&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;블로그나 인스타그램은 많이 하고 있어서, 이제 도전한다면 유튜브를 해야하지 않을까? 생각했습니다&lt;/li&gt;
  &lt;li&gt;혼자서 유튜브 시작하는건 매우 부담스러워서, 지인분들과 데이터 관련 이야기하는 유튜브를 만들었습니다
    &lt;ul&gt;
      &lt;li&gt;혼자 진행하는 것보다 여러명이 함께하니 훨씬 규칙적으로 진행할 수 있는 것 같습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;편집자가 따로 없어서 직접 편집해야 하지만.. Vrew 등을 활용해 더 빠르게 영상을 만들고 있습니다!&lt;/li&gt;
  &lt;li&gt;내년엔 더 많은 영상으로 찾아뵙길..!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;notion&quot;&gt;Notion&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;노션을 사용한지 이제 1년이 넘었습니다&lt;/li&gt;
  &lt;li&gt;예전엔 메모를 중구난방으로 했는데, 이젠 모두 노션에 저장되어 있습니다
    &lt;ul&gt;
      &lt;li&gt;회사에서 작성한 회의록 정리, 기술에 대한 디버깅, Project 진행 상황 템플릿, 링크 모음 등 1년 이상 사용하니 어느정도 저만의 방식이 생긴 것 같습니다&lt;/li&gt;
      &lt;li&gt;내년엔 메모를 어떻게 해야할까?에 대한 내용으로 한번 발표하는 자리를 만들어보려고 합니다 :)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;링크를 아래와 같이 정리하면 다시 찾기 쉽고 보기도 이쁩니다!
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/vtr8gdnn8l18uhj/Screenshot%202019-12-25%2014.56.11.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;마치며&quot;&gt;마치며&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2019년은 정말! 열심히 지냈고, 빠르게 지나갔습니다. 많은 것을 했지만 동시에 못했던 것들도 있으니 그 부분을 잘 채워서 2020년은 더 발전하는 해가 되도록 노력하려고 합니다-!&lt;/li&gt;
  &lt;li&gt;2019년에 블로그 글은 총 56개 작성했으니 평균으로 치면 최소한 1주에 글 1개는 작성한 것 같네요 :)&lt;/li&gt;
  &lt;li&gt;외부 발표는 총 5번 진행했고, 사내 발표는 꽤 많이..! 2020년엔 발표를 많이 할지에 대한 구체적인 생각은 없지만, 조금 더 고민해봐야 겠네요 :)&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 25 Dec 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/diary/2019/12/25/2019-retrospect/</link>
        <guid isPermaLink="true">http://localhost:4000/diary/2019/12/25/2019-retrospect/</guid>
        
        <category>diary</category>
        
        
        <category>diary</category>
        
      </item>
    
      <item>
        <title>Rules of Machine Learning: Best Practices for ML Engineering 정리</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Google의 Research Scientist인 Martin Zinkevich가 작성하신 &lt;a href=&quot;http://martin.zinkevich.org/rules_of_ml/rules_of_ml.pdf&quot;&gt;Rules of Machine Learning: Best Practices for ML Engineering&lt;/a&gt; 나름대로 번역하고 정리한 글입니다&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.google.com/machine-learning/guides/rules-of-ml&quot;&gt;Machine Learning Guides&lt;/a&gt;에 언어를 한국어로 조정하면 번역본이 나오지만, 개인 학습 목적으로 정리했습니다(4부까지만 번역하고 그 이후는 번역하지 않았으니 원본이 궁금하시면 꼭 링크를 참고해주세요)
    &lt;ul&gt;
      &lt;li&gt;정리하며 제가 이해한 상태로 정리했고, 추가적으로 제가 아는 내용을 덧붙였습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;best-practices-for-ml-engineering&quot;&gt;Best Practices for ML Engineering&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;이 문서는 머신러닝에 대한 기본 지식을 가진 사람들이 Google의 머신러닝 best practice의 장점을 얻을 수 있도록 돕기 위한 문서&lt;/li&gt;
  &lt;li&gt;Google C++ 스타일 가이드처럼 머신러닝 관련한 실용적인 내용을 전달함&lt;/li&gt;
  &lt;li&gt;머신러닝 모델을 개발하거나 다뤄본 경험이 있다면 이 문서를 읽기 위한 배경 지식을 갖춘 것&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;terminology용어&quot;&gt;Terminology(용어)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;반복적으로 사용될 용어 정의&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Instance&lt;/code&gt; : 예측하려는 대상. 웹페이지를 “고양이와 관련”, “고양이와 무관”으로 분류하려는 경우 웹페이지가 인스턴스임&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Label&lt;/code&gt; : 예측 작업에 관한 답으로, 머신러닝 시스템이 도출하거나 학습 데이터에서 제공된 정답&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Feature&lt;/code&gt; : 예측 작업에 사용되는 인스턴스의 속성. ‘웹페이지에 고양이란 단어가 나온 횟수’ 등을 예로 들 수 있음&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Feature Column&lt;/code&gt; : 관련된 feature의 집합. 예를 들어 사용자가 거주할 수 있는 모든 국가의 집합. Feature column은 Google에서만 사용되는 용어고, Yahoo/Microsoft에선 namespace라고 함&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Example&lt;/code&gt; : Instance(Feature 포함) 및 Label&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Model&lt;/code&gt; : 예측 작업의 통계적 표현(statistical representation) example을 사용해 모델을 학습한 후, 그 모델을 사용해 예측함&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Metric&lt;/code&gt; : 관심이 있는 수치. 직접 최적화될 수 있고, 아닐수도 있음&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Objective&lt;/code&gt; : 알고리즘에서 최적화하려는 Metric&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Pipeline&lt;/code&gt; : 머신러닝 알고리즘을 둘러싼 인프라. 프론트엔드는 데이터를 수집하고, Train 데이터 저장, 모델 Train, 모델 Production으로 내보내는 것을 포함함&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Click-through Rate&lt;/code&gt; : 광고에서 링크를 클릭하는 비율&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;멋진 제품을 만들기 위해, 머신러닝 전문가 흉내를 내지 말고 훌륭한 엔지니어처럼 머신러닝을 활용해야 함&lt;/li&gt;
  &lt;li&gt;실제로 직면하는 문제는 대부분 엔지니어링 문제임. 결국 좋은 Feature를 갖는 것이 중요함&lt;/li&gt;
  &lt;li&gt;기본 접근 방법
    &lt;ul&gt;
      &lt;li&gt;1) 파이프라인이 end to end로 견고하게 되어있는지 확인&lt;/li&gt;
      &lt;li&gt;2) 합리적인 objective로 시작&lt;/li&gt;
      &lt;li&gt;3) 간단한 방법으로 상식적인 feature 추가&lt;/li&gt;
      &lt;li&gt;4) 파이프라인이 견고하게 되어있는지 확인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 접근법은 오래 사용할 수 있고, 혹시 기본 접근 방법으로 더 이상 진행할 수 없는 경우 다른 방식을 찾아야 함&lt;/li&gt;
  &lt;li&gt;복잡성을 증가시키면 개발은 느려짐&lt;/li&gt;
  &lt;li&gt;기본 접근 방법으로 부족하면 최첨단 머신러닝 기법을 도전할 때고, 3단계 섹션을 참고하면 됨&lt;/li&gt;
  &lt;li&gt;이 문서의 구성
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#1부-before-machine-learning&quot;&gt;1부&lt;/a&gt; : 머신러닝 시스템을 구축하기에 적절한 시점에 대한 이야기&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2부-ml-1단계-your-first-pipeline&quot;&gt;2부&lt;/a&gt; : 첫 파이프라인을 구축하는 방법&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#3부-ml-2단계-feature-engineering&quot;&gt;3부&lt;/a&gt; : 파이프라인에 새 Feature를 추가하며 계속 출시, 반복하는 과정에 대한 이야기 + 모델 training-serving의 skew를 평가하는 방법&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#4부-ml-3단계-slowed-growth-optimization-refinement-and-complex-models&quot;&gt;4부&lt;/a&gt; : 개선이 한계에 부딪힌 경우 대처하는 방법&lt;/li&gt;
      &lt;li&gt;부록 : 자주 사용되는 시스템에 관한 배경 지식&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1부-before-machine-learning&quot;&gt;1부. Before Machine Learning&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Rule #1: 머신러닝 없이 제품을 출시하는 것을 두려워하지 말기
    &lt;ul&gt;
      &lt;li&gt;머신러닝은 매우 cool하지만, 데이터가 필요함&lt;/li&gt;
      &lt;li&gt;다른 문제로 데이터를 가져와서 모델을 살짝 수정해 적용하는 방법은 이론적으론 가능하지만 휴리스틱보다 성능이 떨어질 가능성이 높음&lt;/li&gt;
      &lt;li&gt;머신러닝의 효과를 100% 기대한다면 휴리스틱을 사용해도 50%의 효과는 볼 수 있음&lt;/li&gt;
      &lt;li&gt;예 : 앱 마켓플레이스에서 앱 순위를 매길 때 설치율, 설치 횟수를 휴리스틱으로 사용할 수 있음, 스팸을 감지할 때 전에 스팸을 보낸 적이 있는 발신자를 걸러내면 됨. 연락처의 순위를 매길시 최근에 자주 사용한 연락처 순으로 해도 됨&lt;/li&gt;
      &lt;li&gt;머신러닝이 제품에 정말 필요한 기능이 아니면 데이터를 충분히 수집하기 전엔 사용하지 말기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #2: 가장 먼저 측정 항목(Metric)을 설계하고 구현하기
    &lt;ul&gt;
      &lt;li&gt;머신러닝 시스템을 구축하기 전에 현재 시스템을 최대한 많이 알고 있어야 함. 그 이유는 다음과 같음
        &lt;ul&gt;
          &lt;li&gt;1) 시스템 사용자에게 미리 사용 권한을 받기 쉽다&lt;/li&gt;
          &lt;li&gt;2) 미래에 발생할 수 있는 문제가 있다면 지금부터 과거 데이터를 수집하는 것이 좋음&lt;/li&gt;
          &lt;li&gt;3) metric 측정을 염두에 두고 시스템을 설계하면 나중에 편함. 구체적으로 metric을 위해 로그에서 문자열을 모두 grep할 필요가 없이 설계하면 됨&lt;/li&gt;
          &lt;li&gt;4) 무엇이 바뀌고 무엇이 동일하게 유지되는지 알 수 있음. 예를 들어 1일 활성 사용자 수를 최적화하려고 할 때, 사용자 경험을 크게 바꿔도 metric에 눈에 띄는 변화가 없을 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Google Plus 팀은 read당 exapand 수, read당 reshare 수, read당 plusones 수, 댓글/읽기, 유저당 댓글 수, 
유저당 재공유 횟수 등을 측정해 게시물의 품질을 계산할 때 사용함. &lt;strong&gt;그리고 사용자를 그룹화해 실험할 수 있는 실험 프레임워크를 갖추는 것이 중요함.&lt;/strong&gt; Rule #12 참고&lt;/li&gt;
      &lt;li&gt;Metric을 적극적으로 모니터링할수록 시스템을 전반적으로 파악하기 쉬워짐. 문제를 찾았다면 metric에 추가해 모니터링. 최근 릴리즈에 만족할만한 정량적 변화가 있었다면 metric에 추가하자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #3: 휴리스틱이 복잡하면 머신러닝을 선택하기
    &lt;ul&gt;
      &lt;li&gt;단순한 휴리스틱만 갖춰도 제품을 출시할 수 있음&lt;/li&gt;
      &lt;li&gt;휴리스틱이 복잡하면 유지보수가 불가능&lt;/li&gt;
      &lt;li&gt;데이터가 확보되고 달성하려는 목표가 확실해지면 머신러닝으로 진행할 수 있음&lt;/li&gt;
      &lt;li&gt;소프트웨어 엔지니어링 작업에서 휴리스틱/머신러닝 모델인지 상관없이 계속 업데이트가 필요함&lt;/li&gt;
      &lt;li&gt;머신러닝 모델이 휴리스틱보다 업데이트 및 유지보수가 쉬움. Rule 16 참고&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2부-ml-1단계-your-first-pipeline&quot;&gt;2부. ML 1단계: Your First Pipeline&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;첫 파이프라인에선 시스템 인프라에 집중하기&lt;/li&gt;
  &lt;li&gt;머신러닝의 가능성에 대해 상상하는 것도 재미있지만, 파이프라인을 먼저 믿지 않으면 어떤 일이 일어나는지 파악하기 어려움(=파이프라인이 확실해야 현재 상황을 제대로 파악할 수 있음)&lt;/li&gt;
  &lt;li&gt;Rule #4: 최초 모델은 단순하게 가져가고 인프라를 제대로 만들기
    &lt;ul&gt;
      &lt;li&gt;첫 모델은 제품 개선에 가장 크게 기여하기 때문에 처음부터 화려한 기능을 갖추지 않아도 됨&lt;/li&gt;
      &lt;li&gt;그러나 인프라가 예상보다 더 문제를 겪을 수 있음&lt;/li&gt;
      &lt;li&gt;Facny한 새 머신러닝 시스템을 사용하기 전에 다음과 같은 내용을 결정해야 함
        &lt;ul&gt;
          &lt;li&gt;학습 알고리즘에 example을 제공할 방법&lt;/li&gt;
          &lt;li&gt;시스템의 good과 bad를 판단할 기준&lt;/li&gt;
          &lt;li&gt;모델을 Application에 통합할 방법. 모델을 실시간으로 적용할 수 있고, 미리 예측해 결과를 Table에 저장할 수 있음. 예를 들어 웹페이지는 미리 분류해 테이블에 결과를 저장하고, 채팅 메세지는 실시간으로 분류할 수 있음&lt;/li&gt;
        &lt;/ul&gt;

        &lt;blockquote&gt;
          &lt;p&gt;(역자) : 실시간으로 적용하는 경우엔 Flask, TF Serving 등을 사용해 API로 제공하는 방식이 있고, 배치성으로(1시간에 1번) 진행할 경우엔 Database에 저장하는 방식이 있음&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;단순한 Feature를 선택하면 다음 작업을 쉽게 진행할 수 있음
        &lt;ul&gt;
          &lt;li&gt;Feature가 학습 알고리즘에 정확히 도달함&lt;/li&gt;
          &lt;li&gt;모델이 합리적인 weight를 학습함&lt;/li&gt;
          &lt;li&gt;Feature가 서버의 모델에 정확히 도달함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;이런 3가지 과제를 안정적으로 달성할 시스템을 만들었으면, 대부분의 일을 한 것임&lt;/li&gt;
      &lt;li&gt;이제 단순한 모델에서 baseline metric과 baseline behavior를 얻어 더 복잡한 모델을 테스트할 때 활용할 수 있음&lt;/li&gt;
      &lt;li&gt;(구글의) 어떤 팀에선 “중립적”인 최초 런칭을 목표로 하는데, 이는 머신러닝으로 얻을 당장의 이익에 집착하지 않고 본질의 목표에 집중하기 위함임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #5: 머신러닝과 별도로 인프라 테스트하기
    &lt;ul&gt;
      &lt;li&gt;인프라틑 테스트할 수 있어야하고, 시스템의 train 부분은 캡슐화해야 모든 관련 부분을 테스트할 수 있음. 특히 다음과 같은 작업이 필요함
        &lt;ul&gt;
          &lt;li&gt;1) 알고리즘에 데이터를 넣는 기능 테스트
            &lt;ul&gt;
              &lt;li&gt;생성되야 하는 Feature가 잘 채워졌는지 확인&lt;/li&gt;
              &lt;li&gt;개인정보 보호하는 범위 내에서 input 값을 직접 조사&lt;/li&gt;
              &lt;li&gt;가능하면 파이프라인의 통계를 다른 곳에서(로컬 등) 데이터 처리해 나온 통계와 비교&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;2) 모델을 알고리즘에서 추출하는 기능 테스트
            &lt;ul&gt;
              &lt;li&gt;Train 환경의 모델이 주는 점수와 Serving 환경의 모델과 동일한지 확인. Rule 37 참조&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;머신러닝엔 예측 불가능성이 있어서, Train 및 Serving시 Example을 생성하는 코드를 테스트할 준비하고, Serving 중 고정된 모델을 로드해 사용할 수 있는지 확인해야 함&lt;/li&gt;
      &lt;li&gt;또한 데이터를 이해하는 것이 중요함. &lt;a href=&quot;http://www.unofficialgoogledatascience.com/2016/10/practical-advice-for-analysis-of-large.html&quot;&gt;Practical advice for analysis of large, complex data sets&lt;/a&gt; 참고&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #6: 파이프라인을 복사할 땐 데이터 누락 주의하기
    &lt;ul&gt;
      &lt;li&gt;기존 파이프라인을 복사해 새로운 파이프라인을 만들었는데, 새 파이프라인에 필요한 데이터가 기존 파이프라인에 누락되는 경우가 종종 있음&lt;/li&gt;
      &lt;li&gt;예를 들어 Google+ HOT 소식의 파이프라인은 최신 게시물의 순위를 매기는 것이 목적이라 과거 게시물들이 유의미한데, 복사해온 파이프라인에서 과거 게시물들을 누락시킴
        &lt;ul&gt;
          &lt;li&gt;이 파이프라인을 Google+ 스트림에 사용하기 위해 복사했더니 이 기능에선 과거 게시물들이 누락됨&lt;/li&gt;
          &lt;li&gt;사용자가 트정 게시물을 조회하지 않은 이유를 모델링할 경우 negative example이 모두 누락되므로 결국 쓸모없는 데이터가 됨&lt;/li&gt;
          &lt;li&gt;Play에도 비슷한 문제가 있었음. Play 앱 홈 화면을 만들며 Play 게임 방문 페이지의 Example을 포함한 파이프라인을 새로 만들었는데, 각 example의 출처를 구분짓지 않았음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #7: 휴리스틱을 Feature로 변환하거나 외부에서 처리하기
    &lt;ul&gt;
      &lt;li&gt;머신러닝으로 해결하려는 문제들은 보통 새로 등장한 Problem은 아님. 순위 결정, 분류 등 어떤 문제든 과거에 사용하던 기존 시스템이 있음&lt;/li&gt;
      &lt;li&gt;따라서 수많은 규칙(Rule base), 휴리스틱이 이미 존재함&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;휴리스틱 + 머신러닝의 조합&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;기존 휴리스틱을 철저히 분석해야 함. 첫번째로 머신러닝 시스템으로 전환이 더 원활해짐. 둘째로 이런 규칙은 시스템에 대한 직관을 풍부하게 담고 있음. 다음 4가지 방법으로 휴리스틱을 사용할 수 있음
        &lt;ul&gt;
          &lt;li&gt;1) 휴리스틱을 사용해 전처리
            &lt;ul&gt;
              &lt;li&gt;믿을 수 없을만큼 awesome한 feature인 경우 고려할 수 있음&lt;/li&gt;
              &lt;li&gt;예를 들어 스팸 필터에서 보낸 사람이 이미 차단 목록에 들어있으면 차단 목록을 다시 학습할 필요없음. 단순히 메세지를 차단하면 됨&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;2) Feature 생성
            &lt;ul&gt;
              &lt;li&gt;휴리스틱에서 직접 Feature 생성&lt;/li&gt;
              &lt;li&gt;예를 들어 휴리스틱을 사용해 쿼리 결과의 유사도 점수를 계산할 경우 이 점수를 Feature로 넣을 수 있음&lt;/li&gt;
              &lt;li&gt;이후에 머신러닝 기법을 사용해 값을 조정할 수 있지만 처음엔 휴리스틱에서 나오는 값을 그대로 사용해도 됨&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;3) 휴리스틱의 input을 Feature로 사용
            &lt;ul&gt;
              &lt;li&gt;앱의 설치 횟수, 텍스트 문자 수, 요일을 결합하는 휴리스틱이 있다면 이런 값을 학습에 제공하는 것이 좋음. 이 때 앙상블에 적용되는 기법이 일부 적용됨. Rule 40 참조&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;4) Label을 수정
            &lt;ul&gt;
              &lt;li&gt;휴리스틱이 현재 Label에 포함되지 않는 정보를 포착하면 이 방법을 사용할 수 있음&lt;/li&gt;
              &lt;li&gt;예를 들어 다운로드 횟수를 극대화하며 컨텐츠 품질에도 중점을 두려면 앱이 받은 평균 별점 수로 label을 곱하는 것이 답일 수 있음. 정해진 방식은 없음. 첫 목표 참고&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ML 시스템에서 휴리스틱을 사용하는 경우 복잡도가 추가되는 것을 주의해야 함. 새로운 머신러닝 알고리즘에 기존 휴리스틱을 사용하면 전환이 원활할 수 있지만, 더 간단한 방법으로 같은 효과를 낼 수 없는지 고민해보면 좋음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;모니터링&quot;&gt;모니터링&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;일반적으로 알림에 실제 정보를 추가하고 모니터링할 수 있는 대시보드 페이지를 마련하곤 함&lt;/li&gt;
  &lt;li&gt;Rule #8: 시스템의 갱신(freshness) 요구사항을 파악하기
    &lt;ul&gt;
      &lt;li&gt;모델이 하루, 1주일, 1분기 뒤에 성능이 얼마나 떨어지는지?&lt;/li&gt;
      &lt;li&gt;이 정보는 모니터링의 우선순위를 판단할 때 도움이 됨&lt;/li&gt;
      &lt;li&gt;하루동안 모델을 업데이트하지 않았더니 제품의 품질이 떨어지는 경우 모델을 지속적으로 모니터링하는 엔지니어를 두는 것이 좋음&lt;/li&gt;
      &lt;li&gt;광고 시스템같이 매일 새로운 광고가 유입되는 경우 업데이트가 매일 진행되야 함&lt;/li&gt;
      &lt;li&gt;예를 들어 Google Play 검색의 모델이 업데이트되지 않으면 1개월 이내에 부정적인 영향을 미침&lt;/li&gt;
      &lt;li&gt;Google+의 HOT 소식에서 게시물 id를 갖지 않는 일부 모델은 자주 내보낼 필요가 없고, 게시물 id를 갖는 모델은 자주 업데이트됨&lt;/li&gt;
      &lt;li&gt;갱신 기준은 시간에 따라 변화할 수 있음(특히 모델에서 feature column이 추가되거나 삭제될 경우)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #9: 모델을 내보내기 전에 문제를 탐지하기
    &lt;ul&gt;
      &lt;li&gt;많은 머신러닝 시스템엔 모델을 서빙 환경으로 내보내는 단계가 있음. 내보낸 모델에 문제가 있는 경우 유저가 바로 알아차림&lt;/li&gt;
      &lt;li&gt;모델을 내보내기 전에 sanity check(품질 검사)를 해야 함&lt;/li&gt;
      &lt;li&gt;홀드아웃 데이터에 대해 모델의 성능이 적절한지 확인해야 함&lt;/li&gt;
      &lt;li&gt;또는 데이터의 신빙성이 의심되면 모델을 내보내지 말아야 함&lt;/li&gt;
      &lt;li&gt;계속 모델을 내보내는 팀은 대부분 AUC를 확인한 후 내보냄&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;모델을 제때 내보내지 못하는 것은 이메일 알림으로 해결할 수 있지만, 문제 있는 모델을 제공하면 사태가 커짐&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;따라서 유저에게 영향을 미치는 것보다 늦는게 나을 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #10: 조용한 실패(silent failures)에 주의하기
    &lt;ul&gt;
      &lt;li&gt;개발 시스템보다 머신러닝 시스템에서 자주 나타나는 문제&lt;/li&gt;
      &lt;li&gt;Join 대상이 되는 특정 테이블이 더 이상 업데이트되지 않는 경우, 이 테이블 기반으로 머신러닝 시스템을 구축하면 겉보기엔 특별한 문제가 없어도 실제론 성능이 점점 떨어짐
        &lt;ul&gt;
          &lt;li&gt;몇 달 동안 그대로였던 테이블을 갱신하는 것으로 놀라운 성능 개선 효과를 거둘 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;구현 변경으로 Feature의 포함 범위가 바뀌기도 함
        &lt;ul&gt;
          &lt;li&gt;Feature column이 90%에서 60%로 급락할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;데이터의 통계를 모니터링하면 이런 유형의 실패를 줄일 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #11: Feature column에 소유자를 지정하고 문서화하기
    &lt;ul&gt;
      &lt;li&gt;시스템의 규모가 크고 Feature column이 많은 경우 각 컬럼을 누가 만들었고, 관리하는지 알아야 함&lt;/li&gt;
      &lt;li&gt;담당자가 조직을 떠날 경우 철저한 인수인계가 이루어져야 함&lt;/li&gt;
      &lt;li&gt;이름만 봐도 의미를 알 수 있는 Feature column도 많지만, 특성의 의미, 출처, 유용성을 자세히 기록해두는 습관을 들이는 것이 좋음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;첫-목표objective&quot;&gt;첫 목표(Objective)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;시스템에서 중요한 metric이 아무리 많아도 머신러닝 알고리즘에 필요한 &lt;strong&gt;목표(objective), 알고리점에서 최적화할 수치&lt;/strong&gt;는 일반적으로 단 하나&lt;/li&gt;
  &lt;li&gt;Objective와 Metric을 잘 구분해야 함&lt;/li&gt;
  &lt;li&gt;Metric은 시스템에서 보고하는 다양한 숫자들로 중요할 수도, 중요하지 않을 수도 있음. Rule #2 참조&lt;/li&gt;
  &lt;li&gt;Rule #12: 어떤 objective를 직접 최적화할지 너무 고민하지 말기
    &lt;ul&gt;
      &lt;li&gt;당신은 돈을 벌거나, 유저를 행복하게 만들거나, 세상을 더 좋게 만드는데 기여하는 것을 원할것임&lt;/li&gt;
      &lt;li&gt;중요하게 생각할 metric은 무수히 많고, 이것들을 모두 측정해야 함&lt;/li&gt;
      &lt;li&gt;그러나 머신러닝 초기엔 모든 metric이 증가하는 것을 알 수 있음
        &lt;ul&gt;
          &lt;li&gt;예를 들어 클릭수 및 사용 시간이 중요하다고 가정한 경우, 클릭수를 최적화하면 사용 시간도 증가할 가능성이 높음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;모든 metric이 쉽게 증가할 수 있으므로, 다양한 metric 간 균형을 맞추려고 고민하지 말고 단순하게 생각하면 됨&lt;/li&gt;
      &lt;li&gt;하지만 이 규칙에도 한계가 있음. objetive와 시스템의 절대적 안전성을 혼돈해선 안됨(Rule 39 참조)&lt;/li&gt;
      &lt;li&gt;또한 &lt;strong&gt;직접 최적화하는 metric은 개선되지만 결국 출시에 실패하는 상황이 반복되면 objective를 수정해야 할 수 있음&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #13: 단순하고 관찰 가능하고 추적 가능한 metric을 첫 목표로 선택하기
    &lt;ul&gt;
      &lt;li&gt;궁극적인 목표를 미리 알지 못하는 경우도 많음&lt;/li&gt;
      &lt;li&gt;목표를 일단 정하고, 기존 시스템과 새로운 머신러닝 시스템 데이터를 나란히 분석하면 목표를 수정하고 싶어짐&lt;/li&gt;
      &lt;li&gt;궁극적인 목표에 대해 팀원들의 의견이 다를 수 있음&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;ML Objective는 측정하기 쉬우면서 진정한 목표를 반영해야 함&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;단순한 ML 목표를 기준으로 학습하되, 다른 로직(이왕이면 단순한)을 추가해 최종 순위를 결정할 수 있도록 “policy layer”를 상단에 두는 것이 좋음&lt;/li&gt;
      &lt;li&gt;가장 모델링하기 쉬운 대상은 직접 관찰되고 시스템 동작과 인과성을 추적할 수 있는 사용자 행동
        &lt;ul&gt;
          &lt;li&gt;Ranked list가 클릭되었는가?&lt;/li&gt;
          &lt;li&gt;Ranked object가 다운되었는가?&lt;/li&gt;
          &lt;li&gt;Ranked object가 전달, 회신, 이메일로 발성되었는가?&lt;/li&gt;
          &lt;li&gt;Ranked object가 평가되었는가?&lt;/li&gt;
          &lt;li&gt;보이는 object가 스팸/음란물/불쾌감을 주는 컨텐츠로 신고되었는가?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;간접 효과는 처음에 모델링하지 말기
        &lt;ul&gt;
          &lt;li&gt;사용자가 다음 날 방문했는가?&lt;/li&gt;
          &lt;li&gt;사용자가 사이트를 얼마나 오래 방문했는가?&lt;/li&gt;
          &lt;li&gt;일일 활성 사용자 수는 몇인가?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;간접 효과도 좋은 metric으로 AB Test 및 출시 결정에 활용될 수 있음&lt;/li&gt;
      &lt;li&gt;다음과 같은 의문을 해결할 때 머신러닝을 사용하지 말기
        &lt;ul&gt;
          &lt;li&gt;사용자가 제품을 만족하고 있는가?&lt;/li&gt;
          &lt;li&gt;사용자 경험이 만족스러운가?&lt;/li&gt;
          &lt;li&gt;제품이 사용자의 전반적인 삶의 질을 높여주는가?&lt;/li&gt;
          &lt;li&gt;회사의 전반적인 건강함에 어떤 영향을 주는가?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;모두 중요하지만 측정하기가 매우 어려움. 간접적인 기준으로 대신하자&lt;/li&gt;
      &lt;li&gt;사용자가 만족감을 느낀다면 사이트에 더 오래 머무르고, 다음 날 다시 방문할 것임&lt;/li&gt;
      &lt;li&gt;삶의 질이나 회사의 건강함과 관련되는 부분은 사람의 판단이 필수적&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #14: 해석 가능한 모델부터 시작하면 디버깅이 쉬움
    &lt;ul&gt;
      &lt;li&gt;선형 회귀, 로지스틱 회귀, 푸아송 회귀는 확률론 모델에서 나온 것들임&lt;/li&gt;
      &lt;li&gt;각 예측은 확률 또는 기대값으로 해석할 수 있음&lt;/li&gt;
      &lt;li&gt;예를 들어 Train 시스템의 확률이 병렬로 운영되거나 별도로 조사된 프러덕션 시스템의 확률과 차이가 나면 이를 통해 문제가 드러날 수 있음&lt;/li&gt;
      &lt;li&gt;단순 모델에선 feedback loop를 다루는 방법이 더 쉬움(Rule #36 참조) 이런 확률 예측을 근거로 결정내리는 경우가 많음&lt;/li&gt;
      &lt;li&gt;클릭 확률, 다운로드 확률 등의 기대값에 따라 내림차순으로 게시물의 순위를 매길 수 있음&lt;/li&gt;
      &lt;li&gt;그러나 어떤 모델을 사용할지 선택할 땐 모델에 제공된 데이터의 확률보다 Decision이 더 중요함(Rule #26 참조)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #15: Policy Layer에 스팸 필터링과 Quality Ranking을 분리하자
    &lt;ul&gt;
      &lt;li&gt;Quality Ranking이 예술이라면 스팸 필터링은 전쟁임&lt;/li&gt;
      &lt;li&gt;사용자들은 게시물의 품질을 판단하는데 사용하는 지표를 금방 알아차리고 게시물을 적당히 손질해 이런 속성을 갖게 만듬(인스타그램 생각하면 쉬울듯)&lt;/li&gt;
      &lt;li&gt;따라서 Quality Ranking에선 정상적인 의도로 게시된 컨텐츠의 순위를 매기는 데 집중해야 함&lt;/li&gt;
      &lt;li&gt;스팸의 순위를 높게 매겼다고 해서 Quality Ranking 학습 시스템을 평가절하해선 안됨&lt;/li&gt;
      &lt;li&gt;선정적인 컨텐츠도 마찬가지 이유로 Quality Ranking과 별도로 처리해야 함&lt;/li&gt;
      &lt;li&gt;때론 시스템에 규칙을 도입하기도 함 : 스팸 신고가 3회 초과하면 게시물은 제외한다&lt;/li&gt;
      &lt;li&gt;학습 모델은 최소 하루 1번 이상 업데이트되야 하고, 컨텐츠 작성자의 평판도 큰 역할을 함&lt;/li&gt;
      &lt;li&gt;이런 두 시스템의 출력을 일정 수준에서 통홥해야 함&lt;/li&gt;
      &lt;li&gt;주의 : 검색 결과의 스팸 필터링은 이메일보다 더 공격적이어야 함
        &lt;ul&gt;
          &lt;li&gt;정규화를 사용하지 않고 알고리즘이 수렴한다는 전제 하에 이 사실은 참임&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;스팸은 품질 분류용 학습 데이터에서 제외하는 것이 일반적인 관행임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3부-ml-2단계-feature-engineering&quot;&gt;3부. ML 2단계: Feature Engineering&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;머신러닝 시스템 lifecycle의 첫 단계에서 중요한 이슈는 Train 시스템에 데이터를 공급하고, 의미있는 metric을 측정하고 서빙 인프라를 구축하는 것&lt;/li&gt;
  &lt;li&gt;unit test와 system test를 갖춘 정상적인 end to end 시스템을 구축했다면 2단계로 넘어가자&lt;/li&gt;
  &lt;li&gt;2단계는 다양하고 알기 쉬운 Feature를 시스템에 넣으면 됨
    &lt;ul&gt;
      &lt;li&gt;머신러닝 2단계에서선 최대한 많은 Feature를 직관적인 방식으로 넣는 것에 관심을 가짐&lt;/li&gt;
      &lt;li&gt;이 단계는 모든 metric이 상승세를 보여야 함&lt;/li&gt;
      &lt;li&gt;출시를 반복하며 필요한 데이터를 모두 모아 train 시스템의 성능을 극대화해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #16: 출시와 반복을 계획하기
    &lt;ul&gt;
      &lt;li&gt;지금 작업 중인 모델이 마지막 출시 버전이 될 것이라거나, 반복적인 모델 출시가 언젠가 끝날거라는 기대는 버리면 좋음&lt;/li&gt;
      &lt;li&gt;이번 출시에서 추가되는 복잡성으로 인해 이후 출시가 늦춰질 가능성이 있는지 고려해야 함&lt;/li&gt;
      &lt;li&gt;많은 팀에서 지금까지 분기당 1회 이상 출시를 진행함&lt;/li&gt;
      &lt;li&gt;새 모델을 출시하는 기본적인 3가지 이유
        &lt;ul&gt;
          &lt;li&gt;새로운 Feature 도입&lt;/li&gt;
          &lt;li&gt;정규화 조정 및 이전 Feature를 새로운 방식으로 결합&lt;/li&gt;
          &lt;li&gt;objective 조정&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;모델에 관심을 기울이면 좋은 결과가 나올 수 있음. Example에 공급되는 데이터를 조사해 새로운 지표 또는 잘못된 기존 지표를 찾을 수 있음&lt;/li&gt;
      &lt;li&gt;모델을 만들며 Feature 추가, 삭제, 재결합이 쉬어야 함&lt;/li&gt;
      &lt;li&gt;파이프라인의 사본을 만들고 정확성을 검증하기가 쉬울까?&lt;/li&gt;
      &lt;li&gt;둘 이상의 사본을 동시에 실행하는 방법은 어떻게 할까?&lt;/li&gt;
      &lt;li&gt;특정 Feature가 이번 파이프라인 버전에 포함될지 고민하지 말기. 다음 출시에 포함해도 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #17: 학습된(learned) feature이 아닌 직접 관찰하고 보고된 feature부터 시작하기
    &lt;ul&gt;
      &lt;li&gt;논란의 여지가 있는 주장이지만, 많은 함정을 피할 수 있음&lt;/li&gt;
      &lt;li&gt;우선 학습된 feature는 외부 시스템(예 : 비지도 클러스터링 시스템) 또는 학습 시스템 자체(예 : Factored model이나 딥러닝)에서 생성된 Feature
        &lt;ul&gt;
          &lt;li&gt;이런 Feature가 유용할 수 있지만 여러 문제점을 가질 수 있으므로 최초 모델에는 포함해서 안됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;외부 시스템을 사용해 Feature를 만드는 경우 외부 시스템엔 그 시스템의 목표가 있다는 것을 기억해야 함
        &lt;ul&gt;
          &lt;li&gt;그 외부 시스템의 목표와 나의 현재 목표와 상관이 낮을 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;외부 시스템에서 스냅샷을 가져오는 경우 최신 데이터가 아닐 수 있음&lt;/li&gt;
      &lt;li&gt;외부 시스템의 특성을 업데이트하는 경우 의미가 변질될 수 있음&lt;/li&gt;
      &lt;li&gt;따라서 외부 시스템을 사용해 Feature를 제공하는 방식을 사용하려면 매우 신중한 접근법이 필요함&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;역자 : 날씨나 공공 데이터 API를 받아서 학습하는 경우, 데이터 제공측에서 바꾸면.. 파이프라인이 망가지는데 그 예시와 비슷한 느낌&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;Factored model과 딥러닝 모델은 nonconvex(볼록하지 않다)는 성질이 있음
        &lt;ul&gt;
          &lt;li&gt;따라서 최적 해를 구하거나 근사할 수 있단 보장이 없고, 반복할 때마다 다른 local minima가 발견될 수 있음&lt;/li&gt;
          &lt;li&gt;이런 variation이 시스템 변경에 따르는 영향인지 무작위적인지 판단하기 어렵게 만듬&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;deep feature 없이 모델을 만들면 탁월한 baseline 성능을 얻을 수 있고, 이 기준이 확보된 이후 특이하고 복잡한 접근법을 시도하면 좋음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #18: 여러 Context로 일반화되는 컨텐츠의 feature 찾기
    &lt;ul&gt;
      &lt;li&gt;머신러닝 시스템은 더 거대한 시스템의 일부인 경우가 많음&lt;/li&gt;
      &lt;li&gt;예를 들어 HOT 소식에 올라갈만한 게시물은 HOT 소식에 올라가기 전에 많은 사람의 +1, 재공유, 댓글을 받음
        &lt;ul&gt;
          &lt;li&gt;학습 시스템에 이런 통계를 제공하면 최적화 컨텍스트와 관련해 어떤 데이터도 갖지 않는 새로운 게시물이 추천될 수 있음&lt;/li&gt;
          &lt;li&gt;유튜브의 다음 볼만한 동영상 기능에는 시청 횟수, 연계 시청 횟수를 사용할 수 있음&lt;/li&gt;
          &lt;li&gt;또한 명시적인 사용자 평가를 사용할 수도 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;마지막으로 label로 사용 중인 사용자 행동이 있다면 다른 컨텍스트의 자료에 대해 같은 행동을 파악해 좋은 feature를 생성할 수 있음&lt;/li&gt;
      &lt;li&gt;이런 모든 feature가 새로운 컨텐츠를 가져오도록 기여함&lt;/li&gt;
      &lt;li&gt;단, 개인화는 여기에 포함되지 않음. 이 컨텍스트에서 컨텐츠를 좋아하는 사람이 있는지 알아낸 후 누가 컨텐츠를 좋아하거나 싫어하는지 알아내는 방식으로 진행함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #19: 가능하면 매우 구체적인 Feature를 사용하기
    &lt;ul&gt;
      &lt;li&gt;소수의 복잡한 feature보다 다수의 단순한 feature를 학습하는 것이 더 간편함&lt;/li&gt;
      &lt;li&gt;검색 대상 문서의 id 및 규격화된 쿼리는 일반화에 크게 기여하지 못하지만, head query에서 순위와 label을 맞춰주는 역할을 함&lt;/li&gt;
      &lt;li&gt;따라서 feature 그룹에서 각 feature가 데이터의 매우 작은 부분에만 적용되더라도 전체 coverage가 90% 넘으면 걱정할 필요가 없음&lt;/li&gt;
      &lt;li&gt;정규화를 사용하면 작은 example에 적용되는 feature를 배제할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #20: 사람이 이해할 수 있는 방식으로 기존 feature를 결합하고 수정해 새로운 feature를 만들자
    &lt;ul&gt;
      &lt;li&gt;feature를 결합하고 수정하는 방법은 다양함. Tensorflow에선 Transformation을 이용해 데이터 전처리하는 방법을 제공함&lt;/li&gt;
      &lt;li&gt;가장 표준적인 방식은 이산화(discretization)와 교차(cross)임&lt;/li&gt;
      &lt;li&gt;Discretization : continuous feature를 불연속 feature로 만드는 것. 나이를 10세, 15세 보지 않고 10대, 20대 등으로 하는 것. 히스토그램의 경계를 너무 고민하지 않고 기본적인 분위 사용해도 효과를 얻을 수 있음&lt;/li&gt;
      &lt;li&gt;Cross : 둘 이상의 feature column을 결합. {남성, 여성} x {미국, 캐나다, 멕시코}의 특성으로 구성된 새로운 feature
        &lt;ul&gt;
          &lt;li&gt;매우 큰 feature column을 생성하는 교차는 오버피팅을 초래할 수 있음&lt;/li&gt;
          &lt;li&gt;예를 들어 검색 기능을 만들며 검색어 단어를 포함하는 feature와 문서의 단어를 포함하는 feature를 준비할 수 있음. 이걸 교차하면 매우 많음 feature가 생김(Rule #21 참고)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Text를 다룰 때 두가지 대안이 있음
        &lt;ul&gt;
          &lt;li&gt;가장 엄격한 방법은 내적을 구함&lt;/li&gt;
          &lt;li&gt;가장 단순한 내적은 검색어와 문서가 공통적으로 갖는 단어의 수를 세는 것
            &lt;ul&gt;
              &lt;li&gt;그 후 이 feature를 불연속화&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;내적을 구하는 다른 방식은 교집합을 구하는 것&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #21: 선형 모델에서 학습 가능한 feature weight의 수는 데이터 보유량에 대략적으로 비례함
    &lt;ul&gt;
      &lt;li&gt;모델의 적절한 복잡도에 관한 훌륭한 통계 이론은 많지만, 지금은 이 규칙만 명심하면 됨&lt;/li&gt;
      &lt;li&gt;Example이 1,000개에 불과한데 학습할 수 있는지 의심하는 사람들도 있고, 예시가 100만개 정도 있으면 특정 학습 방식에 고착되므로 그 이상 필요 없다고 생각하는 사람도 있음. 비결은 데이터 사이즈에 학습 규모를 맞추는 것
        &lt;ul&gt;
          &lt;li&gt;1) 검색 랭킹 시스템에서 문서와 쿼리에 수백만가지 단어가 있는데 라벨이 있는 example은 1000개뿐이라면 문서 특성과 쿼리 특성의 내적, TFIDF 및 인위적으로 추출된 feature를 사용해야 함. 1000개의 example에 대략 10개 정도의 feature가 생김&lt;/li&gt;
          &lt;li&gt;2) example이 100만개라면 정규화 및 feature selection을 사용해 문서와 쿼리의 교집함을 구함. 이를 통해 수백만 개의 feature가 나오지만 정규화를 통해 feature가 감소함. 1,000만개의 example에서 대략 10만개 정도의 feature가 생김&lt;/li&gt;
          &lt;li&gt;3) example이 수십억 또는 수천억 개라면 feature selection과 정규화를 사용해 feature column을 문서 및 쿼리 토큰을 cross할 수 있음. 10억 개의 example에 1,000만개의 feature가 생김&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;마지막에는 Rule #28에 따라 사용할 feature를 결정함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #22: 더 이상 사용되지 않는 feature를 정리하기
    &lt;ul&gt;
      &lt;li&gt;사용하지 않는 feature는 기술 부채가 됨
        &lt;ul&gt;
          &lt;li&gt;더 이상 사용되지 않고 다른 feature와 결합해도 유용하지 않다면 인프라에서 삭제하자&lt;/li&gt;
          &lt;li&gt;인프라를 깔끔하게 유지해야 가장 유망한 feature를 가장 빠르게 시험해볼 수 있음. feature가 다시 필요해지면 언제든지 다시 추가할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;추가하거나 유지할 feature를 결정할 땐 coverage를 고려하자. Feature가 얼마나 많은 example을 포괄하는지? 예를 들어 개인별 맞춤 feature가 있는데 사용자 중 이 feature를 사용하는 비율이 8%에 불과하면 높은 효율을 기대할 수 없음&lt;/li&gt;
      &lt;li&gt;어떤 Feature는 생각보다 큰 역할을 하기도 함. 예를 들어 데이터 중 1%만 포괄하는 feature가 있는데, 이 feature를 갖는 example 중 90%가 양성이라면 꼭 추가해야할 feature임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;인간에-의한-시스템-분석&quot;&gt;인간에 의한 시스템 분석&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;머신러닝의 세 번째 단계로 넘어가기 전에, 어떤 머신러닝 강의에서도 다뤄지지 않는 주제를 짚고 넘어가려고 함&lt;/li&gt;
  &lt;li&gt;바로 기준 모델을 어떻게 바라보고 개선할지에 관한 것&lt;/li&gt;
  &lt;li&gt;이것은 과학이라기보단 예술에 가깝지만, 바람직하지 않은 몇 가지 패턴을 피할 때 도움이 됨&lt;/li&gt;
  &lt;li&gt;Rule #23: 당신은 전형적인 최종 유저가 아니다
    &lt;ul&gt;
      &lt;li&gt;팀이 궁지에 몰리는 가장 쉬운 방법&lt;/li&gt;
      &lt;li&gt;fishfood(팀 내에서 프로토타입 사용) 및 dogfood(회사 내에서 프로토타입 사용)에는 많은 장점이 있지만, 직원들이 성능의 정확성에 대해 잘 살펴야 함&lt;/li&gt;
      &lt;li&gt;단점이 분명한 변경사항을 피하는 것도 중요하지만, 프러덕션 단계가 안정적이라고 판단할 요소를 철저히 테스트하는 것이 중요함&lt;/li&gt;
      &lt;li&gt;크라우드소싱 플랫폼에서 일반인을 대상으로 유료 설문조사를 진행하거나 실제 사용자를 대상으로 실험하는 방법이 있음&lt;/li&gt;
      &lt;li&gt;이렇게 하는 이유
        &lt;ul&gt;
          &lt;li&gt;1) 개발자는 코드부터 신경을 쓰기 마련. 특정 측면에만 주목하거나 지나치게 감정이 개입되어 확증 편향이 휩쓸릴 수 있음&lt;/li&gt;
          &lt;li&gt;2) 개발자의 시간은 소중합니다. 엔지니어 9명이 1시간 동안 회의하는데 사용되는 비용과 크라우드소싱 플랫폼에서 유료 설문조사를 진행해 얻을 수 있는 라벨 수를 비교해보자&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;사용자 의견이 꼭 필요하다면, 사용자 경험 방법론(uesr experience methodologies)을 사용해보자. 프로세스 초기에 사용자 페르소나를 만들고 이후에 사용성 테스트를 진행하자
        &lt;ul&gt;
          &lt;li&gt;사용자 페르소나는 가상적인 사용자를 의미함. 예를 들어 팀원이 모두 남성이면 35세 여성 사용자 페르소나를 만들어보자. 또한 사용성 테스트를 진행해 실제 사용자 반응을 조사하면 새로운 관점을 접할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #24: 모델 사이의 delta를 측정하자
    &lt;ul&gt;
      &lt;li&gt;유저가 새 모델을 접하기 전에 측정할 수 있는 가장 쉽고 유용한 항목으로 새로운 모델이 프러덕션의 기존 결과와 얼마나 다른지 계산하는 것을 뜻함&lt;/li&gt;
      &lt;li&gt;예를 들어 ranking 문제에서 동일한 쿼리 샘플을 두 모델에 실행한 후 결과의 symmetric 차이 크기에 순위별 가중치를 적용해 살펴볼 수 있음
        &lt;ul&gt;
          &lt;li&gt;차이가 매우 작다면 별도의 실험을 거치지 않아도 변화가 거의 없을 것을 짐작할 수 있음&lt;/li&gt;
          &lt;li&gt;차이가 매우 크다면 긍정적인 변화임을 확신할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;symmetric 차가 크게 나온 쿼리를 살펴보면 변화의 본질적인 측면을 이해할 때 도움이 됨&lt;/li&gt;
      &lt;li&gt;그러나 중요한 것은 시스템의 안정성임. 모델 자체를 비교할 때(이상적으로 0) 대칭 차이가 낮은지 확인하자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #25: 모델을 선택할 땐 예측 파워보다 실용적인 성능을 우선시하자
    &lt;ul&gt;
      &lt;li&gt;모델에서 클릭률을 예측하려고 한다. 그러나 결국 중요한 질문은 그 예측으로 무엇을 할지?임
        &lt;ul&gt;
          &lt;li&gt;문서의 순위를 결정할 때 활용할 생각이라면 예측 자체보다 최종적인 순위의 품질이 더 중요함&lt;/li&gt;
          &lt;li&gt;문서가 스팸일 확률을 예측해 차단 기중늘 정할 계획이라면 허용할 대상의 정확성이 가장 중요함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;대부분 이런 두 관점의 조화를 이루지만, 그렇지 않다면 소탐대실의 상황이 될 수 있음&lt;/li&gt;
      &lt;li&gt;따라서 어떤 변화가 log loss는 개선하지만 시스템의 성능을 떨어트린다면 다른 feature를 사용해야 함. 이런 상황이 자주 나타나기 시작하면 모델의 objective를 재검토해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #26: 측정된 오차에서 패턴을 찾아 새 feature 만들기
    &lt;ul&gt;
      &lt;li&gt;모델에서 잘못 예측한 training example을 발견했다고 가정
        &lt;ul&gt;
          &lt;li&gt;분류 작업의 경우 false positive나 false negative가 여기에 해당함&lt;/li&gt;
          &lt;li&gt;Ranking task에선 positive와 negative로 이루어진 쌍에서 positive가 negative보다 순위가 낮게 매겨진 경우일 수 있음&lt;/li&gt;
          &lt;li&gt;중요한 점은 해당 예시는 머신러닝 시스템에서 예측이 잘못된 것을 스스로 알고 있으므로 기회가 있으면 수정이 가능하다는 점&lt;/li&gt;
          &lt;li&gt;오류를 수정할 수 있는 feature를 모델에 제공하면 모델은 이 feature를 사용하려고 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;반면 시스템에서 실수를 깨닫지 못한 example을 사용한 feature는 무시됨
        &lt;ul&gt;
          &lt;li&gt;예를 들어 Play 앱 검색에서 사용자가 무료 게임을 검색했는데 최상위 결과 중 하나에 관련성이 떨어지는 개그 앱이 포함되었음. 따라서 개그 앱에 관한 특성을 만들었음&lt;/li&gt;
          &lt;li&gt;설치 횟수를 극대화하는 것이 목표인 경우 무료 게임을 검색하는 사용자들이 개그 앱을 많이 설치한다면 개그 앱 feature는 의도한 효과를 낼 수 없음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;모델에서 잘못 예측한 example을 확보했으면 현재 feature set을 벗어나는 추세를 찾자
        &lt;ul&gt;
          &lt;li&gt;예를 들어 시스템에서 긴 게시물의 순위를 낮추는 경향이 발견되면 게시물 길이를 추가하자. 추가할 feature를 너무 구체적으로 고민하지 말자. 단순히 10개의 feature를 추가한 후 모델이 알아서 판단하도록 놔두자(Rule 21 참조) 이 방식이 원하는 효과를 얻는 가장 쉬운 방법임&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #27: 부적절한 동작이 관찰되면 정량화를 시도하자
    &lt;ul&gt;
      &lt;li&gt;시스템에 바람직하지 않은 속성이 있는데 기존 loss 함수로는 포착되지 않아서 이슈가 되는 경우가 있음&lt;/li&gt;
      &lt;li&gt;이러한 경우 무슨 수를 써서라도 불만족스러운 포인트를 구체적인 숫자로 바꿔야함
        &lt;ul&gt;
          &lt;li&gt;예를 들어 Play 검색에 ‘개그 앱’이 너무 많이 표시된다고 생각되면 평가 전문가에게 개그 앱을 판별하도록 의뢰할 수 있음&lt;/li&gt;
          &lt;li&gt;이 경우 사람이 라벨링한 데이터를 사용해도 무리가 없음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;이렇게 측정 가능한 문제라면 이제 feature, objective, metric으로 사용할 수 있음&lt;/li&gt;
      &lt;li&gt;일반적인 규칙은 우선 측정하고 최적화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #28: 단기적인 동작이 같더라도 장기적인 동작은 다를 수 있음
    &lt;ul&gt;
      &lt;li&gt;모든 doc_id와 exact_query를 조사해 모든 문서, 모든 쿼리에 관한 클릭 확률을 계산하는 시스템을 새로 구축했다고 가정&lt;/li&gt;
      &lt;li&gt;현재 시스템보다 단순하고 AB 테스트 결과가 현재 시스템과 거의 일치하는 것으로 나타나서 출시를 결정함&lt;/li&gt;
      &lt;li&gt;그런데 새 앱이 표시되지 않는 문제를 발견
        &lt;ul&gt;
          &lt;li&gt;왜 그럴까?&lt;/li&gt;
          &lt;li&gt;이 시스템은 자체 기록을 기반으로 해당 쿼리에 관한 문서만을 보여주므로 새 문서를 표시해야 한다는 사실을 학습할 방법이 없음&lt;/li&gt;
          &lt;li&gt;이런 시스템이 장기적으로 어떻게 작동할지 알아내는 유일한 방법은 모델이 실제로 운영될 때 획득한 데이터로만 학습하는 것인데, 이는 매우 어려운 일임&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;training-serving-skew&quot;&gt;Training-Serving Skew&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Training-Serving Skew란 Train 성능과 Serving 성능 간의 차이&lt;/li&gt;
  &lt;li&gt;차이가 나타나는 이유
    &lt;ul&gt;
      &lt;li&gt;Train 파이프라인과 Serving 파이프라인에서 데이터를 처리하는 방법의 차이&lt;/li&gt;
      &lt;li&gt;학습시 데이터와 제공 시 데이터 간의 변화&lt;/li&gt;
      &lt;li&gt;모델과 알고리즘 간의 피드백 루프&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Google의 프로덕션 머신러닝 시스템에도 Training-Serving Skew로 인해 성능이 저하된 경우가 있었음&lt;/li&gt;
  &lt;li&gt;가장 좋은 해법은 시스템과 데이터의 변화로 인해 예기치 않은 격차가 생기지 않도록 직접 모니터링하는 것&lt;/li&gt;
  &lt;li&gt;Rule #29: Training 환경을 Serving 환경과 일치시키는 최고의 방법은 Serving할 때 사용된 feature set을 저장하고 그 데이터를 기반으로 Training시 사용하는 것
    &lt;ul&gt;
      &lt;li&gt;모든 example에 대해서 불가능하다면 일부 example에 대해서라도 실천하여 서빙과 학습의 일관성을 검증할 방법을 강구해야 함(Rule #37 참조)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;역자 : Serving은 보통 실시간 데이터로 적재가 되고 Training 셋은 ETL 파이프라인으로 실시간 데이터가 아닐 수 있음. 이럴 경우 Serving용 실시간 데이터를 바로 적재해 한번에 쓰자는 이야기&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;Google의 여러 팀에서 이런 측정을 통해 의외의 결과를 얻은 적 있음&lt;/li&gt;
      &lt;li&gt;YouTube 홈페이지는 Serving시 특성 로그 기록을 도입하여 품질을 크게 높이고 코드의 복잡성을 낮추었으며, 지금 이 순간에도 여러 팀에서 인프라를 전환하고 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #30: 표본 추출된 데이터를 임의로 무시하지 말고 중요도에 따라 가중치를 매기기
    &lt;ul&gt;
      &lt;li&gt;데이터가 너무 많으면 파일 1~12만 사용하고, 나머지 파일 13~99는 무시하고 싶을 수도 있음&lt;/li&gt;
      &lt;li&gt;하지만 잘못된 생각&lt;/li&gt;
      &lt;li&gt;사용자에게 한 번도 표시되지 않은 데이터는 삭제해도 무방하지만, 나머지 데이터에는 중요도 가중치를 적용하는 것이 가장 좋음&lt;/li&gt;
      &lt;li&gt;중요도 가중치(importance weight)란 예시 X를 샘플링할 확률이 30%라면 10/3의 가중치를 준다는 의미&lt;/li&gt;
      &lt;li&gt;중요도 가중치를 사용하는 경우에도 규칙 #14에서 설명한 calibration 속성이 모두 적용됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #31: Training 및 Serving시 (DB) 테이블 데이터를 조인하는 경우 테이블 데이터는 달라질 수 있음을 명심하자
    &lt;ul&gt;
      &lt;li&gt;문서 ID를 해당 문서의 댓글수 또는 클릭수 등의 특성을 담은 테이블과 조인한다고 가정&lt;/li&gt;
      &lt;li&gt;학습 시점과 서빙 시점 사이에 테이블의 특성이 달라질 수 있음&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;역자 : 특히 시계열성 데이터에서 많이 실수함(Lag 변수)&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;이런 경우 학습과 서빙 간에 같은 문서에 관한 모델의 예측이 서로 달라짐&lt;/li&gt;
      &lt;li&gt;이런 문제를 피하는 가장 쉬운 방법은 서빙 시에 특성을 기록하는 것(Rule #32 참조)&lt;/li&gt;
      &lt;li&gt;테이블의 변화가 비교적 느리다면 1시간 또는 하루마다 테이블의 스냅샷을 만들어 적당히 근접한 데이터를 얻을 수 있음&lt;/li&gt;
      &lt;li&gt;그러나 문제가 완벽하게 해결되는 것은 아님&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #32: 가능하면 학습 파이프라인과 서빙 파이프라인 간에 코드를 재사용하자
    &lt;ul&gt;
      &lt;li&gt;Batch 처리는 Online 처리와 다름&lt;/li&gt;
      &lt;li&gt;온라인 처리는 도착하는 각 요청을 실시간으로 처리해야 하므로 각 쿼리에 대해 별도의 조회를 수행하는 반면, 배치 처리에서는 여러 작업을 조인 등의 방법으로 결합할 수 있음&lt;/li&gt;
      &lt;li&gt;서빙 시에는 온라인 처리를 수행하는 반면, 학습은 일괄 처리 작업&lt;/li&gt;
      &lt;li&gt;그러나 코드를 재사용할 수 있는 방법이 몇 가지 있음
        &lt;ul&gt;
          &lt;li&gt;예를 들어 모든 쿼리 또는 조인의 결과를 사람이 읽을 수 있는 방식으로 저장하면 오류를 쉽게 테스트할 수 있음&lt;/li&gt;
          &lt;li&gt;그런 다음 모든 정보가 수집되었으면 서빙 또는 학습 중에 공통 메소드를 실행하여 사람이 읽을 수 있는 객체와 머신러닝 시스템에 사용되는 형식을 연결하자&lt;/li&gt;
          &lt;li&gt;이렇게 하면 학습-서빙 격차가 근본적으로 방지됨&lt;/li&gt;
          &lt;li&gt;이렇게 하려면 우선 학습 코드와 서빙 코드에 동일한 프로그래밍 언어를 사용해야 합니다&lt;/li&gt;
          &lt;li&gt;그렇지 않으면 코드를 공유하기가 거의 불가능함&lt;/li&gt;
        &lt;/ul&gt;

        &lt;blockquote&gt;
          &lt;p&gt;역자 : 우버는 Spark로 Training / Serving을 모두 통합함&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #33: 1월 5일까지 수집된 데이터를 기준으로 모델을 생성하는 경우 1월 6일 이후의 데이터로 모델을 테스트하자
    &lt;ul&gt;
      &lt;li&gt;일반적인 규칙은 모델 학습에 사용된 데이터보다 이후에 수집된 데이터로 모델의 성능을 측정하는 것&lt;/li&gt;
      &lt;li&gt;이렇게 하면 시스템의 프로덕션 성능을 더 정확히 예상할 수 있음&lt;/li&gt;
      &lt;li&gt;1월 5일까지 수집된 데이터를 기준으로 모델을 생성하는 경우 1월 6일 이후의 데이터로 모델을 테스트하자&lt;/li&gt;
      &lt;li&gt;새 데이터에 관한 성능은 기존 데이터보다 다소 저하되는 것이 정상이지만 크게 나빠져서는 안됨&lt;/li&gt;
      &lt;li&gt;우연히 daily로 변동이 생길 수 있으므로 평균적인 클릭률 또는 전환율이 변경되지 않을 수 있지만, 양성 예시가 음성 예시보다 1점 높게 나올 가능성을 나타내는 AUC는 합리적인 유사도를 보여야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #34: 스팸 감지, 관심 이메일 판단 등 필터링을 위한 이진 분류에서는 단기적으로 다소의 성능 저하를 감수하더라도 데이터를 철저히 정제하자
    &lt;ul&gt;
      &lt;li&gt;필터링 작업에서는 음성으로 판정된 예시를 사용자로부터 숨긴다
        &lt;ul&gt;
          &lt;li&gt;서빙 시 음성 예시의 75%를 차단하는 필터가 있다고 가정하자&lt;/li&gt;
          &lt;li&gt;사용자에게 표시된 instance로 추가적인 학습 데이터를 추출하려는 생각을 할 수 있음&lt;/li&gt;
          &lt;li&gt;예를 들어 필터를 통과했지만 사용자가 스팸으로 신고한 이메일은 학습 데이터로 활용할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;그러나 이 방식은 샘플링 편향을 유발함
        &lt;ul&gt;
          &lt;li&gt;더 정제된 데이터를 얻는 방법은 서빙 시 전체 트래픽 중 1%를 ‘홀드아웃’으로 라벨링하고 모든 홀드아웃 예시를 사용자에게 보내는 것&lt;/li&gt;
          &lt;li&gt;이제 필터는 음성 예시 중에서 최소 74%를 차단함&lt;/li&gt;
          &lt;li&gt;이러한 홀드아웃 예시는 학습 데이터가 될 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;필터가 음성 예시의 95% 이상을 차단한다면 이 접근법은 현실성이 낮음&lt;/li&gt;
      &lt;li&gt;그렇더라도 서빙 성능을 측정하려는 경우 소량의 샘플(0.1% 또는 0.001%)을 추출할 수 있음&lt;/li&gt;
      &lt;li&gt;1만 개 정도의 예시가 있으면 성능을 비교적 정확히 추정할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #35: Ranking 문제에선 특유의 왜곡이 나타날 수 있음
    &lt;ul&gt;
      &lt;li&gt;표시되는 결과가 바뀔 정도로 ranking 알고리즘을 급격히 변경하면 알고리즘에서 이후에 접하게 될 데이터 자체가 변화함&lt;/li&gt;
      &lt;li&gt;이러한 유형의 왜곡이 나타날 것을 대비하여 모델을 설계해야 함&lt;/li&gt;
      &lt;li&gt;여기에는 여러 가지 접근법이 있으며, 공통점은 모델에서 기존에 접한 데이터를 우선시함&lt;/li&gt;
      &lt;li&gt;1) 쿼리 하나에만 해당하는 특성 보다 여러 쿼리를 포괄하는 특성에 더 높은 정규화를 적용
        &lt;ul&gt;
          &lt;li&gt;이렇게 하면 모델에서 모든 쿼리로 일반화되는 특성보다 하나 또는 소수의 쿼리에 국한되는 특성이 우선시됨&lt;/li&gt;
          &lt;li&gt;이 방식은 자주 나타나는 결과가 이와 무관한 쿼리에까지 영향을 주지 않도록 차단할 때 도움이 됨&lt;/li&gt;
          &lt;li&gt;unique 값이 많은 feature에 더 높은 정규화를 적용하라는 기존의 권장사항과는 정반대임&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) featue에 positive weight만 허용
        &lt;ul&gt;
          &lt;li&gt;따라서 양호한 모든 특성이 ‘미지의’ 특성보다 우선시됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;3) 문서에만 국한된 feature를 배제
        &lt;ul&gt;
          &lt;li&gt;이는 #1의 극단적인 경우&lt;/li&gt;
          &lt;li&gt;예를 들어 특정 앱이 쿼리와 무관하게 많은 다운로드를 기록했더라도 무조건 항상 표시할 수는 없음&lt;/li&gt;
          &lt;li&gt;문서에만 국한된 특성을 배제하면 문제가 단순해짐&lt;/li&gt;
          &lt;li&gt;특정한 인기 앱을 무조건 표시하지 않으려는 이유는 모든 추천 앱을 골고루 제공하는 것이 중요하기 때문
            &lt;ul&gt;
              &lt;li&gt;예를 들어 ‘조류 관찰 앱’을 검색한 사용자가 ‘앵그리 버드’를 다운로드할 수는 있지만 기존 의도에 분명히 어긋난 결과&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;이러한 앱을 표시하면 다운로드율은 올라가지만 사용자의 궁극적인 요구사항이 해결되지는 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #36: positional feature를 사용해 피드백 루프를 방지하자
    &lt;ul&gt;
      &lt;li&gt;콘텐츠의 위치는 사용자와 상호작용에 막대한 영향을 줌&lt;/li&gt;
      &lt;li&gt;앱을 1번 위치에 표시하면 실제로 클릭수가 올라가며, 앞으로도 그러할 것으로 확신할 수 있음&lt;/li&gt;
      &lt;li&gt;이 문제를 다루는 방법 중 하나는 positional feature, 즉 페이지에서 콘텐츠가 차지하는 위치에 관한 특성을 추가하는 것
        &lt;ul&gt;
          &lt;li&gt;모델 학습에 위치 특성을 사용하면 ‘1st­position’과 같은 특성에 높은 가중치를 부여하도록 모델이 학습됨&lt;/li&gt;
          &lt;li&gt;따라서 ‘1st­position=true’를 갖는 예시에서 다른 요소에 적은 가중치가 부여됨&lt;/li&gt;
          &lt;li&gt;Serving 시에는 후보의 점수를 매긴 후에 표시 순서를 결정하게 되므로 모든 인스턴스에 위치 특성을 지정하지 않거나 동일한 기본 특성을 지정함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;위치 특성은 이와 같이 Training과 Testing 간에 비대칭성을 가지므로 모델의 나머지 부분과 별도로 유지하는 것이 중요함&lt;/li&gt;
      &lt;li&gt;모델을 positional feature의 함수와 나머지 특성의 함수를 더한 합으로 만드는 것이 가장 좋음(앙상블)&lt;/li&gt;
      &lt;li&gt;예를 들어 위치 특성과 문서 특성을 교차해선 안됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #37: Training/Serinvg Skew를 측정하자
    &lt;ul&gt;
      &lt;li&gt;격차가 발생할 수 있는 원인은 보통 몇 가지로 정리되며, 다음과 같이 나눌 수 있음
        &lt;ul&gt;
          &lt;li&gt;학습 데이터와 홀드아웃 데이터의 성능 차이
            &lt;ul&gt;
              &lt;li&gt;일반적으로 이 차이는 불가피하며 반드시 나쁜 것은 아님&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;홀드아웃 데이터와 ‘다음날’ 데이터 간의 성능 차이
            &lt;ul&gt;
              &lt;li&gt;이 차이도 불가피함&lt;/li&gt;
              &lt;li&gt;다음날 성능을 극대화하는 방향으로 정규화를 조정해야 함&lt;/li&gt;
              &lt;li&gt;홀드아웃 데이터와 다음날 데이터 간에 상당한 격차가 있다면 일부 feature에 시간 민감성이 있어 모델의 성능을 저하한다는 증거일 수 있음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;‘다음날’ 데이터와 실시간 데이터 간의 성능 차이
            &lt;ul&gt;
              &lt;li&gt;학습 데이터의 example에 모델을 적용할 때와 serving시 동일한 example에 모델을 적용할 때 완전히 같은 결과가 나와야 함(Rule #5 참조)&lt;/li&gt;
              &lt;li&gt;따라서 이 차이는 엔지니어링 오류를 시사할 가능성이 높음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4부-ml-3단계-slowed-growth-optimization-refinement-and-complex-models&quot;&gt;4부. ML 3단계: Slowed Growth, Optimization Refinement, and Complex Models&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;2단계가 마무리되고 있음을 나타내는 구체적인 징후
    &lt;ul&gt;
      &lt;li&gt;가장 먼저, 월별 개선 폭이 둔화하기 시작&lt;/li&gt;
      &lt;li&gt;측정항목 간에 절충 관계가 나타나기 시작
        &lt;ul&gt;
          &lt;li&gt;즉, 몇몇 실험에서 상승하는 측정항목과 하락하는 측정항목이 동시에 나타남&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;여기서부터 문제가 복잡해짐&lt;/li&gt;
      &lt;li&gt;개선을 이루기가 어려워졌기 때문에 머신러닝 시스템을 정교화해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 섹션에는 이전 섹션보다 다소 비현실적인 규칙이 포함될 수 있으므로 주의!&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;머신러닝 1단계와 2단계는 일사천리로 진행할 수 있지만 3단계부터는 스스로 길을 찾아 나가야 함&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #38: unaligned된 objective가 문제가 된다면 새로운 Feature에 시간 낭비하지 말자
    &lt;ul&gt;
      &lt;li&gt;Metric 개선이 한계에 다다르면 현재 머신러닝 시스템의 목표에서 벗어난 문제점을 찾기 시작할 때&lt;/li&gt;
      &lt;li&gt;앞에서도 설명했듯, 기존의 알고리즘 목표로는 제품의 목표를 해결할 수 없다면 알고리즘 목표와 제품 목표 중 하나를 변경해야함&lt;/li&gt;
      &lt;li&gt;예를 들어 클릭수, +1 또는 다운로드 횟수를 최적화할 수 있지만 출시 결정을 내릴 때는 인간 평가자의 의견도 참고할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #39: 출시 결정은 제품의 장기적인 목표를 반영해야함
    &lt;ul&gt;
      &lt;li&gt;설치 횟수 예측의 logistic loss를 줄일 수 있는 아이디어를 생각했다
        &lt;ul&gt;
          &lt;li&gt;해당 feature를 추가했더니 로지스틱 손실이 감소했다&lt;/li&gt;
          &lt;li&gt;실시간 실험 결과 설치율 상승이 관찰됨&lt;/li&gt;
          &lt;li&gt;그런데 출시 검토 회의에서 일일 활성 사용자 수가 5% 하락했다는 지적이 나옴&lt;/li&gt;
          &lt;li&gt;따라서 모델을 출시하지 않기로 결정&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;실망스러운 결과지만 출시 결정에는 여러 가지 기준이 작용하며 ML을 통해 최적화할 수 있는 것은 그중 일부에 불과하다는 점을 알게 됨&lt;/li&gt;
      &lt;li&gt;현실 세상은 게임과 달라서, 제품의 상태를 일률적으로 판단할 수 있는 ‘체력 수치’ 같은 개념이 없음
        &lt;ul&gt;
          &lt;li&gt;팀에서는 수집 가능한 통계를 총 동원하여 시스템의 미래 성능을 효과적으로 예측하기 위해 노력해야함&lt;/li&gt;
          &lt;li&gt;Engagement, 1일 활성 사용자(DAU), 30일 DAU, 광고주의 투자수익 등을 고려해야 함&lt;/li&gt;
          &lt;li&gt;이런 metric은 AB 테스트로 측정할 수 있지만 사용자 만족도, 사용자 수 증가, 파트너 만족도, 수익 등의 더욱 장기적인 목표를 대변하는 역할을 함&lt;/li&gt;
          &lt;li&gt;제품의 유용성과 품질 향상 및 5년 후의 회사 발전과 같은 목표에 대해서도 이를 대변하는 metric을 생각할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;출시 결정을 내리기 쉬운 유일한 경우는 모든 측정항목이 개선되거나 적어도 악화되지 않을 때&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;팀에서 정교한 머신러닝 알고리즘과 단순한 휴리스틱 사이에서 선택할 수 있으며 단순한 휴리스틱이 모든 측정항목에서 더 나은 결과를 보인다면 휴리스틱을 선택해야함&lt;/li&gt;
          &lt;li&gt;또한 가능한 모든 metric 값 사이에 명백하게 우열이 가려지지도 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;구체적으로 다음과 같은 두 가지 시나리오를 살펴보자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;실험&lt;/th&gt;
      &lt;th&gt;DAU&lt;/th&gt;
      &lt;th&gt;Revenue/Day&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;1 million&lt;/td&gt;
      &lt;td&gt;$4 million&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;B&lt;/td&gt;
      &lt;td&gt;2 million&lt;/td&gt;
      &lt;td&gt;$2 million&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;현재 시스템이 A라면 B로 전환할 가능성은 낮음
    &lt;ul&gt;
      &lt;li&gt;현재 시스템이 B라면 A로 전환할 가능성은 낮음&lt;/li&gt;
      &lt;li&gt;이러한 상황은 모순적으로 보이지만, 측정항목에 관한 예측은 적중한다는 보장이 없으므로 어떠한 변화에도 상당한 위험이 뒤따름&lt;/li&gt;
      &lt;li&gt;두 metric 모두 팀에서 우려하는 위험을 수반함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;뿐만 아니라 어떠한 측정항목도 팀의 궁극적인 관심사인 ‘지금부터 5년 후에 제품이 어떠한 위치에 있을까?’라는 의문을 해결해 주지 못함&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;사람들은 자신이 직접 최적화할 수 있는 측정항목 하나를 중시하는 경향이 있음&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;대부분의 머신러닝 도구는 이러한 환경에 적합함&lt;/li&gt;
      &lt;li&gt;이러한 환경에서 새로운 feature를 개발하는 엔지니어가 끊임없이 계속되는 출시에 대응해야함&lt;/li&gt;
      &lt;li&gt;머신러닝 유형 중 이 문제를 다루기 시작하는 유형이 multi-objective learning임
        &lt;ul&gt;
          &lt;li&gt;예를 들어 각 측정항목에 관한 하한선을 갖는 제약조건 충족 문제를 작성하고 측정항목의 특정한 선형 조합을 최적화&lt;/li&gt;
          &lt;li&gt;그러나 이렇게 하더라도 모든 측정항목을 머신러닝 목표로 손쉽게 규격화할 수 있는 것은 아님&lt;/li&gt;
          &lt;li&gt;문서가 클릭되거나 앱이 설치되는 이유는 콘텐츠가 표시되었기 때문&lt;/li&gt;
          &lt;li&gt;그러나 사용자가 사이트를 방문한 계기를 알아내기는 훨씬 어려움&lt;/li&gt;
          &lt;li&gt;사이트의 미래 실적을 전반적으로 예측하는 문제는 AI-Complete 문제로 컴퓨터 시각인식 또는 자연어 처리만큼이나 어려움&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #40: 앙상블을 단순하게 유지하기
    &lt;ul&gt;
      &lt;li&gt;Raw feature를 사용해 컨텐츠의 순위를 바로 결정하는 통합 모델은 디버깅 및 파악이 가장 쉬운 모델임
        &lt;ul&gt;
          &lt;li&gt;그러나 모델의 앙상블(다른 모델의 점수를 종합하여 만든 단일 ‘모델’)은 더 우수한 성능을 발휘할 수 있음&lt;/li&gt;
          &lt;li&gt;단순성을 유지하려면 각 모델은 다른 모델의 입력만을 취하는 앙상블이거나 여러 특성을 취하는 기본 모델이어야 하며, 두 가지 입력을 모두 취해서는 안 됨&lt;/li&gt;
          &lt;li&gt;별도로 학습되는 다른 모델을 기반으로 하는 여러 모델이 있는 경우 이러한 모델을 결합하면 부적합한 동작이 나타날 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;앙상블에는 ‘기본’ 모델의 출력만을 입력으로 취하는 단순 모델을 사용하자
        &lt;ul&gt;
          &lt;li&gt;그리고 앙상블 모델의 속성을 직접 규정할 필요가 있음&lt;/li&gt;
          &lt;li&gt;예를 들어 기본 모델이 산출하는 점수가 상승하는 경우 앙상블의 점수가 하락해서는 안됨&lt;/li&gt;
          &lt;li&gt;또한 가급적이면 입력 모델이 semantically적으로으로 해석 가능하도록 보정 등의 작업을 거쳐야함&lt;/li&gt;
          &lt;li&gt;그래야 underlying(기반) 모델의 변화가 앙상블 모델에 혼선을 주지 않음&lt;/li&gt;
          &lt;li&gt;또한 underlying(기반) 분류자가 예측한 확률이 상승할 때 앙상블이 예측한 확률이 하락하지 않도록 강제해야함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #41: 성능 개선이 한계에 다다르면 기존 신호를 다듬기보다는 본질적으로 새로운 정보를 추가하자
    &lt;ul&gt;
      &lt;li&gt;사용자의 인구통계 정보를 추가함
        &lt;ul&gt;
          &lt;li&gt;문서에 포함된 단어에 관한 정보도 추가함&lt;/li&gt;
          &lt;li&gt;템플릿 탐색을 수행하여 정규화를 조정함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;그런데 핵심 측정항목이 1% 이상 개선된 출시가 몇 분기 동안 단 한 번도 없었습니다. 이제 어떻게 해야 할까요?&lt;/li&gt;
      &lt;li&gt;이제 완전히 다른 feature를 위한 인프라 구축을 시작할 때
        &lt;ul&gt;
          &lt;li&gt;예를 들면 사용자가 어제, 지난주, 작년에 액세스한 문서 내역, 다른 출처에서 가져온 데이터 등&lt;/li&gt;
          &lt;li&gt;위키데이터 항목 또는 사내 보유 데이터(예: Google의 지식 정보)를 사용하자&lt;/li&gt;
          &lt;li&gt;딥러닝을 활용하자&lt;/li&gt;
          &lt;li&gt;ROI를 조정하고 새로운 feature를 위한 업무량을 늘려야함&lt;/li&gt;
          &lt;li&gt;다른 엔지니어링 프로젝트와 마찬가지로, 새 feature를 추가하는 데 따르는 편익과 복잡성이 올라가는 데 따르는 비용을 저울질해야함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #42: Diversity, Personalization, Relevance는 polularity와 상관관계가 의외로 낮을 수 있음
    &lt;ul&gt;
      &lt;li&gt;컨텐츠 집합의 Diversity은 여러 가지 의미를 가질 수 있는데, 가장 흔한 것은 컨텐츠 출처의 다양성을 의미함
        &lt;ul&gt;
          &lt;li&gt;Personalization란 각 사용자에게 자신만의 결과를 제공하는 것&lt;/li&gt;
          &lt;li&gt;Relevance이란 특정 쿼리의 결과가 다른 어떠한 결과보다도 해당 쿼리에 적합하다는 의미&lt;/li&gt;
          &lt;li&gt;따라서 이러한 세 가지 속성은 특별한 속성으로 규정됨&lt;/li&gt;
          &lt;li&gt;그러나 평범함이 최선인 경우도 많다는 것이 문제&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;시스템에서 클릭수, 사용 시간, 시청 횟수, +1, 재공유 등을 측정한다면 결과적으로 컨텐츠의 인기도를 측정하는 것&lt;/li&gt;
      &lt;li&gt;어떤 팀에선 다양성을 갖춘 개인별 모델을 학습시키려고 함
        &lt;ul&gt;
          &lt;li&gt;이를 위해 시스템의 personalize(사용자의 관심사를 나타내는 특성) 또는 diversify(이 문서가 다른 반환 문서와 저자, 콘텐츠 등의 특성을 공통적으로 갖는지를 나타내는 특성)에 기여하는 특성을 추가하지만, 가중치가 생각보다 낮거나 부호가 반대라는 사실을 알게됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Diversity, Personalize, Relevance가 중요하지 않다는 의미는 아님
        &lt;ul&gt;
          &lt;li&gt;이전 규칙에서 설명했듯이 후처리를 통해 Diversity 또는 Relevance을 강화할 수 있음&lt;/li&gt;
          &lt;li&gt;더 장기적인 목표가 개선되는 것으로 나타난다면 popularity와 별개로 Diversity/Relevance이 중요하다고 판단할 수 있음&lt;/li&gt;
          &lt;li&gt;후처리를 계속 사용할 수도 있고, Diversity 또는 Relevance 기준으로 목표를 직접 수정할 수도 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rule #43: 당신의 친구들은 다른 제품에 같은 경향이 있지만 당신의 관심사는 그렇지 않은 경향이 있음(해석이 어려워서 원문을 남깁니다 : Your friends tend to be the same across different products. Your interests tend not to be)
    &lt;ul&gt;
      &lt;li&gt;Google의 여러 팀에서는 한 제품에서 관계의 긴밀함을 예측하는 모델을 취하여 다른 제품에 성공적으로 적용함으로써 큰 성과를 거둠&lt;/li&gt;
      &lt;li&gt;반면, 여러 제품 분야를 넘나드는 맞춤화 특성으로 인해 고생하는 팀도 있음
        &lt;ul&gt;
          &lt;li&gt;이론적으로는 성공해야 할 것 같은데, 실제로는 잘 되지 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;한 부문의 원시 데이터를 사용하여 다른 부문의 사용자 행동을 예측하는 방법은 성공을 거두기도 함&lt;/li&gt;
      &lt;li&gt;또한 사용자가 다른 부문에서 활동한 적이 있다는 사실만 알아도 도움이 될 수 있음&lt;/li&gt;
      &lt;li&gt;예를 들어 사용자가 두 제품을 사용했다는 사실 자체가 큰 의미를 가질 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.google.com/machine-learning/guides/rules-of-ml&quot;&gt;Rules of Machine Learning:
Best Practices for ML Engineering&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 15 Dec 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/2019/12/15/rules-of-ml/</link>
        <guid isPermaLink="true">http://localhost:4000/data/2019/12/15/rules-of-ml/</guid>
        
        <category>ml</category>
        
        
        <category>data</category>
        
      </item>
    
      <item>
        <title>CS224W - Machine Learning with Graphs 1강 정리</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Stanford CS224W : Machine Learning with Graphs 1강을 듣고 정리한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;cs224w--machine-learning-with-graphs&quot;&gt;CS224W : Machine Learning with Graphs&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;예전 강의에선 Analytics, Social Network, Analytics graph에 집중했으나, 최근엔 ML에 집중&lt;/li&gt;
  &lt;li&gt;Why Networks?
    &lt;ul&gt;
      &lt;li&gt;네트워크는 상호 작용하는 엔티티의 복잡한 시스템을 설명하기 위한 일반적인 언어임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Two Types of Networks/Graphs
    &lt;ul&gt;
      &lt;li&gt;Network(Natural Graphs)
        &lt;ul&gt;
          &lt;li&gt;사회는 70억개 이상의 개인의 모음&lt;/li&gt;
          &lt;li&gt;전자 장치를 연결하는 통신 시스템&lt;/li&gt;
          &lt;li&gt;유전자, 단백질의 상호 작용으로 생명 조절&lt;/li&gt;
          &lt;li&gt;우리의 생각은 뇌의 수십억 개의 뉴런으로 이루어짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Information Graphs
        &lt;ul&gt;
          &lt;li&gt;정보, 지식이 구성되고 연결됨&lt;/li&gt;
          &lt;li&gt;Scene graphs : 장면의 객체와 관계&lt;/li&gt;
          &lt;li&gt;유사성 네트워크 : 데이터 수집, 유사한 지점을 연결함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;종종 크게 구별이 가지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;많은 데이터가 네트워크임
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/c6hlwkws5t04zq3/Screenshot%202019-12-02%2023.19.55.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/zkerkrhdjqfl10p/Screenshot%202019-12-02%2023.52.08.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;이 시스템은 어떻게 구성되어 있는가?&lt;/li&gt;
      &lt;li&gt;이것들의 design property는 무엇인가?- 많은 시스템 뒤엔 구성 요소간의 상호 작용을 적용하는 다이어그램, 네트워크가 있음&lt;/li&gt;
      &lt;li&gt;네트워크를 이해하지 않으면 이런 시스템을 모델링하고 예측할 수 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;더 나은 예측을 위해 Relational Structure를 어떻게 이용할까?&lt;/li&gt;
  &lt;li&gt;Graphs : Machine Learning
    &lt;ul&gt;
      &lt;li&gt;복잡한 도메인(텍스트, 이미지 등)은 관계형 그래프로 표현할 수 있는 구조를 가지고 있음&lt;/li&gt;
      &lt;li&gt;관계를 명시적으로 모델링해 더 나은 성능을 달성함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;네트워크에 관심가져야 하는 이유
    &lt;ul&gt;
      &lt;li&gt;복잡한 데이터를 설명하기 위한 범용 언어
        &lt;ul&gt;
          &lt;li&gt;과학, 자연, 기술 네트워크는 예상보다 비슷함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;분야간 단어 공유
        &lt;ul&gt;
          &lt;li&gt;컴퓨터 과학, 사회 과학, 물리학, 경제학, 통계학, 생물학&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;데이터 가용성, 계산 이슈
        &lt;ul&gt;
          &lt;li&gt;웹/모바일, 바이오, 건강, 의료&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Impact
        &lt;ul&gt;
          &lt;li&gt;소셜 네트워크, 약물 설계, AI 추론 등&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;networks-and-applications&quot;&gt;Networks and Applications&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Node classification
    &lt;ul&gt;
      &lt;li&gt;주어진 노드의 type, color 예측&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Link prediction
    &lt;ul&gt;
      &lt;li&gt;두 노드가 연결되어 있는지 예측&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Community detection
    &lt;ul&gt;
      &lt;li&gt;밀도있게 연결된 노드 클러스터 구분&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Network similarity
    &lt;ul&gt;
      &lt;li&gt;두 노드, 네트워크의 유사도 측정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;여러 예시
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/bz9bgqddzyuw74t/Screenshot%202019-12-03%2000.56.36.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/h77a5wt3fx9j7pb/Screenshot%202019-12-03%2000.56.52.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/gxxb0sg1lkflwd3/Screenshot%202019-12-03%2001.01.36.png?raw=1&quot; /&gt;
        &lt;ul&gt;
          &lt;li&gt;네트워크 구조가 시스템의 robustness에 어떤 영향을 미치는지 이해해야 함&lt;/li&gt;
          &lt;li&gt;네트워크 구조와 네트워크의 동적 프로세스 간의 상호 작용 및 장애에 대한 영향을 평가하기 위한 정량적 도구 개발&lt;/li&gt;
          &lt;li&gt;현실에서 실패가 재현할 수 있는 법칙을 따르고, 네트워크 도구를 사용해 정량화하고 예측할 수 있음을 배움&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/sq55tfzpe0fdjbe/Screenshot%202019-12-03%2001.12.03.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ts73wq6oji4zejs/Screenshot%202019-12-03%2001.12.23.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/1d6d20v5oc4mtg7/Screenshot%202019-12-03%2001.13.03.png?raw=1&quot; /&gt;
        &lt;ul&gt;
          &lt;li&gt;오 추천에도 이렇게 link prediction 사용할 수 있구나&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/h3nmvz4zh9dauzg/Screenshot%202019-12-03%2001.22.40.png?raw=1&quot; /&gt;
        &lt;ul&gt;
          &lt;li&gt;노드를 d차원 임베딩에 매핑해서 유사한 네트워크 환경을 가진 노드가 서로 가까이에 되도록 설정&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/samckayvkz0hr3g/Screenshot%202019-12-03%2001.23.40.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/tj940a4o2hpr01m/Screenshot%202019-12-03%2001.24.07.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/0du7dyyxxsxta72/Screenshot%202019-12-03%2001.24.26.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ahgtgh5418sif93/Screenshot%202019-12-03%2001.24.46.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/25aeswxcgkrjqm5/Screenshot%202019-12-03%2001.25.27.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/fu69lihvk7t2d4z/Screenshot%202019-12-03%2001.26.06.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ejdas5q0qbmvowf/Screenshot%202019-12-03%2001.26.36.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/yo6r0ppromkdddc/Screenshot%202019-12-03%2001.27.10.png?raw=1&quot; /&gt;
        &lt;ul&gt;
          &lt;li&gt;오 사이드이펙트 예측! 약의 pari가 주어지고 사이드 이펙트 예측하기 신기함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/94jvwp5lg8usmi6/Screenshot%202019-12-03%2001.27.50.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/7f1kxcrylzyytfk/Screenshot%202019-12-03%2001.28.53.png?raw=1&quot; /&gt;
        &lt;ul&gt;
          &lt;li&gt;A와 B를 같이 사용할 때 근육을 분해할 가능성은?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Network Analysis Tools
    &lt;ul&gt;
      &lt;li&gt;snap.py&lt;/li&gt;
      &lt;li&gt;snap c++&lt;/li&gt;
      &lt;li&gt;NetworkX, graph-tool&lt;/li&gt;
      &lt;li&gt;(facebook의 big-graph도 있음)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;structure-of-graphs&quot;&gt;Structure of Graphs&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;네트워크의 구조
    &lt;ul&gt;
      &lt;li&gt;Network는 object 쌍이 링크로 연결된 object 모음&lt;/li&gt;
      &lt;li&gt;네트워크 구조는 무엇일까?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Network의 구성 요소
    &lt;ul&gt;
      &lt;li&gt;Object : nodes, vertics, entity
        &lt;ul&gt;
          &lt;li&gt;N&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Interactions : links, edges
        &lt;ul&gt;
          &lt;li&gt;E&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;System : network, graph
        &lt;ul&gt;
          &lt;li&gt;G(N, E)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Networks와 Graph의 차이
    &lt;ul&gt;
      &lt;li&gt;Network는 실제 시스템을 의미함
        &lt;ul&gt;
          &lt;li&gt;Web, Social network&lt;/li&gt;
          &lt;li&gt;Language : Network, node, link&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Graph는 network의 수학적 표현
        &lt;ul&gt;
          &lt;li&gt;Web graph, Social graph&lt;/li&gt;
          &lt;li&gt;Language : Graph, vertex, edge&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;필요할 땐 구별하겠지만, 대부분 두 용어를 번갈아 사용할 예정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/1wedzrc3cueixpx/Screenshot%202019-12-03%2021.02.49.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Choosing Proper Representations
    &lt;ul&gt;
      &lt;li&gt;협력하는 개인을 연결하면 professional network&lt;/li&gt;
      &lt;li&gt;sexual 관계를 연결하면 sexual network&lt;/li&gt;
      &lt;li&gt;인용하는 과학 논문을 연결하면 citation network&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Network를 정의하는 방법
    &lt;ul&gt;
      &lt;li&gt;Graph 작성
        &lt;ul&gt;
          &lt;li&gt;Node란 무엇인가?&lt;/li&gt;
          &lt;li&gt;Edge란 무엇인가?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;적절한 네트워크 representation 선택
        &lt;ul&gt;
          &lt;li&gt;주어진 도메인, 문제에서 네트워크를 성공적으로 사용하기 위해 중요한 결정&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;어떤 경우엔 독특하고 명확한 표현이 있음&lt;/li&gt;
      &lt;li&gt;다른 경우엔 표현이 unique하지 않음&lt;/li&gt;
      &lt;li&gt;링크를 할당하는 방법에 따라 공부할 내용이 다양함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;network-표현-방식&quot;&gt;Network 표현 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Undirected
    &lt;ul&gt;
      &lt;li&gt;방향성이 없는 그래프&lt;/li&gt;
      &lt;li&gt;Links : undirected, Symmetrical, reciprocal&lt;/li&gt;
      &lt;li&gt;예시 : Collaborations, 페이스북 친구 관계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Directed
    &lt;ul&gt;
      &lt;li&gt;방향성이 있는 그래프&lt;/li&gt;
      &lt;li&gt;Links : directed, arcs&lt;/li&gt;
      &lt;li&gt;예시 : 트위터의 팔로잉&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;노드의 차수(Node Degrees)
    &lt;ul&gt;
      &lt;li&gt;Undirected
        &lt;ul&gt;
          &lt;li&gt;Node degree, &lt;code class=&quot;MathJax_Preview&quot;&gt;k_{i}&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;k_{i}&lt;/script&gt; : 노드 i에 인접한 edge의 수&lt;/li&gt;
          &lt;li&gt;Average degree =&amp;gt; 어디에 쓰지?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Directed
        &lt;ul&gt;
          &lt;li&gt;in-degree : 해당 노드로 향하는, out-degree : 해당 노드가 향하는&lt;/li&gt;
          &lt;li&gt;source : &lt;code class=&quot;MathJax_Preview&quot;&gt;k^{in}=0&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;k^{in}=0&lt;/script&gt;&lt;/li&gt;
          &lt;li&gt;sink : &lt;code class=&quot;MathJax_Preview&quot;&gt;k^{out}=0&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;k^{out}=0&lt;/script&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/u7n620pjrnodp6g/Screenshot%202019-12-03%2022.41.10.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;완전 그래프(Complete Graph)
    &lt;ul&gt;
      &lt;li&gt;서로 다른 두 개의 꼭짓점이 반드시 하나의 변으로 연결된 그래프&lt;/li&gt;
      &lt;li&gt;서로 다른 두 개의 vertex가 반드시 하나의 edge로 연결&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;MathJax_Preview&quot;&gt;E = E_{max}&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;E = E_{max}&lt;/script&gt;일 경우 complete graph&lt;/li&gt;
      &lt;li&gt;average degree = N-1&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/dkqmghcgd44pisi/Screenshot%202019-12-03%2022.44.42.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이분 그래프(Bipartite Graph)
    &lt;ul&gt;
      &lt;li&gt;핀터레스트에서 사용&lt;/li&gt;
      &lt;li&gt;이분 그래프는 모든 링크가 U의 노드를 V의 노드에 연결하도록 노드를 U,V로 나눌 수 있는 그래프, U와 V는 독립&lt;/li&gt;
      &lt;li&gt;U끼리는 연결되지 않고, V끼리도 연결되지 않음&lt;/li&gt;
      &lt;li&gt;인접한 정점끼리 다른 색으로 칠하고 모든 정점을 두 가지 색으로만 칠할 수 있는 그래프&lt;/li&gt;
      &lt;li&gt;예시
        &lt;ul&gt;
          &lt;li&gt;Authors to Papers&lt;/li&gt;
          &lt;li&gt;Actors to Movies&lt;/li&gt;
          &lt;li&gt;Users to Movies&lt;/li&gt;
          &lt;li&gt;Recipes to Ingredients&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;“Folded” networks
        &lt;ul&gt;
          &lt;li&gt;Author collaborations networks&lt;/li&gt;
          &lt;li&gt;Movie co-rating networks&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;BFS, DFS 탐색 이용하면 확인할 수 있음&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://gmlwjd9405.github.io/2018/08/23/algorithm-bipartite-graph.html&quot;&gt;이분 그래프(Bipartite Graph)란&lt;/a&gt; 참고&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/mqxudp9rre5qgb6/Screenshot%202019-12-03%2022.52.43.png?raw=1&quot; /&gt;
        &lt;ul&gt;
          &lt;li&gt;B와 C는 5와 공통적으로 연결됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Representing Graphs : 인접 행렬(Adjacency matrix)
    &lt;ul&gt;
      &lt;li&gt;node i와 j로 가는 링크가 있다면 1, 아니면 0&lt;/li&gt;
      &lt;li&gt;인접행렬 : 그래프에서 어느 꼭짓점들이 변으로 연결되었는지 나타내는 행렬&lt;/li&gt;
      &lt;li&gt;undirected graph는 대칭 행렬이지만, directed graph(오른쪽)의 경우 대칭 행렬이 아님&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/des3cl902gow4zs/Screenshot%202019-12-03%2022.57.06.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9yybz1vrgrdxjow/Screenshot%202019-12-03%2022.58.28.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Representing Graphs : Edge list
    &lt;ul&gt;
      &lt;li&gt;엣지 리스트 : 연결된 엣지들의 집합&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/g944aslxyyghlm5/Screenshot%202019-12-03%2023.06.43.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Representing Graphs : 인접 리스트(Adjancency list)
    &lt;ul&gt;
      &lt;li&gt;그래프의 한 꼭짓점에서 연결되어 있는 꼭짓점들을 하나의 연결 리스트로 표현&lt;/li&gt;
      &lt;li&gt;인접 행렬에 비해 edge가 희소한 그래프에서 효과적임&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/fxcilsiz4i3rgan/Screenshot%202019-12-03%2023.08.58.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Networks are Sparse Graphs
    &lt;ul&gt;
      &lt;li&gt;현실 네트워크는 Sparse&lt;/li&gt;
      &lt;li&gt;따라서 인접 행렬은 0으로 채워짐!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Edge Attribute
    &lt;ul&gt;
      &lt;li&gt;가능한 옵션
        &lt;ul&gt;
          &lt;li&gt;Weight (예 : 커뮤니케이션의 빈도)&lt;/li&gt;
          &lt;li&gt;Ranking (예 : Best friend, Second best freind)&lt;/li&gt;
          &lt;li&gt;Type (Frient, relactive, co-worker)&lt;/li&gt;
          &lt;li&gt;Sign : Friend vs Foe, Trust vs Distrust&lt;/li&gt;
          &lt;li&gt;Propeties depending on the structure of the reset of the graph : 공통 친구 수&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;More Types of Graphs
    &lt;ul&gt;
      &lt;li&gt;Unweighted, Weighted(undirected)
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ltsz03qx42a5zgb/Screenshot%202019-12-03%2023.14.26.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Self-edges(self-loops), Multigraph
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ittwwh229ulxqj8/Screenshot%202019-12-03%2023.14.45.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Connectivity of Undirected Graphs
    &lt;ul&gt;
      &lt;li&gt;두 정점은 경로로 연결될 수 있음&lt;/li&gt;
      &lt;li&gt;연결이 끊어진 그래프는 둘 이상의 연결된 구성 요소로 구성됨&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/qr61lm4s95oyisd/Screenshot%202019-12-03%2023.16.25.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/2b4nt1m9sykqdmk/Screenshot%202019-12-03%2023.16.43.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;여러 컴포너튼가 있는 네트워크의 인접 행렬은 block-diagonal 형태로 작성할 수 있어서 0이 아닌 요소는 사각형으로 제한되고 아니면 모두 0임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Connectivity of directed Graphs
    &lt;ul&gt;
      &lt;li&gt;strongly connected(강하게 연결된) directed graph
        &lt;ul&gt;
          &lt;li&gt;각 노드에서 다른 모든 노드로 경로가 있고, 반대도 마찬가지&lt;/li&gt;
          &lt;li&gt;SCC를 식별할 수 있지만 모든 노드가 SCC는 아님&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/uwfflcz6datfnrl/Screenshot%202019-12-03%2023.25.27.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;weakly connected(약하게 연결된) directed graph
        &lt;ul&gt;
          &lt;li&gt;가장 자리 방향을 무시하면 연결됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/1rq9en9ix083eyg/Screenshot%202019-12-03%2023.19.37.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Network Representations
    &lt;ul&gt;
      &lt;li&gt;Email network =&amp;gt; directed multigraph with self-edges&lt;/li&gt;
      &lt;li&gt;Facebook friendship =&amp;gt; undirected, unweighted&lt;/li&gt;
      &lt;li&gt;Citation networks =&amp;gt; unweighted, directed, acyclic&lt;/li&gt;
      &lt;li&gt;Collaboration networks =&amp;gt; undirected multigraph of weighted graph&lt;/li&gt;
      &lt;li&gt;Mobile phone calss =&amp;gt; directed, (weighted?) multigraph&lt;/li&gt;
      &lt;li&gt;Protein Interactions =&amp;gt; undirected, unweighted with self interactions&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;readings&quot;&gt;Readings&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;P. Erdos, A. Renyi. &lt;a href=&quot;http://snap.stanford.edu/class/cs224w-readings/erdos59random.pdf&quot;&gt;On Random Graphs&lt;/a&gt; I. Publ. Math. Debrecen,1959.&lt;/li&gt;
  &lt;li&gt;P. Erdos, A. Renyi. &lt;a href=&quot;http://snap.stanford.edu/class/cs224w-readings/erdos60random.pdf&quot;&gt;On the evolution of random graphs&lt;/a&gt;. Magyar Tud.
Akad. Mat. Kutato Int. Koezl., 1960.&lt;/li&gt;
  &lt;li&gt;B. Bollobas. &lt;a href=&quot;http://www2.math.uu.se/~svante/talks/2014stockholm.pdf&quot;&gt;Random Graphs&lt;/a&gt;. Cambridge University Press.&lt;/li&gt;
  &lt;li&gt;M.E.J. Newman, S. H. Strogatz and D.J. Watts. &lt;a href=&quot;http://math.uchicago.edu/~shmuel/Network-course-readings/Random-Graphs-with-Arbitrary-Degree-Distributions-and-Their-Applications.pdf&quot;&gt;Random graphs with arbitrary degree distributions and their applications&lt;/a&gt;. Phys. Rev. E
64, 026118, 2001.&lt;/li&gt;
  &lt;li&gt;R. Milo, N. Kashtan, S. Itzkovitz, M.E.J. Newman, U. Alon. &lt;a href=&quot;https://arxiv.org/abs/cond-mat/0312028&quot;&gt;On the uniform generation of random graphs with prescribed degree&lt;/a&gt;
sequences. Arxiv, 2004.&lt;/li&gt;
  &lt;li&gt;D. Ellis. &lt;a href=&quot;http://snap.stanford.edu/class/cs224w-readings/ellis11expansion.pdf&quot;&gt;The expansion of random regular graphs. Lecture notes&lt;/a&gt; from Algebraic methods in combinatorics, Cambridge University, 2011.&lt;/li&gt;
  &lt;li&gt;S. Arora, S. Rao and U. Vazirani. &lt;a href=&quot;http://snap.stanford.edu/class/cs224w-readings/arora04expansion.pdf&quot;&gt;Expander Flows, Geometric Embeddings and Graph Partitioning&lt;/a&gt;. In proc. STOC ‘04, 2004.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 03 Dec 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/2019/12/03/cs224w-ml-with-graph/</link>
        <guid isPermaLink="true">http://localhost:4000/data/2019/12/03/cs224w-ml-with-graph/</guid>
        
        <category>ml</category>
        
        <category>graph</category>
        
        
        <category>data</category>
        
      </item>
    
      <item>
        <title>지도 데이터 시각화 : Uber의 pydeck 사용하기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Uber의 대규모 WebGL 기반 데이터 시각화 도구인 Deck.gl를 파이썬에서 사용할 수 있도록 만든 pydeck 사용 방법에 대해 작성한 글입니다
    &lt;ul&gt;
      &lt;li&gt;제가 연습하며 사용한 코드는 &lt;a href=&quot;https://nbviewer.jupyter.org/github/zzsza/TIL/blob/master/python/pydeck-example.ipynb&quot;&gt;Nbviewer&lt;/a&gt;로 보실 수 있습니다 :)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;deckgl&quot;&gt;Deck.gl&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://deck.gl&quot;&gt;Homepage&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Uber에서 만든 WebGL 기반 대용량 데이터 시각화 도구
    &lt;ul&gt;
      &lt;li&gt;WebGL : 웹 기반의 그래픽 라이브러리로 웹 브라우저에서 3D 그래픽을 사용할 수 있도록 해줌. 참고 : &lt;a href=&quot;https://ko.wikipedia.org/wiki/WebGL&quot;&gt;위키백과&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;주요 특징
    &lt;ul&gt;
      &lt;li&gt;데이터 시각화에 Layer적 접근(계층적 접근)
        &lt;ul&gt;
          &lt;li&gt;Deck.gl을 사용하면 존재하는 레이어를 활용해 복잡한 시각화를 구성할 수 있으며, 재사용 가능한 레이어로 쉽개 패키징하고 공유할 수 있음&lt;/li&gt;
          &lt;li&gt;이미 입증된 레이어 종류를 제공하고 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;GPU의 고정밀 계산
        &lt;ul&gt;
          &lt;li&gt;Deck.gl은 GPU에서 64비트 부동 소수점 계산을 emulating해서 비교할 수 없는 정확성과 성능으로 데이터 세트를 렌더링함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;React와 Mapbox GL 통합
        &lt;ul&gt;
          &lt;li&gt;Deck.gl은 React와 잘 맞고, 리액트 프로그래밍 패러다임에서 효율적인 WebGL 렌더링을 지원함&lt;/li&gt;
          &lt;li&gt;Maxbox GL과 함께 사용하면 mapbox 카메라 시스템에 매핑되서 맵박스 지도에서 2D, 3D 시각화를 할 수 있게 됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Introduction
    &lt;ul&gt;
      &lt;li&gt;deck.gl은 대규모 데이터 시각화를 단순히 할 수 있도록 설계됨&lt;/li&gt;
      &lt;li&gt;사용자는 기존 레이어 구성을 통해 적은 노력으로 인상적인 시각화 결과를 얻을 수 있고, 고급 WebGL 기반으로 만든 자바스크립트 레이어로 패키징할 수 있는 아키텍처를 제공함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;pydeck&quot;&gt;pydeck&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/uber/deck.gl/tree/master/bindings/pydeck&quot;&gt;pydeck Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;pydeck을 deck.gl을 파이썬에서 사용할 수 있도록 만든 라이브러리&lt;/li&gt;
  &lt;li&gt;pydeck의 목표 : Python 사용자가 많은 Javascript를 몰라도 deck.gl 맵을 만들 수 있도록 하는 것&lt;/li&gt;
  &lt;li&gt;Jupyter Notebook에서 가장 잘 작동하고, 노트북에서 결과를 보거나 HTML로 추출할 수 있음&lt;/li&gt;
  &lt;li&gt;pydeck의 고유한 기능
    &lt;ul&gt;
      &lt;li&gt;Folium, Ipyleaflet 등의 지도 라이브러리와 대비한 기능&lt;/li&gt;
      &lt;li&gt;Python에서 deck.gl의 전체 레이어 사용 가능&lt;/li&gt;
      &lt;li&gt;대규모 데이터에서 색상 변경, 데이터 수정 지원&lt;/li&gt;
      &lt;li&gt;시각화에서 선택한 데이터를 Jupyter Notebook의 커널로 다시 전달할 수 있는 양방향 통신&lt;/li&gt;
      &lt;li&gt;Python API를 통해 수십만 개의 데이터를 2D / 3D로 매핑하는 기능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단, 아직 공식 Release는 아니고 Beta임
    &lt;ul&gt;
      &lt;li&gt;글 작성 기준 최신 버전은 pydeck-0.1.dev5&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;install&quot;&gt;Install&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;추후에 바뀔 수 있으니 &lt;a href=&quot;https://github.com/uber/deck.gl/tree/master/bindings/python/pydeck&quot;&gt;pydeck Github&lt;/a&gt; 참고&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;설치&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pip3 install pydeck
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Extension 설정&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  jupyter nbextension install --sys-prefix --symlink --overwrite --py pydeck
  jupyter nbextension enable --sys-prefix --py pydeck
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;mapbox-api-등록&quot;&gt;Mapbox API 등록&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;deck.gl처럼 pydeck 라이브러리도 Mapbox의 베이스맵 타일이 필요함
    &lt;ul&gt;
      &lt;li&gt;Mapbox API는 특정 사용량까진 무료이지만, 그 이상을 사용하고 싶을 경우 비용을 내야함. &lt;a href=&quot;https://www.mapbox.com/pricing/#api-pricing&quot;&gt;API pricing&lt;/a&gt; 참고&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://account.mapbox.com/access-tokens/&quot;&gt;Mapbox API access token&lt;/a&gt;으로 이동해 회원 가입&lt;/li&gt;
  &lt;li&gt;Access tokens의 Token을 복사
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/uh4n0n732pf3z0i/Screenshot%202019-11-24%2011.52.58.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;노트북에서 매번 정의하지 않고 환경 변수로 추가. 터미널에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;vi ~/.zshrc&lt;/code&gt;(bash를 사용하면 vi ~/.bashrc)을 한 후 아래 내용 추가&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  export MAPBOX_API_KEY=&quot;pk로 시작하는 여러분들의 Token 값&quot;
  # ESC :wq 로 저장하고 빠져나오기
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;터미널에서 수정 사항 적용&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  source ~/.bashrc
  # 만약 zsh을 사용하면 source ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;터미널에서 MAPBOX_API_KEY가 제대로 나오는지 확인&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  echo $MAPBOX_API_KEY
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;만약 노트북에서 Mapbox API key is not set 에러가 발생하면 터미널을 아예 끄고, Jupyter notebook 재실행	
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;example-code&quot;&gt;Example Code&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;공식 홈페이지에서 제공하는 예시
    &lt;ul&gt;
      &lt;li&gt;단 r.to_html()을 r.show()로 바꿈(노트북에서 바로 보이도록 하기 위해)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import pydeck

# 2014 locations of car accidents in the UK
UK_ACCIDENTS_DATA = ('https://raw.githubusercontent.com/uber-common/'
                     'deck.gl-data/master/examples/3d-heatmap/heatmap-data.csv')

# Define a layer to display on a map
layer = pydeck.Layer(
    'HexagonLayer',
    UK_ACCIDENTS_DATA,
    get_position='[lng, lat]',
    auto_highlight=True,
    elevation_scale=50,
    pickable=True,
    elevation_range=[0, 3000],
    extruded=True,                 
    coverage=1)

# Set the viewport location
view_state = pydeck.ViewState(
    longitude=-1.415,
    latitude=52.2323,
    zoom=6,
    min_zoom=5,
    max_zoom=15,
    pitch=40.5,
    bearing=-27.36)

# Render
r = pydeck.Deck(layers=[layer], initial_view_state=view_state)
# r.to_html('demo.html')
r.show() # html 저장하지 않고 바로 보고싶은 경우 사용
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/x75gp69fqpj83bp/Screenshot%202019-11-24%2012.18.30.png?raw=1&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;layer-종류&quot;&gt;Layer 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;deck.gl에서 지원하는 Layer를 잘 파악해둬야 좋음&lt;/li&gt;
  &lt;li&gt;기본적으로 Layer나 CompositeLayer 클래스를 상속함&lt;/li&gt;
  &lt;li&gt;Core Layers : 일반적인 용도의 레이어
    &lt;ul&gt;
      &lt;li&gt;ArcLayer
        &lt;ul&gt;
          &lt;li&gt;위도 / 경도 좌표로 지정된 소스와 대상을 연결&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/j9k63c6whc82e9z/Screenshot%202019-11-24%2014.30.57.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;BitmapLayer
        &lt;ul&gt;
          &lt;li&gt;지정된 경계에 비트맵 이미지를 렌더링&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/bz5ivq3gr3umbhk/Screenshot%202019-11-24%2014.31.28.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ColumnLayer
        &lt;ul&gt;
          &lt;li&gt;HexagonLayer에 의해 렌더링되는 기본 레이어&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/lgtqf6awp2tqgt1/Screenshot%202019-11-24%2014.32.06.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;GeoJsonLayer
        &lt;ul&gt;
          &lt;li&gt;GeoJson 형식의 데이터를 가져와 다각형, 선, 점으로 렌더링&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/qhzovgwi7o5mbab/Screenshot%202019-11-24%2014.36.32.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;GridCellLayer
        &lt;ul&gt;
          &lt;li&gt;집계 후 CPUGridLayer에 렌더링됨&lt;/li&gt;
          &lt;li&gt;ColumnLayer의 변형&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/n5hy6qg68vyschk/Screenshot%202019-11-24%2014.37.38.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;IconLayer
        &lt;ul&gt;
          &lt;li&gt;지정된 좌표에서 래스터 아이콘을 렌더링&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/x19crv143y3qtnn/Screenshot%202019-11-24%2014.38.34.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;LineLayer
        &lt;ul&gt;
          &lt;li&gt;위도 / 경도 좌표로 지정된 소스와 타겟점을 flat line으로 렌더링&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/8ff2ri9gfop6v7w/Screenshot%202019-11-24%2014.39.59.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;PathLayer
        &lt;ul&gt;
          &lt;li&gt;좌표 점 리스트를 가져와 돌출 선으로 렌더링&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/e7blc5u7dsngvll/Screenshot%202019-11-24%2014.40.51.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;PointCloudLayer
        &lt;ul&gt;
          &lt;li&gt;3D 위치, 색 등을 가져와 특정 반지름을 가진 구를 렌더링&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/qac5tdqzvp5p3my/Screenshot%202019-11-24%2014.41.14.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;PolygonLayer
        &lt;ul&gt;
          &lt;li&gt;채워졌거나 스트로크된 다각형을 렌더링&lt;/li&gt;
          &lt;li&gt;PolygnLayer는 CompsiteLayer&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/v2m1fwzydhd93ch/Screenshot%202019-11-24%2014.42.06.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ScatterplotLayer
        &lt;ul&gt;
          &lt;li&gt;위도 경도 쌍으로 이루어진 점을 가져와 특정 반지름의 원으로 렌더링&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/q8avr7hrypbhuzr/Screenshot%202019-11-24%2014.43.20.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;SolidPolygonLayer
        &lt;ul&gt;
          &lt;li&gt;채워진 다각형을 렌더링&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;TextLayer
        &lt;ul&gt;
          &lt;li&gt;텍스처 레이블을 맵에 렌더링함&lt;/li&gt;
          &lt;li&gt;IconLayer의 확장판&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/qg90u9b8tmmcmpt/Screenshot%202019-11-24%2014.44.40.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Aggregation Layers : 입력 데이터를 집계 및 육각형, 컨투어 히트맵 등으로 시각화하는 레이어
    &lt;ul&gt;
      &lt;li&gt;ContourLayer
        &lt;ul&gt;
          &lt;li&gt;주어진 임계값과 셀 크기에 대해 Isoline, Isband를 시각화&lt;/li&gt;
          &lt;li&gt;Isoband : 주어진 임계값 범위 값을 포함하는 다각형&lt;/li&gt;
          &lt;li&gt;Isoline : 등치선&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/g397r5kjnfx0onv/Screenshot%202019-11-24%2014.33.47.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;GridLayer
        &lt;ul&gt;
          &lt;li&gt;point의 배열에 기반해 렌더링&lt;/li&gt;
          &lt;li&gt;일정한 셀의 크기를 취하고 입력 포인트를 셀로 집계함&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/28rgurbzb9ry947/Screenshot%202019-11-24%2014.46.07.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;GPUGridLayer
        &lt;ul&gt;
          &lt;li&gt;GridLayer가 GPU에서 렌더링(WebGL2가 지원되는 브라우저 한정)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;CPUGridLayer
        &lt;ul&gt;
          &lt;li&gt;GridLayer가 CPU에서 렌더링&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;HexagonLayer
        &lt;ul&gt;
          &lt;li&gt;pint의 배열에 기반으로 육각형 히트맵 렌더링&lt;/li&gt;
          &lt;li&gt;육각형의 반지름을 사용해 그림&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/h8e502w7hycuf9r/Screenshot%202019-11-24%2014.50.43.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ScreenGridLayer
        &lt;ul&gt;
          &lt;li&gt;위도 및 경도 좌표 포인트의 배열을 가져와 히스토그램 빈으로 집계해 그리드로 렌더링&lt;/li&gt;
          &lt;li&gt;셀 사이즈를 조정하면 다시 집계해 렌더링함&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ihd5jd1s322ejz0/Screenshot%202019-11-24%2014.52.18.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;HeatmapLayer
        &lt;ul&gt;
          &lt;li&gt;데이터의 Spatial 분포를 시각화할 때 사용&lt;/li&gt;
          &lt;li&gt;내부적으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Kernel_%28statistics%29#Kernel_functions_in_common_use&quot;&gt;Gaussian Kernel Density Estimation&lt;/a&gt;을 구현해 히트맵 렌더링&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/k7h15xfnc33knat/Screenshot%202019-11-24%2014.53.33.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Geo Layers : 지도 타일, 지리 공간 색인 시스템, GIS 형식을 지원하는 지리 공간 레이어
    &lt;ul&gt;
      &lt;li&gt;GreatCircleLayer
        &lt;ul&gt;
          &lt;li&gt;ArcLayer의 변형&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%8C%80%EC%9B%90&quot;&gt;Great Circle(대원)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/loozukirly97k28/Screenshot%202019-11-24%2014.55.59.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;H3ClusterLayer
        &lt;ul&gt;
          &lt;li&gt;H3으로 나타난 Cluster 렌더링&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/68ftvrw6z31p5yq/Screenshot%202019-11-24%2014.57.48.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;H3HexagonLayer
        &lt;ul&gt;
          &lt;li&gt;H3으로 렌더링&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/zbbfe4kg0swcajs/Screenshot%202019-11-24%2014.58.45.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;S2Layer
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;http://s2geometry.io/&quot;&gt;S2 토큰(지리 공간 인덱스)&lt;/a&gt;을 기반으로 지오메트리를 계산해 채워진 다각형 렌더링&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9as0hgzitt93abh/Screenshot%202019-11-24%2015.00.57.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;TileLayer
        &lt;ul&gt;
          &lt;li&gt;getTileData로 타입을 가져와 GeJsonLayer에서 렌더링&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/sczu3nhaqlcj19y/Screenshot%202019-11-24%2015.02.53.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;TripsLayer
        &lt;ul&gt;
          &lt;li&gt;차량 Trip을 나타내는 path를 렌더링&lt;/li&gt;
          &lt;li&gt;currentTime이 바뀌며 이동하는 모습을 시각화할 수 있음&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/5hthrbm0ukf6sei/Screenshot%202019-11-24%2015.03.32.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mesh Layers : glTF 형식의 그래프에 대한 실험 지원. 3D 모델 지원
    &lt;ul&gt;
      &lt;li&gt;SimpleMeshLayer&lt;/li&gt;
      &lt;li&gt;ScenegraphLayer&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;pydeck-사용-방법&quot;&gt;pydeck 사용 방법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;pydeck은 geojson, Pandas Dataframe을 Input으로 사용 가능(URL도 사용 가능)&lt;/li&gt;
  &lt;li&gt;큰 흐름
    &lt;ul&gt;
      &lt;li&gt;1) 데이터 선택&lt;/li&gt;
      &lt;li&gt;2) Layer 선택&lt;/li&gt;
      &lt;li&gt;3) ViewState 정의&lt;/li&gt;
      &lt;li&gt;4) 렌더링&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1) 데이터 선택&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import pandas as pd
	
  UK_ACCIDENTS_DATA = 'https://raw.githubusercontent.com/uber-common/deck.gl-data/master/examples/3d-heatmap/heatmap-data.csv'
	
  pd.read_csv(UK_ACCIDENTS_DATA).head()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;2) Layer 선택
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pdk.Layer()&lt;/code&gt;에서 첫 인자에 레이어 이름을 String으로 작성
        &lt;ul&gt;
          &lt;li&gt;참고 : pdk.Layer(type, data, id=None, get_position=’[lng, lat]’, **kwargs)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;그 후 데이터와 각종 인자를 넣어줌&lt;/li&gt;
      &lt;li&gt;세부 인자는 &lt;a href=&quot;https://deck.gl/#/documentation/deckgl-api-reference/layers/overview&quot;&gt;Layer Document&lt;/a&gt;에서 찾아서 넣으면 됨&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import pydeck as pdk
	
  layer = pdk.Layer(
      'HexagonLayer',
      UK_ACCIDENTS_DATA,
      get_position='[lng,lat]',
      elevation_scale=50,
      pickable=True,
      auto_highlight=True,
      elevation_range=[0, 3000],
      extruded=True,                 
      coverage=1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;3) ViewState 정의
    &lt;ul&gt;
      &lt;li&gt;ViewState는 지도 데이터를 기준으로 카메라 각도를 지정함&lt;/li&gt;
      &lt;li&gt;기본적으로 지도를 잡고 드래그, 회전할 수 있음&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  view_state = pdk.ViewState(
      longitude=-1.415,
      latitude=52.2323,
      zoom=6,
      min_zoom=5,
      max_zoom=15,
      pitch=40.5,
      bearing=-27.36)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;4) 렌더링
    &lt;ul&gt;
      &lt;li&gt;pdk.Deck으로 레이어와 view state를 통합&lt;/li&gt;
      &lt;li&gt;layers 인자에 여러 레이어를 추가할 수 있음&lt;/li&gt;
      &lt;li&gt;r.show()로 시각화하고, 만약 저장하고 싶다면 r.to_html()사용&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  r = pdk.Deck(layers=[layer], initial_view_state=view_state)
  r.show()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;pdk.Deck Class 참고&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pdk.Deck(
      layers=[],
      views=[{&quot;controller&quot;: true, &quot;type&quot;: &quot;MapView&quot;}],
      map_style='mapbox://styles/mapbox/dark-v9',
      mapbox_key=None,
      initial_view_state={&quot;bearing&quot;: 0, &quot;latitude&quot;: 0.0, &quot;longitude&quot;: 0.0, &quot;maxZoom&quot;: 20, &quot;minZoom&quot;: 0, &quot;pitch&quot;: 0, &quot;zoom&quot;: 1},
      width='100%',
      height=500,
      tooltip=True,
  )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;렌더링 후 업데이트
    &lt;ul&gt;
      &lt;li&gt;layer의 속성을 수정한 후, r.update()를 사용해 업데이트 가능&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  layer.elevation_range = [0, 10000]
  r.update()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;시간이 지나며 업데이트하기&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import time
  r.show()
  for i in range(0, 10000, 1000):
      layer.elevation_range = [0, i]
      r.update()
      time.sleep(0.1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tooltip-추가하기&quot;&gt;Tooltip 추가하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;pdk.Deck()으로 객체를 생성할 때 tooltip을 설정하면 툴팁을 넣을 수 있음&lt;/li&gt;
  &lt;li&gt;1) tooltip=True을 주면 가진 모든 내용을 툴팁으로 보여줌&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2) 특정 값만 HTML으로 스타일을 입힐 수도 있음&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import pydeck as pdk

  layer = pdk.Layer(
      'HexagonLayer',
      UK_ACCIDENTS_DATA,
      get_position='[lng, lat]',
      auto_highlight=True,
      elevation_scale=50,
      pickable=True,
      elevation_range=[0, 3000],
      extruded=True,
      coverage=1)
	
  # Set the viewport location
  view_state = pdk.ViewState(
      longitude=-1.415,
      latitude=52.2323,
      zoom=6,
      min_zoom=5,
      max_zoom=15,
      pitch=40.5,
      bearing=-27.36)
	
  # Combined all of it and render a viewport
  r = pdk.Deck(
      layers=[layer],
      initial_view_state=view_state,
      tooltip={
          'html': '&amp;lt;b&amp;gt;Elevation Value:&amp;lt;/b&amp;gt; {elevationValue}',
          'style': {
              'color': 'white'
          }
      }
  )
  r.show()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3) 그냥 Text로 표현할 수도 있음&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import pydeck as pdk

  layer = pdk.Layer(
      'HexagonLayer',
      UK_ACCIDENTS_DATA,
      get_position='[lng, lat]',
      auto_highlight=True,
      elevation_scale=50,
      pickable=True,
      elevation_range=[0, 3000],
      extruded=True,
      coverage=1)
	
  # Set the viewport location
  view_state = pdk.ViewState(
      longitude=-1.415,
      latitude=52.2323,
      zoom=6,
      min_zoom=5,
      max_zoom=15,
      pitch=40.5,
      bearing=-27.36)
	
  # Combined all of it and render a viewport
  r = pdk.Deck(
      layers=[layer],
      initial_view_state=view_state,
      tooltip={
          &quot;text&quot;: &quot;Elevation: {elevationValue}&quot;
      }
  )
  r.show()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;ipywidgets을-사용해-interactive-시각화&quot;&gt;ipywidgets을 사용해 Interactive 시각화&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사용 방식
    &lt;ul&gt;
      &lt;li&gt;1) 우선 베이스가 되는 Deck을 만들어서 r.show()로 보여줌&lt;/li&gt;
      &lt;li&gt;2) ipywidget 슬라이더 생성&lt;/li&gt;
      &lt;li&gt;3) ipywidget에서 사용할 함수 정의 =&amp;gt; 마지막에 r.update() 사용&lt;/li&gt;
      &lt;li&gt;4) slider.observe로 Deck과 슬라이더를 연결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;예제 코드&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import pandas as pd
  import pydeck as pdk
	
  LIGHTS_URL = 'https://raw.githubusercontent.com/ajduberstein/lights_at_night/master/chengdu_lights_at_night.csv'
  df = pd.read_csv(LIGHTS_URL)
  df['color'] = df['brightness'].apply(lambda val: [255, val * 4,  255, 255])
  plottable = df[df['year'] == 1993].to_dict(orient='records')
	
  view_state = pdk.ViewState(
      latitude=31.0,
      longitude=104.5,
      zoom=8,
      max_zoom=8,
      min_zoom=8)
  scatterplot = pdk.Layer(
      'HeatmapLayer',
      data=plottable,
      get_position='[lng, lat]',
      get_weight='brightness',
      opacity=0.5,
      pickable=False,
      get_radius=800)
  r = pdk.Deck(
      layers=[scatterplot],
      initial_view_state=view_state,
      views=[pdk.View(type='MapView', controller=None)])
  r.show()
	
  # Widget 슬라이더 생성
  import ipywidgets as widgets
  from IPython.display import display
  slider = widgets.IntSlider(1992, min=1993, max=2013, step=2)
	
  # Widget에서 사용할 함수 정의 
  def on_change(v):
      results = df[df['year'] == slider.value].to_dict(orient='records')
      scatterplot.data = results
      r.update()
	    
  # Deck과 슬라이더 연결
  slider.observe(on_change, names='value')
  display(slider)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/gkqy0h4f7u6sjxd/Screenshot%202019-11-24%2015.52.04.png?raw=1&quot; /&gt;	
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;뉴욕-택시-데이터-시각화&quot;&gt;뉴욕 택시 데이터 시각화&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;pickup ~ dropoff arc layer&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;agg_query = &quot;&quot;&quot;
WITH base_data AS 
(
  SELECT 
    nyc_taxi.*, 
    pickup.zip_code as pickup_zip_code,
    pickup.internal_point_lat as pickup_zip_code_lat,
    pickup.internal_point_lon as pickup_zip_code_lon,
    dropoff.zip_code as dropoff_zip_code,
    dropoff.internal_point_lat as dropoff_zip_code_lat,
    dropoff.internal_point_lon as dropoff_zip_code_lon
  FROM (
    SELECT *
    FROM `bigquery-public-data.new_york_taxi_trips.tlc_yellow_trips_2015`
    WHERE 
        EXTRACT(MONTH from pickup_datetime) = 1
        and pickup_latitude &amp;lt;= 90 and pickup_latitude &amp;gt;= -90
        and dropoff_latitude &amp;lt;= 90 and dropoff_latitude &amp;gt;= -90
    ) AS nyc_taxi
  JOIN (
    SELECT zip_code, state_code, state_name, city, county, zip_code_geom, internal_point_lat, internal_point_lon 
    FROM `bigquery-public-data.geo_us_boundaries.zip_codes`
    WHERE state_code='NY'
    ) AS pickup 
  ON ST_CONTAINS(pickup.zip_code_geom, st_geogpoint(pickup_longitude, pickup_latitude))
  JOIN (
    SELECT zip_code, state_code, state_name, city, county, zip_code_geom, internal_point_lat, internal_point_lon 
    FROM `bigquery-public-data.geo_us_boundaries.zip_codes`
    WHERE state_code='NY' 
    ) AS dropoff
  ON ST_CONTAINS(dropoff.zip_code_geom, st_geogpoint(dropoff_longitude, dropoff_latitude))
  
)

SELECT 
  pickup_zip_code,
  pickup_zip_code_lat,
  pickup_zip_code_lon,
  dropoff_zip_code,
  dropoff_zip_code_lat,
  dropoff_zip_code_lon,
  COUNT(*) AS cnt
FROM base_data 
GROUP BY 1,2,3,4,5,6
limit 10000
&quot;&quot;&quot;

agg_df = pd.read_gbq(query=agg_query, dialect='standard', project_id='{여러분들의 프로젝트 id}')

# 100개만
agg_df = agg_df.sort_values('cnt', ascending=False)
agg_df = agg_df[:100]


arc_layer = pdk.Layer(
    'ArcLayer',
    agg_df,
    get_source_position='[pickup_zip_code_lon, pickup_zip_code_lat]',
    get_target_position='[dropoff_zip_code_lon, dropoff_zip_code_lat]',
    get_source_color='[255, 255, 120]', 
    get_target_color='[255, 0, 0]',
    width_units='meters',
    get_width=&quot;cnt/50&quot;,
    pickable=True, 
    auto_highlight=True,
)

nyc_center = [-73.9808, 40.7648] 
view_state = pdk.ViewState(longitude=nyc_center[0], latitude=nyc_center[1], zoom=9)

r = pdk.Deck(layers=[arc_layer], initial_view_state=view_state,
             tooltip={
                 'html': '&amp;lt;b&amp;gt;count:&amp;lt;/b&amp;gt; {cnt}',
                 'style': {
                     'color': 'white'
                 }
             }
            )
r.show()

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;width_units&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;get_width&lt;/code&gt; 쪽이 문서나 참고 자료가 거의 없어서 이것 저것 시도함&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/4zqgyd88jc13z5d/Screenshot%202019-11-24%2018.34.08.png?raw=1&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;ipywidgets을 사용한 요일별 Arc Layer&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;agg_query2 = &quot;&quot;&quot;
WITH base_data AS 
(
  SELECT 
    nyc_taxi.*, 
    pickup.zip_code as pickup_zip_code,
    pickup.internal_point_lat as pickup_zip_code_lat,
    pickup.internal_point_lon as pickup_zip_code_lon,
    dropoff.zip_code as dropoff_zip_code,
    dropoff.internal_point_lat as dropoff_zip_code_lat,
    dropoff.internal_point_lon as dropoff_zip_code_lon
  FROM (
    SELECT *
    FROM `bigquery-public-data.new_york_taxi_trips.tlc_yellow_trips_2015`
    WHERE 
        EXTRACT(MONTH from pickup_datetime) = 1
        and pickup_latitude &amp;lt;= 90 and pickup_latitude &amp;gt;= -90
        and dropoff_latitude &amp;lt;= 90 and dropoff_latitude &amp;gt;= -90
    LIMIT 100000
    ) AS nyc_taxi
  JOIN (
    SELECT zip_code, state_code, state_name, city, county, zip_code_geom, internal_point_lat, internal_point_lon 
    FROM `bigquery-public-data.geo_us_boundaries.zip_codes`
    WHERE state_code='NY'
    ) AS pickup 
  ON ST_CONTAINS(pickup.zip_code_geom, st_geogpoint(pickup_longitude, pickup_latitude))
  JOIN (
    SELECT zip_code, state_code, state_name, city, county, zip_code_geom, internal_point_lat, internal_point_lon 
    FROM `bigquery-public-data.geo_us_boundaries.zip_codes`
    WHERE state_code='NY' 
    ) AS dropoff
  ON ST_CONTAINS(dropoff.zip_code_geom, st_geogpoint(dropoff_longitude, dropoff_latitude))
  
)

SELECT 
  CAST(format_datetime('%u', pickup_datetime) AS INT64) -1 AS weekday,
  pickup_zip_code,
  pickup_zip_code_lat,
  pickup_zip_code_lon,
  dropoff_zip_code,
  dropoff_zip_code_lat,
  dropoff_zip_code_lon,
  COUNT(*) AS cnt
FROM base_data 
GROUP BY 1,2,3,4,5,6,7
&quot;&quot;&quot;

agg_df2 = pd.read_gbq(query=agg_query2, dialect='standard', project_id='geultto')


default_data = agg_df2[agg_df2['weekday'] == 0].to_dict(orient='records')

arc_layer = pdk.Layer(
    'ArcLayer',
    default_data,
    get_source_position='[pickup_zip_code_lon, pickup_zip_code_lat]',
    get_target_position='[dropoff_zip_code_lon, dropoff_zip_code_lat]',
    get_source_color='[255, 255, 120]', 
    get_target_color='[255, 0, 0]',
    width_units='meters',
    get_width=&quot;cnt/50&quot;,
    pickable=True, 
    auto_highlight=True,
)

nyc_center = [-73.9808, 40.7648] 
view_state = pdk.ViewState(longitude=nyc_center[0], latitude=nyc_center[1], zoom=9)

r = pdk.Deck(layers=[arc_layer], initial_view_state=view_state,
             tooltip={
                 'html': '&amp;lt;b&amp;gt;count:&amp;lt;/b&amp;gt; {cnt}',
                 'style': {
                     'color': 'white'
                 }
             }
            )
r.show()


# Widget 슬라이더 생성
import ipywidgets as widgets
from IPython.display import display
slider = widgets.IntSlider(0, min=0, max=6, step=1)

# Widget에서 사용할 함수 정의 
def on_change(v):
    results = agg_df2[agg_df2['weekday'] == slider.value].to_dict(orient='records')
    arc_layer.data = results
    r.update()

# Deck과 슬라이더 연결
slider.observe(on_change, names='value')
display(slider)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/hf6u5pz2g8989zc/Screenshot%202019-11-24%2018.47.18.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;keplergl-vs-deckgl&quot;&gt;Kepler.gl vs Deck.gl&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Kepler.gl은 &lt;a href=&quot;https://zzsza.github.io/data/2019/04/01/uber-keplergl/&quot;&gt;블로그&lt;/a&gt;에 써둔 것처럼 매우 사용하기 쉬움
    &lt;ul&gt;
      &lt;li&gt;단, 대용량 데이터 시각화 하면 크롬이 refresh&lt;/li&gt;
      &lt;li&gt;결국 deck.gl 기반으로 만들어진 도구&lt;/li&gt;
      &lt;li&gt;사용은 쉽지만 쿼리를 날려서 csv 저장하고 웹에 올려야되는 불편함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Deck.gl은 약간의 코딩이 필요(그래도 Python으로 가능하면 양호한 편이라 생각)
    &lt;ul&gt;
      &lt;li&gt;대용량 데이터도 나름 잘 되는 편&lt;/li&gt;
      &lt;li&gt;노트북에서 한번에 다 뽑아낼 수 있는 장점&lt;/li&gt;
      &lt;li&gt;하지만 적응하기 까지 약간의 시간이 필요하고, 개발 진행중이라 계속 바뀔 가능성이 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;결국 목적에 맞도록 적절하게 사용하면 좋을 것 같아요 :)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://deck.gl&quot;&gt;Deck.gl Homepage&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://deck.gl/#/documentation/deckgl-api-reference/layers/overview&quot;&gt;Layer Document&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/vis-gl/pydeck-unlocking-deck-gl-for-use-in-python-ce891532f986&quot;&gt;pydeck: Unlocking deck.gl for use in Python&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://deckgl.readthedocs.io/en/latest/&quot;&gt;pydeck document&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/uber/deck.gl/tree/master/bindings/pydeck/examples&quot;&gt;pydeck example&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://dailyheumsi.tistory.com/147&quot;&gt;전시흠님 블로그&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 24 Nov 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/2019/11/24/pydeck/</link>
        <guid isPermaLink="true">http://localhost:4000/data/2019/11/24/pydeck/</guid>
        
        <category>mobility</category>
        
        
        <category>data</category>
        
      </item>
    
      <item>
        <title>Gaining Insights in a Simulated Marketplace with Machine Learning at Uber 번역</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Uber Tech blog의 &lt;a href=&quot;https://eng.uber.com/simulated-marketplace/&quot;&gt;Gaining Insights in a Simulated Marketplace with Machine Learning at Uber&lt;/a&gt; 번역 &amp;amp; 정리입니다&lt;/li&gt;
  &lt;li&gt;개인 학습 목적으로 번역했으며, 오역이나 의역이 있을 수 있습니다 :)
    &lt;ul&gt;
      &lt;li&gt;글을 보다 내용과 관련된 링크를 찾아 추가한 부분도 있습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Uber에선 Marketplace 알고리즘을 사용해 드라이버와 라이더를 연결함
    &lt;ul&gt;
      &lt;li&gt;알고리즘이 전 세계적으로 출시되기 전에 Uber는 알고리즘을 완벽하게 테스트하고 평가해 핵심 &lt;a href=&quot;https://marketplace.uber.com/&quot;&gt;Marketplace&lt;/a&gt; 원칙에 맞는 최적의 사용자 경험을 만듬&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Uber Marketplace Simulation팀은 제품 테스트를 더욱 안전하고 쉽게 실행할 수 있도록 현실 세계에 있을 상황을 모방한 driver와 rider을 시뮬레이션할 수 있는 플랫폼을 구축
    &lt;ul&gt;
      &lt;li&gt;Uber marketplace 엔지니어와 데이터 과학자는 에이전트 기반의 discrete event 시뮬레이터를 활용해 리스크가 없는 환경에서 새로운 기능과 가설을 신속하게 프로토 타이핑하고 테스트할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시뮬레이터는 이력(historical) 데이터를 활용해 marketplace 서비스 및 사용자 행동 모델(user behavior model)을 만듬
    &lt;ul&gt;
      &lt;li&gt;Marketplace 서비스는 이런 인사이트를 활용해 Dispatch 결정을 내림&lt;/li&gt;
      &lt;li&gt;사용자 행동 모델은 simulation context를 사용해 trip 취소나 navigation 선택 같은 rider와 driver의 행동을 결정함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Uber Marketplace Simulation팀은 모델 배포와 학습을 더 쉽고 정확하게 할 수 있도록 시뮬레이션 플랫폼에서 모델을 완벽하게 빌드하고, 학습, serving할 수 있는 머신러닝 프레임워크를 구축함
    &lt;ul&gt;
      &lt;li&gt;ML은 시뮬레이션 정확도와 현실성을 향상시키기 때문에 시뮬레이션 플랫폼에서 사용자 행동을 예측할 때 중요한 역할을 함&lt;/li&gt;
      &lt;li&gt;실제로 플랫폼에서 가장 시뮬레이션된 사용자 행동은 모델 기반이며 집계된 과거의 익명 데이터로 훈련됨&lt;/li&gt;
      &lt;li&gt;시뮬레이션은 ML 모델 개발 및 개선에도 도움이 됨&lt;/li&gt;
      &lt;li&gt;새로운 모델은 시뮬레이션 플랫폼에 탑재되어 실제 서비스에 적용되기 전에 신속하게 반복할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ML 모델 학습 프레임워크를 설계해 사용자가 시뮬레이션 플랫폼에서 모델을 신속하게 빌드, 배포하고 시뮬레이션을 통해 ML 모델을 개선할 수 있도록 함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;simulation-platform-machine-learning-framework&quot;&gt;Simulation platform machine learning framework&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ML은 시뮬레이션 플랫폼에서 점점 중요한 기능의 핵심에 있음
    &lt;ul&gt;
      &lt;li&gt;ML 프레임워크를 시뮬레이션 플랫폼에 도입하기 전에 ML 개발, 학습, serving은 주로 재사용할 수 없는 임시 솔루션(ad-hoc)으로 구성됨&lt;/li&gt;
      &lt;li&gt;예를 들어 ML 개발자는 시뮬레이터에서 ML 모델을 직접 구현하고 시뮬레이터가 실행될 때 모델을 학습함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이런 일회성 솔루션은 개발자가 여러 모델을 구현하고 모델 버전을 추가하며 시뮬레이터 내에서 복잡성을 누적시킴
    &lt;ul&gt;
      &lt;li&gt;시뮬레이터를 유지 관리하기 어려워졌고, 모델을 학습하기 위해 많은 RAM과 CPU를 사용해 시뮬레이터 성능이 저하됨&lt;/li&gt;
      &lt;li&gt;이런 유형의 시나리오에선 custom top-to-bottom 학습과 serving 코드를 커스텀한 top-to-bottom에 가질 수 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시뮬레이션 팀은 시뮬레이션 플랫폼에서 실행되는 대부분의 ML 학습, workload를 효율적으로 재사용 가능한 단일 프레임워크를 만듬. 프레임워크는 오픈소스와 우버에서 만든 컴포넌트들을 섞어 만들었음. 4개의 레이어에서 작동함&lt;/li&gt;
  &lt;li&gt;Layer
    &lt;ul&gt;
      &lt;li&gt;시뮬레이션 플랫폼에서 ML 모델을 구성하는 API 및 module을 구성하는 ML 라이브러리&lt;/li&gt;
      &lt;li&gt;모델을 학습하고 binary 파일로 저장하는 자동 학습 파이프라인&lt;/li&gt;
      &lt;li&gt;모든 모델의 메타데이터를 관리하는 백엔드 시스템&lt;/li&gt;
      &lt;li&gt;선택한 모델을 시뮬레이션에 load하는 시뮬레이터의 중앙 모듈&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시뮬레이션 ML 프레임워크 학습 workflow에서 학습 파이프라인은 ML 라이브러리를 가져오고 Apaceh Spark를 사용해 Apache Hive의 데이터를 가져오고 처리하고 과거 시계열 데이터를 기반으로 모델을 자동으로 학습함
    &lt;ul&gt;
      &lt;li&gt;파이프라인이 학습이 끝나면, 시뮬레이션 데이터베이스 및 checkpoint model instance가 생성됨. 그 후, Uber의 storage service에 binary file로 저장됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시뮬레이션 백엔드 서비스는 시뮬레이션 생성 요청을 받으면 유저의 셋팅을 기반으로 관련 ML 모델의 메타 데이터를 사용해 모델 checkpoint를 local disk로 저장함
    &lt;ul&gt;
      &lt;li&gt;그 후, 시뮬레이션 백엔드 서비스는 model factory가 있는 시뮬레이터를 실행함&lt;/li&gt;
      &lt;li&gt;그 후, 모델 팩토리는 Python ML 라이브러리를 가져와 로컬 디스크에서 checkpoint를 스캔해 관련 모델을 인스턴스화하고, 인스턴스를 시뮬레이션 core flow로 출력함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ML 프레임워크의 Train / Serving Workflow
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/znokglqgothuitb/Screenshot%202019-11-01%2022.02.11.png?raw=1&quot; /&gt;
        &lt;ul&gt;
          &lt;li&gt;그림 1. Automatic Training Pieplein(가운데)은 Spark(위)를 사용해 Hive에서 raw 데이터를 가져오고 simulation ML 모델(왼쪽)을 사용해 Storage 서비스(오른쪽) 및 SImulation Database(아래)에 데이터를 저장함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/8jbl93mxdcn2ioa/Screenshot%202019-11-01%2022.05.02.png?raw=1&quot; /&gt;
        &lt;ul&gt;
          &lt;li&gt;그림 2. 시뮬레이션을 생성하기 위해 먼저 시뮬레이션 request를 보냄(왼쪽 상단) 그 후 백엔드 서비스 모델 메타 데이터를 가져와 데이터베이스에 입력함. 그 후, 데이터베이스는 메타 데이터를 기반으로 checkpoint를 저장소에서 가져오고 디스크로 다운로드함. 그 후, checkpoint는 시뮬레이텨에서 Simulation ML Model(상단)과 결합해 Model Factory가 모델을 인스턴스화함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 프레임워크은 Training과 Serving workflow를 분리함
    &lt;ul&gt;
      &lt;li&gt;이 변화는 개발자가 지속적으로 모델을 개선시킬 때 필요한 유연한 모델을 제공함&lt;/li&gt;
      &lt;li&gt;이 시스템에서 개발자가 사용자 행동 모델을 변경하려면 Python ML 라이브러리에서 구현물을 업데이트하면 됨&lt;/li&gt;
      &lt;li&gt;그 다음 자동으로 train 파이프라인을 트리거하고 최신 모델을 모든 시뮬레이터에 추가함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시뮬레이터에서 Training workflow를 제거해 시뮬레이터의 복잡성을 단순화해 RAM, CPU 사용량을 크게 개선함
    &lt;ul&gt;
      &lt;li&gt;이 변경은 또한 시뮬레이터의 처리량을 증가시킴&lt;/li&gt;
      &lt;li&gt;이런 간소화가 하드웨어 리소스를 보존하고 시스템의 효율성을 향상시킴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Marketplace Simulation 팀은 이 프레임워크를 사용해 표준화된 방식으로 여러 사용자 행동 및 기타 ML 모델을 시뮬레이션 플랫폼에 통합함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;how-supply-movement-models-improve-marketplace-simulation&quot;&gt;How supply movement models improve marketplace simulation&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://dl.acm.org/citation.cfm?id=3186924&quot;&gt;최근 연구&lt;/a&gt;에서 제안한 것처럼 ride-sharing 시물레이션에서 운전자의 움직임은 시뮬레이션의 정확도와 리얼리즘에 중요한 factor임
    &lt;ul&gt;
      &lt;li&gt;시뮬레이션 플랫폼에서 실험적인 marketplace 알고리즘은 실제 결과와 다른 결과를 가져옴&lt;/li&gt;
      &lt;li&gt;예를 들어 시뮬레이션의 드라이버는 현실과 다른 rider와 매칭될 수 있음&lt;/li&gt;
      &lt;li&gt;이 경우에 시뮬레이터는 경로, 주행 시간 및 하차 위치를 시뮬레이션하기 위해 historical driver 이동 데이터를 재사용할 수 없음&lt;/li&gt;
      &lt;li&gt;이 문제를 해결하기 위해 운전자의 움직임을 정확하게 시뮬레이션하는 모델을 구축해야 했음&lt;/li&gt;
      &lt;li&gt;적절한 movement 모델을 사용하면 라이더 행동 모델(예 : 라이더 취소 모델)을 향상시키고 매칭 및 가격 알고리즘에서 노이즈를 줄일 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시뮬레이션 된 세계는 제한된 과거 데이터에서 실행되고 교통 정보, 날씨, 지리적 데이터와 같이 사용자 행동에 영향을 줄 수 있는 많은 요소가 없기 때문에 운전자의 움직임을 정확하게 시뮬레이션하는 것은 매우 어려운 작업임&lt;/li&gt;
  &lt;li&gt;다행히 대부분의 marketplace 알고리즘에서 단일 운전자의 움직임은 알고리즘 결과에 큰 영향을 미치지 않음
    &lt;ul&gt;
      &lt;li&gt;이런 알고리즘들은 특히 rider-driver 매칭이나 가격 알고리즘들은 개별 운전자의 움직임보다 집계된(aggregated) 드라이버 분포를 활용함&lt;/li&gt;
      &lt;li&gt;이런 이유로 모든 운전자의 움직임을 완벽하게 시뮬레이션하지 않고 운전자 분포를 정확하게 시뮬레이션하는 모델을 구축함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시뮬레이션된 세계에서 목표를 달성하기 위해 online driver movement 동작을 on-trip과 off-trip으로 나눔
    &lt;ul&gt;
      &lt;li&gt;2가지 state에서 다른 드라이버 행동을 예측하는 하이브리드 모델을 만들어 uber의 marketplace 수요를 더 잘 예측함&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/zcz866zxap94e0v/Screenshot%202019-11-01%2022.26.54.png?raw=1&quot; /&gt;
        &lt;ul&gt;
          &lt;li&gt;그림 3. Driver movement 하이브리드 모델은 시뮬레이션하는 운전자 요청으로 시작해 예/아니오 분기를 통해 결론에 도달하고, 운전자 정보를 라우팅 엔진에 보내고, route를 통해 speed와 이동을 측정함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;On-trip 드라이버를 위한 룰 베이스 모델을 적용함
    &lt;ul&gt;
      &lt;li&gt;시뮬레이션된 driver과 trip을 수락하면 모델은 라우팅 엔진을 사용해 경로를 따라 운전자를 미리 정해진 목적지로 안내함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Off-trip 드라이버 분포를 시뮬레이션하는 것은 매우 어려움
    &lt;ul&gt;
      &lt;li&gt;전에 언급한 것처럼, 시뮬레이션된 세상이 historical driver movement를 재현할 수 없음&lt;/li&gt;
      &lt;li&gt;이런 이유로 ML 모델을 사용해 집계된 off-trip 드라이버의 이동을 예측함&lt;/li&gt;
      &lt;li&gt;생산적인 알고리즘을 사용해 이 모델은 드라이버 분포를 과거 분포에 가깝게 시뮬레이션함&lt;/li&gt;
      &lt;li&gt;Off-trip 드라이버 분포를 정확하게 시뮬레이션하는 목표를 달성하기 위해 트리 기반 확률 모델을 훈련함&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/5l3worskp69xsfb/Screenshot%202019-11-01%2022.33.22.png?raw=1&quot; /&gt;
        &lt;ul&gt;
          &lt;li&gt;그림 4. off-trip 드라이버 분포 시뮬레이션을 위한 stochastic 모델의 decision tree 중 하나&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시뮬레이션은 off-trip 드라이버의 목적지를 예측하려고 할 때, 그림 4와 같이 드라이버 정보(위치, 타임스탬프 등)를 사용해 Tree 모델에서 관련된 리프 노드를 가져옴
    &lt;ul&gt;
      &lt;li&gt;리프 노드에는 전이 행렬(transition)이 포함됨
        &lt;ul&gt;
          &lt;li&gt;시뮬레이션된 운전자의 미래 움직임을 예측하는 매트릭스&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;시뮬레이션 플랫폼에서 육각형 계층적 공간 인덱스인 H3을 사용해 지구의 영역을 식별 가능한 그리드 셀로 분할함&lt;/li&gt;
      &lt;li&gt;이런 식별 가능한 그리드 셀을 사용해 아래 그림 5와 같이 전이 매트릭스를 정의함&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/mh3ypx5lup07qfn/Screenshot%202019-11-01%2022.35.52.png?raw=1&quot; /&gt;
        &lt;ul&gt;
          &lt;li&gt;그림 5. 이 표는 지구상의 위치를 나타내는 다양한 그리드 셀의 확률값을 보여줌&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Transition 행렬의 값은 드라이버가 현재 그리드 셀 X에 있는 경우 드라이버가 그리드 셀 Y로 이동할 확률을 나타냄&lt;/li&gt;
  &lt;li&gt;이런 transition matrix를 사용해 시뮬레이션은 open 드라이버가 다음 셀로 이동할 가능성이 있는 셀을 예측할 수 있음
    &lt;ul&gt;
      &lt;li&gt;그런 다음 시뮬레이션은 해당 셀 내부의 위치를 임의로 선택해 open 드라이버의 목적지로 할당함. 아래 그림 6은 이 프로세스를 보여줌&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/42tmanj53f7y3rx/Screenshot%202019-11-01%2022.39.13.png?raw=1&quot; /&gt;
        &lt;ul&gt;
          &lt;li&gt;그림 6. 이 Flow 차트는 리프 노드에서 시작하고 맵을 사용해 식별 가능한 그리드 셀을 가져와 드라이버를 찾음. 시뮬레이션이 전이 행렬로 드라이버 이동 확률을 계산하는 방법을 보여줌(좌측 밑) 시뮬레이션에서 운전자의 목적지 위치를 선택하는 방법을 우측 지도에서 보여줌. 운전자 대상을 예측하기 위한 트리 기반 확률 모델임&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시뮬레이터가 open driver의 목적지를 예측하면 운전자의 경로와 속도를 추정한 다음 운전자를 목적지로 옮김
    &lt;ul&gt;
      &lt;li&gt;on-trip 및 off-trip 드라이버의 주요 차이점은 open 드라이버가 목적지로 운전하는 동안 상태를 변경할 수 있음(offline/dispatchied)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Marketplace Simualtion Platform은 하이브리드 driver movement 모델을 사용해 실제 운전자 분포를 정확하게 근사함
    &lt;ul&gt;
      &lt;li&gt;동일한 알고리즘을 사용해 분포를 실제 분포와 비교했음. 아래 그림 7은 피크 시간 드라이버의 분포를 보여줌&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/uozqc6xi5tdtcx8/Screenshot%202019-11-01%2022.42.21.png?raw=1&quot; /&gt;
        &lt;ul&gt;
          &lt;li&gt;그림 7. 왼쪽 지도는 실제 세계에서 운전자가 분포하는 영역이고, 오른쪽 지도는 시뮬레이션 결과. 근접함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;how-simulation-helps-us-experiment-with-matching-algorithms&quot;&gt;How simulation helps us experiment with matching algorithms&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Uber 플랫폼은 ETA, Routing, 사용자 위치, trip 선호도 및 가격을 포함한 다양한 요소에 최적화된 매칭 알고리즘을 사용해 rider와 driver를 실시간으로 연결함&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://arxiv.org/pdf/1302.6666.pdf&quot;&gt;최근 연구&lt;/a&gt;와 &lt;a href=&quot;http://www.columbia.edu/~cs2035/courses/ieor4405.S17/p14.pdf&quot;&gt;강의 자료&lt;/a&gt;에 따르면 ride-sharing 프로그램은 종종 large-scale 조합 알고리즘을 사용해 사용자 매칭을 최적화함
    &lt;ul&gt;
      &lt;li&gt;그러나 사업을 다양화하며, 이 알고리즘은 더 많은 요소를 고려해야 함&lt;/li&gt;
      &lt;li&gt;점점 더 복잡해지는 매칭을 수용하기 위해 머신러닝 모델을 최적화 알고리즘에 통합해 시뮬레이션 처리량을 높임&lt;/li&gt;
      &lt;li&gt;추천 시스템과 maximum bipartite matching을 조합함&lt;/li&gt;
      &lt;li&gt;아래 그림 8에 전체 workflow가 나옴&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/6gcv6qh2r8okymj/Screenshot%202019-11-01%2022.49.57.png?raw=1&quot; /&gt;
        &lt;ul&gt;
          &lt;li&gt;그림 8. 상단 절반은 추천 시스템을 나타내며 몇 단계를 거쳐 드라이버를 좁히고 순위를 매김. 추천 시스템의 순서는 각 라이더에 대해 모든 드라이버를 찾고, 드라이버 옵션을 수백으로 좁히고, 링크 생성, 드라이버 옵션을 수십으로 좁히고 10보다 적을 경우 순위를 매김. 이 프로세스가 완료되면 화살표는 권장 사항이 일치 단계로 이동함. 처음에 이 알고리즘은 여러 라이더를 단일 드라이버에 연결할 수 있지만 maximum bipartite 매칭 알고리즘을 사용해 개별 드라이버와 단일 라이더를 페어링함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;매칭 솔루션에서 추천 시스템은 각 pari의 점수를 가진 라이더당 몇 명의 드라이버를 제안함
    &lt;ul&gt;
      &lt;li&gt;추천 결과를 기반으로 가중치가 있는 bipartite graph를 만듬&lt;/li&gt;
      &lt;li&gt;이 그래프는 한 명의 rider와 한 명의 driver를 매칭시킴&lt;/li&gt;
      &lt;li&gt;이 문제를 효율적으로 해결하기 위해 maximum bipartite matching algorithm을 사용함&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://kks227.blog.me/220807541506&quot;&gt;이분 매칭(Bipartite Matching)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;rider와 driver 위치만 사용해 추천 시스템을 개발하는 것은 어려운 일임
    &lt;ul&gt;
      &lt;li&gt;다른 맥락이 없으면 feature의 부족으로 협업 필터링, Factorization 머신, 딥 뉴럴넷을 사용하기 어려움&lt;/li&gt;
      &lt;li&gt;이 문제를 해결하기 위해 대규모 소셜 네트워크 추천을 살펴봄
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1709.05584&quot;&gt;Representation Learning on Graphs: Methods and Applications&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://link.springer.com/chapter/10.1007/978-3-642-37658-0_6&quot;&gt;Parallel Clustered Low-Rank Approximation of Graphs and Its Application to Link Prediction&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://www.sciencedirect.com/science/article/pii/S0167739X17319684&quot;&gt;Recommender Systems for Large-Scale Social Networks: A review of challenges and solutions&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;종합적인 연구를 한 후, 소셜 네트워크에서 구현된 솔루션을 사용해 추천 시스템을 만들기로 결정함
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://arxiv.org/abs/1709.05584&quot;&gt;Representation Learning on Graphs: Methods and Applications&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://dl.acm.org/citation.cfm?id=956972&quot;&gt;The link prediction problem for social networks&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;그림 8에 표시된 것처럼 rider와 driver 위치를 기준으로 꼭지점을 갖는 그래프를 구성함&lt;/li&gt;
      &lt;li&gt;운전자 ETA나 rider와 driver 사이의 거리 같은 규칙 기반 제약 조건을 사용해 그래프의 Edge를 생성함&lt;/li&gt;
      &lt;li&gt;시뮬레이터가 그래프를 구성한 후, historical dispatch 결과를 기반으로 각 edge의 점수를 예측할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그러나 각 node와 edg에 대한 정보는 위치와 경로만 포함하기 때문에 매우 제한적인 정보를 가지고 있음
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://snap.stanford.edu/graphsage/#motivation&quot;&gt;GraphceSAGE&lt;/a&gt;와 같은 graph representation learning 방법에 영감을 받아, 아래 그림 9와 같이 이웃에서 정보를 집계해 각 node에 충분한 feature를 추출함&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/k0tf4fo8roe8hc1/Screenshot%202019-11-01%2023.05.28.png?raw=1&quot; /&gt;
        &lt;ul&gt;
          &lt;li&gt;그림 9. rider node의 외부 원은 이웃의 집계된 feature 정보를 사용해 더 작은 원 내의 rider node를 driver node로 이동시킴. 그런 다음 다시 집계되어 하나의 rider node로 좁아짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이런 Feature는 각 노드에 대한 근처 네트워크 구조 정보를 반영함
    &lt;ul&gt;
      &lt;li&gt;또한 continuouse feature를 normalized하고 모델을 일반화하기 위해 feature vector에 임베딩함&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45530.pdf&quot;&gt;Deep Neural Networks for YouTube Recommendations&lt;/a&gt;를 모방함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;결국 각 쌍의 점수를 예측하기 위해 정착한 모델은 &lt;a href=&quot;https://arxiv.org/abs/1505.01866&quot;&gt;DART : Gradient Boosting Tree with dropouts&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;학습 데이터의 상당 부분에서 음수 쌍(driver와 rider가 일치하지 않음)이 발생하기 때문에 모델을 훈련하기 전에 음수 상을 다운 샘플링하고 양수 쌍(driver와 rider가 일치한)을 샘플링함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모델을 학습한 후, 모델을 사용해 각 쌍의 점수를 기준으로 각 rider의 top-k potential driver를 예측함
    &lt;ul&gt;
      &lt;li&gt;이 경우 예측 결과에 따르면, 각 rider는 여러 driver와 연결되며, driver는 여러 rider와 연결될 수 있음&lt;/li&gt;
      &lt;li&gt;그런 다음 링크를 기반으로 bipartite graph를 구성하고 maximum bipartite matching algorithm을 적용해 bipartite matching 문제를 해결하고 최소 평균 드라이버 ETA를 달성함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;moving-forward&quot;&gt;Moving forward&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ML 프레임워크를 사용해 ML 모델을 시뮬레이션 플랫폼에 점진적으로 통합해 시뮬레이션에서 더 많은 사용자 행동과 실험적인 marketplace 알고리즘, 기능을 테스트할 수 있음
    &lt;ul&gt;
      &lt;li&gt;이 시스템은 Uber가 개발 프로세스를 가속화하고 안전하고 안정적인 transportation product를 제공할 수 있도록 도와줌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;앞으로는 다음 기능을 통해 시뮬레이션 ML 프레임워크를 향상시킬 계획
    &lt;ul&gt;
      &lt;li&gt;Hyperparameter automatic tuning
        &lt;ul&gt;
          &lt;li&gt;ML 모델에는 learning rate, tree depth 같은 많은 하이퍼 파라미터가 포함됨&lt;/li&gt;
          &lt;li&gt;이런 하이퍼 파라미터를 조정하면 시간이 많이 걸리고 오류가 발생하기 쉬움&lt;/li&gt;
          &lt;li&gt;하이퍼 파라미터 튜닝 툴을 모델 학습 파이프라인에 통합해 모델 개발자의 생산성을 높이고 엔지니어의 작업을 더 쉽게 만들 계획&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Online model performance monitoring
        &lt;ul&gt;
          &lt;li&gt;시뮬레이션 플랫폼의 대부분 ML 모델은 시간 및 위치와 같은 환경적 요인에 직접 영향을 받음&lt;/li&gt;
          &lt;li&gt;시간이 지나며 시뮬레이션의 환경(예 : 교통 패턴)이 변경되므로 모델 성능이 저하됨&lt;/li&gt;
          &lt;li&gt;이런 변화에도 모델을 정확하게 유지하려면 새로운 데이터로 모델을 재학습해야 함&lt;/li&gt;
          &lt;li&gt;온라인 모델 성능 모니터링 시스템은 model serving 퍼포먼스를 모니터링하고 성능이 특정 임계값보다 낮아지면 학습 파이프라인을 트리거할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Distributed machine learning serving
        &lt;ul&gt;
          &lt;li&gt;Uber의 엔지니어는 더 많은 ML 모델을 시뮬레이션 플랫폼에 통합하고 있음&lt;/li&gt;
          &lt;li&gt;현재 프레임워크에는 컴퓨팅 리소스 부족이 발생해 예측 대기 시간(latency for predictions)이 크게 증가함&lt;/li&gt;
          &lt;li&gt;따라서 시뮬레이션 처리량이 악화됨&lt;/li&gt;
          &lt;li&gt;고성능 분산 ML 서비스가 이 문제를 해결할 때 도움이 될 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Configurable machine learning model development
        &lt;ul&gt;
          &lt;li&gt;시뮬레이션 플랫폼의 대부분 ML 모델은 Data processing logic 및 기본 머신러닝 알고리즘과 같은 공통 component를 공유함&lt;/li&gt;
          &lt;li&gt;대부분의 사용자를 위해 모델 개발 프로세스를 단순화하기 위해 configurations driven model 개발 프레임워크를 만들 예정&lt;/li&gt;
          &lt;li&gt;Input config를 기반으로 모델을 구성할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 01 Nov 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/2019/11/01/simulated_marketplace_uber/</link>
        <guid isPermaLink="true">http://localhost:4000/data/2019/11/01/simulated_marketplace_uber/</guid>
        
        <category>mobility</category>
        
        <category>simulation</category>
        
        
        <category>data</category>
        
      </item>
    
      <item>
        <title>DEVIEW 2019 1일차 후기</title>
        <description>&lt;p&gt;네이버 DEVIEW 2019 1일차 후기입니다 :)&lt;/p&gt;

&lt;h3 id=&quot;키노트&quot;&gt;키노트&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;문재인 대통령님이 오셨음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;외산-클라우드-없이-ai-플랫폼-제공하기-features-training-serving-and-ai-suite&quot;&gt;외산 클라우드 없이 AI 플랫폼 제공하기: features, training, serving, and AI Suite.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;어떻게 설계했는지 위주를 말씀드릴 예정&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://deview.kr/data/deview/2019/presentation/%5B141%5DDeview2019_AiSUITE_1028_1.pdf&quot;&gt;발표 자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;자체 AI 플랫폼이 필요한 이유
    &lt;ul&gt;
      &lt;li&gt;Security&lt;/li&gt;
      &lt;li&gt;Cost
        &lt;ul&gt;
          &lt;li&gt;데이터가 적거나 연산량이 적게 필요하면 클라우드 사용이 유리할 수 있음&lt;/li&gt;
          &lt;li&gt;대용량 데이터 처리를 지속적으로 수행하면 비용 무시하기 어려움&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Demand
        &lt;ul&gt;
          &lt;li&gt;머신러닝 수요가 엄청 늘어남&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이미 존재하는 플랫폼
    &lt;ul&gt;
      &lt;li&gt;분산 저장 플랫폼, Cuve&lt;/li&gt;
      &lt;li&gt;분산 처리 플랫폼 : C3&lt;/li&gt;
      &lt;li&gt;피쳐 엔지니어링 플랫폼은 없음&lt;/li&gt;
      &lt;li&gt;모델 학습 플랫폼 : AiTraining NSML&lt;/li&gt;
      &lt;li&gt;모델 서빙 플랫폼 : Ai Serving Platform&lt;/li&gt;
      &lt;li&gt;AI Suite : End-to-End Platform&lt;/li&gt;
      &lt;li&gt;구글클라우드와 비슷&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;머신러닝 하나 적용하기 위해
    &lt;ul&gt;
      &lt;li&gt;데이터 처리&lt;/li&gt;
      &lt;li&gt;모델 학습&lt;/li&gt;
      &lt;li&gt;서빙 : 성능 평가와 용량 산정 후 서비스로 제공&lt;/li&gt;
      &lt;li&gt;데이터를 가져와서 인프라 만들고, 비즈니스에 적용하는 시간이 오래 걸림&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;AiFeatures
    &lt;ul&gt;
      &lt;li&gt;웹브라우저로 카테고리처럼 어떤 데이터가 있는지 볼 수 있음&lt;/li&gt;
      &lt;li&gt;DUMP : 데이터를 어딘가로 가져와서&lt;/li&gt;
      &lt;li&gt;ANALYZE : 잘못된, biased 데이터 없나 보고, 간단한 가시화로 데이터에 대한 인사이트를 얻고&lt;/li&gt;
      &lt;li&gt;BATCH : 잘못된 데이터는 버리고, 나머지는 가공해서 피쳐벡터를 만듬&lt;/li&gt;
      &lt;li&gt;AiFeatures 아키텍쳐
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/cg72zq2pyooh9om/Screenshot%202019-10-28%2011.52.14.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;Facets 씀&lt;/li&gt;
          &lt;li&gt;참고 : &lt;a href=&quot;https://nbviewer.jupyter.org/github/zzsza/TIL/blob/master/Tensorflow-Extended/TFDV%28data%20validation%29%20example.ipynb&quot;&gt;https://nbviewer.jupyter.org/github/zzsza/TIL/blob/master/Tensorflow-Extended/TFDV(data validation) example.ipynb&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Facets 사용할 때 샘플링, HDFS를 위해 일정 부분 읽어서 전체 추론&lt;/li&gt;
      &lt;li&gt;NLP 라이브러리를 API화시킴. 웹 서버가 Rest API로 요청하고, nginx로 쓰로틀링하고 pyspark는 쓰로틀링 프록시로 다 보냄
  	- pyspark로 딕셔너리 물고 하는 것들을 할 수 있음
  	- UDF 만들어서 해결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;머신러닝 모델 학습
    &lt;ul&gt;
      &lt;li&gt;모델 연구시
        &lt;ul&gt;
          &lt;li&gt;빨리 학습하고 평가하는 과정을 반복&lt;/li&gt;
          &lt;li&gt;모델과 파라미터를 빨리 얻는 것이 목적&lt;/li&gt;
          &lt;li&gt;데이터는 고정되므로 캐싱하면 이득&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;제품화 시
        &lt;ul&gt;
          &lt;li&gt;학습에 걸리는 시간을 이미 알고있음. 다음 갱신 전까지만 완료되면 되기 됨. 일정 시간 내에 최소 자원을 쓰면 좋음&lt;/li&gt;
          &lt;li&gt;배포 전에 이전 버전의 모델과 품질을 검증할 필요가 있음&lt;/li&gt;
          &lt;li&gt;켄진타우? 헤밍 디스턴스 알고리즘처럼 얼마나 서로 다른가&lt;/li&gt;
          &lt;li&gt;매번 새로운 떼이터로 학습하는 경우가 많아 데이터 캐싱 이득이 없음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;학습 자동화
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/8gtt5ioqnvxdjbg/Screenshot%202019-10-28%2011.55.28.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서빙 아키텍쳐
    &lt;ul&gt;
      &lt;li&gt;ONNX 형태로 받음 =&amp;gt; Pytorch/Caffe 모두 가능&lt;/li&gt;
      &lt;li&gt;비즈니스 코드 =&amp;gt; 사용자의 코드 =&amp;gt; 뒷단 서버에 요청&lt;/li&gt;
      &lt;li&gt;Yarn 위에서 돌리고 있음&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/2gcm2m9ovy96l9k/Screenshot%202019-10-28%2011.56.49.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;For ML Engine : 내 모델은 여기있고, 이 설정으로 띄워주세요&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/57is3slpicflv2q/Screenshot%202019-10-28%2012.00.35.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모든 단계 자동화하기
    &lt;ul&gt;
      &lt;li&gt;AI-suite&lt;/li&gt;
      &lt;li&gt;Google Dataflow랑 비슷한 느낌? 드래그도 되는 편의성&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/5buno7z4m38qt5a/Screenshot%202019-10-28%2012.03.02.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Batch라는 주석을 하면 프러덕션 레벨의 셀 =&amp;gt; 확장 프로그램을 Run하면 Batch만 파이썬 스크립트를 뽑아서 할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Problem 3. 사용자 작업이 돌고 있는데 AI Suite는 어떻게 업데이트하나?
    &lt;ul&gt;
      &lt;li&gt;전체 컴포넌트는 컨테이너라이징&lt;/li&gt;
      &lt;li&gt;분산 작업 관리는 Celery(Airflow 왜 안썼는지는 부스로..!)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

</description>
        <pubDate>Mon, 28 Oct 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/etc/2019/10/28/deview2019-review/</link>
        <guid isPermaLink="true">http://localhost:4000/etc/2019/10/28/deview2019-review/</guid>
        
        <category>lecture</category>
        
        
        <category>etc</category>
        
      </item>
    
      <item>
        <title>MLOps NYC19 Conference 정리</title>
        <description>&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.mlopsnyc.com/&quot;&gt;MLOps NYC19&lt;/a&gt; 영상을 정리한 글입니다&lt;/li&gt;
  &lt;li&gt;시청한 영상
    &lt;ul&gt;
      &lt;li&gt;MLOps in the Newsroom&lt;/li&gt;
      &lt;li&gt;Netflix Presents: A Human-Friendly Approach to MLOps&lt;/li&gt;
      &lt;li&gt;The Architecture That Powers Twitter’s Feature Store&lt;/li&gt;
      &lt;li&gt;Serverless for ML Pipelines from A to Z&lt;/li&gt;
      &lt;li&gt;Deep Learning on Business Data at Uber&lt;/li&gt;
      &lt;li&gt;The Growth and Future of Kubeflow for ML&lt;/li&gt;
      &lt;li&gt;Stateless ML Pipelines: Achieve reproducibility and automation while simplifying the pipeline&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Training session은 영상이 없지만, &lt;a href=&quot;https://toddmorrill.github.io/blog/2019/10/05/MLOps-tooling&quot;&gt;Review&lt;/a&gt;를 통해 간접적으로 내용을 볼 수 있습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;mlops-in-the-newsroom&quot;&gt;MLOps in the Newsroom&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Information Platforms and the Rise of the Data Scientist(2009)라는 책에선 R / Hadoop을 사용했다고 하는데 NYTimes에선 TF / GCP를 사용함&lt;/li&gt;
  &lt;li&gt;NYTimes의 DS Software Stack
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/yfoecbi8dttrq0r/Screenshot%202019-10-26%2021.03.48.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Deployment at The New York Times
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/4nyham5sw4qsa5n/Screenshot%202019-10-26%2021.04.17.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;뉴스
    &lt;ul&gt;
      &lt;li&gt;20세기엔 church + state였다면&lt;/li&gt;
      &lt;li&gt;21세기엔 church + state + data(데이터가 앞 2가지 요소에 영향을 미침)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모델링
    &lt;ul&gt;
      &lt;li&gt;Descriptive modeling
        &lt;ul&gt;
          &lt;li&gt;Readerscope&lt;/li&gt;
          &lt;li&gt;데이터를 설명하는 패턴을 찾음&lt;/li&gt;
          &lt;li&gt;현재 발생하는 상황에 대해 더 정교하고 실시간 통찰력이 필요했음&lt;/li&gt;
          &lt;li&gt;누가 무엇을 읽고 있는지? 그리고 어디에 있는가?&lt;/li&gt;
          &lt;li&gt;마케터가 drill down으로 LA에서 무슨 일이 있는지 등을 알 수 있음&lt;/li&gt;
          &lt;li&gt;Contextual bandit&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Predictive modeling
        &lt;ul&gt;
          &lt;li&gt;누가 구독할 것인가, 누가 떠날 것인가를 예측(퍼널 단계 단계를 예측)&lt;/li&gt;
          &lt;li&gt;리스크를 위해 성능과 해석 가능성을 중시&lt;/li&gt;
          &lt;li&gt;광고주가 광고할 때 어떤 사람에게 효과가 있는지? 관련있는 context를 제시 =&amp;gt; 우리 광고는 Travel 부분과 digital 세대에 영향을 많이 미칠 것이다 등&lt;/li&gt;
          &lt;li&gt;텍스트 기반해서 Labeling(Inspired, Happiness, Sadness, Love 등)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Prescriptive modeling
        &lt;ul&gt;
          &lt;li&gt;추천을 어떻게 할 것인가&lt;/li&gt;
          &lt;li&gt;톰슨 샘플링 &amp;amp; 밴딧 사용&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;http://modelingsocialdata.org/&quot;&gt;Modeling Social Data&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IDEA
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/bkgiq5exkxlu5ti/Screenshot%202019-10-26%2021.51.26.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;best AI is AI + IRL
        &lt;ul&gt;
          &lt;li&gt;recpect for craft&lt;/li&gt;
          &lt;li&gt;recpect for collaborators&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;netflix-presents-a-human-friendly-approach-to-mlops&quot;&gt;Netflix Presents: A Human-Friendly Approach to MLOps&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;넷플릭스는 출시 전에 매일 프로그램 시청자의 예상 크기(estimated size)를 알고 싶어함&lt;/li&gt;
  &lt;li&gt;The Life of a Model
    &lt;ul&gt;
      &lt;li&gt;EDA
        &lt;ul&gt;
          &lt;li&gt;프로젝트를 잡고, 노트북에서 잡음&lt;/li&gt;
          &lt;li&gt;correlation를 찾고, scatter plot을 그림&lt;/li&gt;
          &lt;li&gt;2주 정도 진행&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Prototyping
        &lt;ul&gt;
          &lt;li&gt;다양한 실험을 하고, Feature 추가, 모델링 등등을 진행&lt;/li&gt;
          &lt;li&gt;6~8주&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Productionalize
        &lt;ul&gt;
          &lt;li&gt;Ship Model to Production(v1)&lt;/li&gt;
          &lt;li&gt;Scale &amp;amp; Deploy&lt;/li&gt;
          &lt;li&gt;ETL / Feature Engineering / Model Traing / Model Hoasting / Batch Scoring / Live Scoring / Audits / Scheduling etc&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Metaflow
    &lt;ul&gt;
      &lt;li&gt;빠른 프로토 타이핑을 위해 만듬&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/m5oyy7p0tihcv7t/Screenshot%202019-10-26%2022.31.05.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;코드의 구조는 next로 다음 행동을 지정할 수 있음
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/4sed61hnbujgaen/Screenshot%202019-10-26%2022.34.40.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/t3vqibm2tldcojc/Screenshot%202019-10-26%2022.35.50.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;프로토타입 할 때 특정 부분만 안되면 resume 명령어로 다시 실행
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ijkufviq5ezc2gs/Screenshot%202019-10-26%2022.37.56.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;컴퓨팅 파워는 titus에게 말하면 됨
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/lfkkt14rwtt2vmn/Screenshot%202019-10-26%2022.39.48.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;분산 처리
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/q84o74li5siiakg/Screenshot%202019-10-26%2022.40.55.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Production 배포시 Meson 사용, meson create
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://medium.com/netflix-techblog/meson-workflow-orchestration-for-netflix-recommendations-fc932625c1d9&quot;&gt;넷플릭스 테크 블로그 : Meson: Workflow Orchestration for Netflix Recommendations&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/acramereyt3w82o/Screenshot%202019-10-26%2022.42.16.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Real time Scoring
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/69zaxl8beh7mlui/Screenshot%202019-10-26%2022.45.04.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;몇달이 지난 후&lt;/li&gt;
  &lt;li&gt;The Life of a Model
    &lt;ul&gt;
      &lt;li&gt;Maintenance
        &lt;ul&gt;
          &lt;li&gt;모델 유지하고 version 2 빌드&lt;/li&gt;
          &lt;li&gt;v1를 안전하게 복사&lt;/li&gt;
          &lt;li&gt;새로운 feature를 추가해 진행&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;inspect &amp;amp; debug
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/7c9bf6kdph8k5y5/Screenshot%202019-10-26%2022.48.50.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pick up &amp;amp; iterate
    &lt;ul&gt;
      &lt;li&gt;다른 사람의 실험도 돌릴 수 있음
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/pazegy5n9i18waw/Screenshot%202019-10-26%2023.39.13.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;태그도 가능
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/wbzhy9xhnzc9uq5/Screenshot%202019-10-26%2023.39.56.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Metaflow at scale
    &lt;ul&gt;
      &lt;li&gt;도입 후 정말 많은 프로젝트가 생기고 있음&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/j1rype7shji2hke/Screenshot%202019-10-26%2023.43.01.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/n4weq63h8p9ryj0/Screenshot%202019-10-26%2023.43.19.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;the-architecture-that-powers-twitters-feature-store&quot;&gt;The Architecture That Powers Twitter’s Feature Store&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;많은 사람들이 모델링하면 겹치는 Feature Engineering이 있음
    &lt;ul&gt;
      &lt;li&gt;이미 많이 진행한 팀, 이제 막 머신러닝을 도입하려는 팀 등&lt;/li&gt;
      &lt;li&gt;이미 진행한 팀꺼를 fork하거나 밑바닥부터 만들 수 있음&lt;/li&gt;
      &lt;li&gt;전사에서 사용할 라이브러리 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Featre Store는 library&lt;/li&gt;
  &lt;li&gt;오.. 트위터껀 아니지만 Gojek이 만든 &lt;a href=&quot;https://github.com/gojek/feast&quot;&gt;feast&lt;/a&gt;가 있음
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://github.com/gojek/feast/raw/master/docs/architecture.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Share
    &lt;ul&gt;
      &lt;li&gt;Feature Catalog&lt;/li&gt;
      &lt;li&gt;Succinct, declarative Definitions&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Datasets
    &lt;ul&gt;
      &lt;li&gt;온라인/오프라인 접근이 가능&lt;/li&gt;
      &lt;li&gt;동영상에서 화질이 너무 낮아 알아보기 힘듬 ㅠ&lt;/li&gt;
      &lt;li&gt;추가할 Feature를 정의&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Offline Integration
    &lt;ul&gt;
      &lt;li&gt;스칼라 사용&lt;/li&gt;
      &lt;li&gt;joinFeatures&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Online Integration
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/5c9shgg9mt5n5br/Screenshot%202019-10-27%2010.54.54.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Feature Store Client
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/7b3pewkkceqg8nj/Screenshot%202019-10-27%2010.55.45.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Strato
    &lt;ul&gt;
      &lt;li&gt;FeatureStore Client에서 Strato로 데이터 보내고, 캐싱하거나 DB에 넣거나 서비스에 쓰거나 하는듯&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ezwfvjwr6gn5uyn/Screenshot%202019-10-27%2010.56.26.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/xyeseqjs45ynx8g/Screenshot%202019-10-27%2010.57.01.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;영상은 10분만에 끝남. 딱히 인상 깊진 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;serverless-for-ml-pipelines-from-a-to-z&quot;&gt;Serverless for ML Pipelines from A to Z&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Code / Model Development is Just the First Step
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/2xny5vio2f6ysz0/Screenshot%202019-10-27%2010.59.00.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파이프라인 예시
    &lt;ul&gt;
      &lt;li&gt;Weather 정보도 추가&lt;/li&gt;
      &lt;li&gt;여기서도 Feature Store란 단어가 나옴&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/klajbcfhxu0ld49/Screenshot%202019-10-27%2010.59.46.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Nuclio를 사용해 ETL과 Streaming을 가속
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/nuclio/nuclio&quot;&gt;Nuclio Github&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/coijvb4sg66zaj8/Screenshot%202019-10-27%2011.02.59.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Nuclio를 사용해 Serving
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/nuclio/nuclio-jupyter&quot;&gt;Nuclio Jupyter Github&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/firi83gflx0a7pc/Screenshot%202019-10-27%2011.05.01.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Buidling ML Pipelines From (Serverless) Functions
    &lt;ul&gt;
      &lt;li&gt;Feature Store가 있군!&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/yg0rxoxfj9aifiz/Screenshot%202019-10-27%2011.06.45.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Demo
    &lt;ul&gt;
      &lt;li&gt;KFServing을 쓰는듯&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/qvfh1ym7co0cfch/Screenshot%202019-10-27%2011.12.05.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;deep-learning-on-business-data-at-uber&quot;&gt;Deep Learning on Business Data at Uber&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;왜 딥러닝인가?
    &lt;ul&gt;
      &lt;li&gt;기존에 사용하던 알고리즘보다 딥러닝이 더 좋은 성능을 보이고 있음&lt;/li&gt;
      &lt;li&gt;특정 도메인에선 압도적인 성능(vision)&lt;/li&gt;
      &lt;li&gt;기존에 사용하던 트리 모델과 결합해 하이브리드 모델을 만듬&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;딥러닝 In Uber
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/f4l210de6l1ds2t/Screenshot%202019-10-27%2011.24.35.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/46q5qf1pf24fc26/Screenshot%202019-10-27%2011.25.07.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/1cbo9ksvjys9oit/Screenshot%202019-10-27%2011.26.00.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이런 시스템을 어떻게 구현할까?
    &lt;ul&gt;
      &lt;li&gt;Option A : TFX&lt;/li&gt;
      &lt;li&gt;Option B : Apache Spark (이걸 사용)
        &lt;ul&gt;
          &lt;li&gt;Powerful ETL&lt;/li&gt;
          &lt;li&gt;Easy integration with XGBoost&lt;/li&gt;
          &lt;li&gt;이미 스파크를 사용하는 시스템이 있었음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;1) Feature Store
    &lt;ul&gt;
      &lt;li&gt;Real time과 Batch를 통합&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/5qxi8pl7bu24d4t/Screenshot%202019-10-27%2011.27.31.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2) Model Training
    &lt;ul&gt;
      &lt;li&gt;Apache Spark에서 딥러닝을 어떻게 합칠까?&lt;/li&gt;
      &lt;li&gt;Preprocessing
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/4si8hp8jyhw59u7/Screenshot%202019-10-27%2011.29.15.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;SparkML Pipelines
        &lt;ul&gt;
          &lt;li&gt;Estimator, Trnasformer, Pipeline&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/1mklfr4xpl7okle/Screenshot%202019-10-27%2011.30.11.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Distributed Training
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/aaz7ryhgd4udr6a/Screenshot%202019-10-27%2011.31.09.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Petastorm : 딥러닝 학습을 위한 데이터 접근
        &lt;ul&gt;
          &lt;li&gt;Parquet&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/qwevz08n6guz6u0/Screenshot%202019-10-27%2011.31.46.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;End-to-end Training Architecture
        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;http://eng.uber.com/petastorm&quot;&gt;Petastorm Blog&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/0yj3we2us2pkfrb/Screenshot%202019-10-27%2011.33.02.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3) Prediction Service
    &lt;ul&gt;
      &lt;li&gt;자바와 딥러닝 프레임워크를 같이 실행시켜야 함&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/j4akgulln6vajtj/Screenshot%202019-10-27%2011.34.16.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4) Authoring
    &lt;ul&gt;
      &lt;li&gt;데이터 사이언티스트들은 쥬피터 노트북을 좋아함&lt;/li&gt;
      &lt;li&gt;하나의 노트북에서 아이데이션, 학습, 평가, 딥러닝 모델 배포 등을 할 수 있을까?&lt;/li&gt;
      &lt;li&gt;Data Access
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/rvn5h7gj6jl9ifs/Screenshot%202019-10-27%2011.37.30.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Data Preparation
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/mmp1krwr8g94j5h/Screenshot%202019-10-27%2011.39.06.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Model Construction
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/7vryec8adgpjz8y/Screenshot%202019-10-27%2011.39.23.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Train the Model
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/33iiyucyv06e3m2/Screenshot%202019-10-27%2011.39.39.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Deploy the Model
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/grjfymmq0yx14f6/Screenshot%202019-10-27%2011.40.04.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;5) Don’t know Deep Learning?
    &lt;ul&gt;
      &lt;li&gt;딥러닝을 몰라도 Ludwig 활용&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://uber.github.io/ludwig/&quot;&gt;Ludwig 홈페이지&lt;/a&gt;, &lt;a href=&quot;https://github.com/uber/ludwig&quot;&gt;Ludwig Github&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/3y69bx9smagaj5o/Screenshot%202019-10-27%2011.40.24.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Recap(요약)
    &lt;ul&gt;
      &lt;li&gt;거대한 데이터셋을 가진 회사에서 딥러닝을 사용하면 powerful한 모델을 만들 수 있음&lt;/li&gt;
      &lt;li&gt;Uber의 딥러닝 시스템 아키텍쳐와 E2E DL 파이프라인을 정의하기 위해 노트북 친화적으로 만든 API를 떠올리기&lt;/li&gt;
      &lt;li&gt;Apache Spark, Horovod, Petastorm을 사용함&lt;/li&gt;
      &lt;li&gt;
        &lt;h2 id=&quot;ludwig에서-코드-없이-딥러닝-모델을-만듬&quot;&gt;Ludwig에서 코드 없이 딥러닝 모델을 만듬&lt;/h2&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;the-growth-and-future-of-kubeflow-for-ml&quot;&gt;The Growth and Future of Kubeflow for ML&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ML 구성은 매우 복잡함(이거 진짜 모든 MLOps 세미나에서 나오는듯…ㅋㅋㅋ)&lt;/li&gt;
  &lt;li&gt;MLOps Team이 당면한 문제
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/3jdmkhn65b1h3k9/Screenshot%202019-10-27%2011.46.29.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;10배 넘게 생산성을 가지도록 하는 방법은?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Kubeflow
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/6bcohn3vivnowwi/Screenshot%202019-10-27%2011.48.07.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Vibrant(활기찬) Ecosystem of Kubeflow
    &lt;ul&gt;
      &lt;li&gt;엄청 활발하게 발전되고 있는 에코시스템&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/tl0k49uafd42apj/Screenshot%202019-10-27%2011.49.29.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Deploy &amp;amp; Manage
    &lt;ul&gt;
      &lt;li&gt;Composable, Scalable, Portable&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9b8vdb8yen8ke3j/Screenshot%202019-10-27%2011.50.55.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;쿠버네티스가 MLOps에 좋은 이유
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/3bhobpdpr9wp49k/Screenshot%202019-10-27%2011.52.07.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Kubeflow 0.6
    &lt;ul&gt;
      &lt;li&gt;Metadata
        &lt;ul&gt;
          &lt;li&gt;인공물을 저장하고 스키마 정의 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Deployment
        &lt;ul&gt;
          &lt;li&gt;Kustomize가 ksonnet을 대체함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Multi user support&lt;/li&gt;
      &lt;li&gt;Pipelines
        &lt;ul&gt;
          &lt;li&gt;API와 UI 개선&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/480fza1vdjmyjjy/Screenshot%202019-10-27%2011.52.51.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Anthos가 MLOps에 좋은 이유
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://developers-kr.googleblog.com/2019/06/new-platform-for-managing-applications-in-todays-multi-cloud-world.html&quot;&gt;Google Developer의 Anthos 소개 글&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;흠 Anthos는 규모에 따라 이득일지 아닐지가 나뉠듯..?&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/wegm6aeiowf6do0/Screenshot%202019-10-27%2011.55.41.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/8gw1yyklg6hwhcq/Screenshot%202019-10-27%2012.05.37.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;stateless-ml-pipelines-achieve-reproducibility-and-automation-while-simplifying-the-pipeline&quot;&gt;Stateless ML Pipelines: Achieve reproducibility and automation while simplifying the pipeline&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;나이키&lt;/li&gt;
  &lt;li&gt;데이터 사이언티스트와 팀은 모델 파이프라인부터 프러덕션까지 할 수 있어야 하고, 모델의 전체 lifecycle을 알아야 함&lt;/li&gt;
  &lt;li&gt;What Stateless Pipelines Changed
    &lt;ul&gt;
      &lt;li&gt;Airflow 사용 -&amp;gt; 실패하면 알람&lt;/li&gt;
      &lt;li&gt;이제 모델 파이프라인을 몇분만에 만듬&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ilpknrtapcmzbyz/Screenshot%202019-10-27%2012.09.48.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Lifecycle of an ML Project
    &lt;ul&gt;
      &lt;li&gt;CI/CD 어떻게 하는지 궁금&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/z0cls1c1z6vp6u6/Screenshot%202019-10-27%2012.13.14.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파이프라인
    &lt;ul&gt;
      &lt;li&gt;기존 에어플로 설정을 더 간소화함&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/2ifepht6idg6ab8/Screenshot%202019-10-27%2012.18.07.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/q1kj72aiqbbgca5/Screenshot%202019-10-27%2012.19.38.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;아래는 뭐로 한건지 모르겠음. dsp?&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/kuajdntxeh3yhws/Screenshot%202019-10-27%2012.20.11.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모델 실행 파이프라인 예시
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/bw8aeyd1pe4rwm7/Screenshot%202019-10-27%2012.22.27.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Providing Paths
    &lt;ul&gt;
      &lt;li&gt;Dev / Test / Prod가 저장되는 폴더가 다름&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ixhpj53ic8e55uf/Screenshot%202019-10-27%2012.23.54.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Metrics
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/j652btdah2p6d50/Screenshot%202019-10-27%2012.24.16.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Standard CI/CD pipeline
    &lt;ul&gt;
      &lt;li&gt;젠킨스파일을 가짐&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/01xvl0l7vf8adsh/Screenshot%202019-10-27%2012.24.43.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Result
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/vvkydjq0dgpiivi/Screenshot%202019-10-27%2012.25.03.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLH8M0UOY0uy6d_n3vEQe6J_gRBUrISF9m&quot;&gt;MLOps NYC 2019 Youtube&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 27 Oct 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/mlops/2019/10/27/mlops-nyc19-review/</link>
        <guid isPermaLink="true">http://localhost:4000/mlops/2019/10/27/mlops-nyc19-review/</guid>
        
        <category>basic</category>
        
        
        <category>mlops</category>
        
      </item>
    
      <item>
        <title>Tensorflow KR 3차 오프라인 모임 후기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Tensorflow 3차 오프라인 모임 후기입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;on-device-ml-with-tensorflow-lite&quot;&gt;On-device ML with Tensorflow Lite&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Jason Zaman
    &lt;ul&gt;
      &lt;li&gt;twitter.com/perfinion&lt;/li&gt;
      &lt;li&gt;GDE Machine Learning&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;On-device ML
    &lt;ul&gt;
      &lt;li&gt;Constrained environment&lt;/li&gt;
      &lt;li&gt;Small battery&lt;/li&gt;
      &lt;li&gt;Limited memory&lt;/li&gt;
      &lt;li&gt;Bad connectivity&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Why do on-device ML?
    &lt;ul&gt;
      &lt;li&gt;더 많은 데이터에 접근하기 위해&lt;/li&gt;
      &lt;li&gt;interaction을 더 빠르게 하기 위해&lt;/li&gt;
      &lt;li&gt;Privacy preserving(클라우드에 올라가면 이슈)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Model Conversion
    &lt;ul&gt;
      &lt;li&gt;모델을 실행시키는 방법들
        &lt;ul&gt;
          &lt;li&gt;Demo App&lt;/li&gt;
          &lt;li&gt;Pretrained models&lt;/li&gt;
          &lt;li&gt;Retrained models&lt;/li&gt;
          &lt;li&gt;Build from scratch&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TF Lite까지 가는 Conversion flow
    &lt;ul&gt;
      &lt;li&gt;TensorFlow -&amp;gt; Saved Model -&amp;gt; TF Lite Converter -&amp;gt; TF Lite Model&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Model optimization
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.tensorflow.org/model_optimization/guide/roadmap&quot;&gt;loadmap link&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TFLite conversion flow&lt;/li&gt;
  &lt;li&gt;Sample Code&lt;/li&gt;
  &lt;li&gt;Inference with TFLite Interpreter
    &lt;ul&gt;
      &lt;li&gt;생각보다 간단&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import numpy as np
  import tensorflow as tf
	
  # Load TFLite model and allocate tensors.
  interpreter = tf.lite.Interpreter(model_path=&quot;converted_model.tflite&quot;)
  interpreter.allocate_tensors()
	
  # Get input and output tensors.
  input_details = interpreter.get_input_details()
  output_details = interpreter.get_output_details()
	
  # Test model on random input data.
  input_shape = input_details[0]['shape']
  input_data = np.array(np.random.ran
  dom_sample(input_shape), dtype=np.float32)
  interpreter.set_tensor(input_details[0]['index'], input_data)
	
  interpreter.invoke()
	
  # The function `get_tensor()` returns a copy of the tensor data.
  # Use `tensor()` in order to get a pointer to the tensor.
  output_data = interpreter.get_tensor(output_details[0]['index'])
  print(output_data)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;C++에서도 쉽게 가능&lt;/li&gt;
  &lt;li&gt;Incredible inference performancee를 보임&lt;/li&gt;
  &lt;li&gt;Interpreter Core는 Operation Kernels와 Accelerator Delegate, Operation Kernels로 이루어져 있음
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.tensorflow.org/lite/performance/delegates&quot;&gt;Document&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Android Neural Network API delegate도 있음. 안드로이드에서도 딥러닝?&lt;/li&gt;
  &lt;li&gt;Optimization
    &lt;ul&gt;
      &lt;li&gt;Quantization
        &lt;ul&gt;
          &lt;li&gt;Fixed point vs Floating point&lt;/li&gt;
          &lt;li&gt;Post training quantization vs Quantization-aware training&lt;/li&gt;
          &lt;li&gt;진행하면 모델 사이즈가 4배 작아지고, 속도 개선됨&lt;/li&gt;
          &lt;li&gt;TensorFlow =&amp;gt; Saved Model + Calibration Data =&amp;gt; TF Lite Converter =&amp;gt; TF Lite Model&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;EdgeTPU
    &lt;ul&gt;
      &lt;li&gt;4 Trillion Operations per Second(TOPS)&lt;/li&gt;
      &lt;li&gt;어마어마한 친구 ㄷㄷ&lt;/li&gt;
      &lt;li&gt;Fixed point only&lt;/li&gt;
      &lt;li&gt;Must fully quantize&lt;/li&gt;
      &lt;li&gt;Compile .tflite file for the EdgeTPU&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Quantize 해야하는 이유
    &lt;ul&gt;
      &lt;li&gt;에너지 절약&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;auto-scalable한-deep-learning-production을-위한-ai-service-infra-구성-및-ai-devops-cycle&quot;&gt;Auto Scalable한 Deep Learning Production을 위한 AI Service Infra 구성 및 AI DevOps Cycle&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Feat. Docker로 1만 TPS inference 구축해보기&lt;/li&gt;
  &lt;li&gt;SKT AI Center, 김훈동님 박찬엽님&lt;/li&gt;
  &lt;li&gt;Production AI Serving Infra 구성 및 방법론
    &lt;ul&gt;
      &lt;li&gt;Pain Point 1
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/7gmjlnk5hwtdfxa/2019-10-20%2013.44.41.jpg?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;Tensorflow Serving : 멀티 딥러닝 프레임워크 환경이라 커버리지가 높은 방법을 찾음&lt;/li&gt;
          &lt;li&gt;PaaS : 매우 비쌈&lt;/li&gt;
          &lt;li&gt;Flask : Python이 느리고, 험난한 Engineering Art가 필요&lt;/li&gt;
          &lt;li&gt;TensorRT&lt;/li&gt;
          &lt;li&gt;Cloud serverless + NoSQL : 커버리지는 낮을 수 있음. 케바케&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;다양한 프레임워크 지원을 위해 다른 방법으로 접근&lt;/li&gt;
      &lt;li&gt;머신러닝 모델들 =&amp;gt; PMML 파일로 컨버전해서 상대적으로 성능이 좋은 자바를 통해 inference 진행
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/6u3hl3iydoiw3ef/2019-10-20%2013.47.31.jpg?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;진행한 방법
        &lt;ul&gt;
          &lt;li&gt;Flask, TensorRT&lt;/li&gt;
          &lt;li&gt;무거운 모델이면 TensorRT&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;3번 Flask
        &lt;ul&gt;
          &lt;li&gt;초 저렴 vCPU Docker 많은 인스턴스(월 4만원) vs 어벤져스급 GPU Docker(월 1000만원)&lt;/li&gt;
          &lt;li&gt;저글링 vs 시즈탱크 =&amp;gt; 일반인과 프로게이머의 차이&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;DL Serving에 대한 고려 사항
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/7nwwq35mm8823tq/2019-10-20%2013.50.47.jpg?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;배치사이즈 큰 경우, 작은 사이즈&lt;/li&gt;
          &lt;li&gt;Python Thread 처리는 최악&lt;/li&gt;
          &lt;li&gt;처리량과 정확도의 Trade Off&lt;/li&gt;
          &lt;li&gt;모델 압축&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;GPU의 오해
        &lt;ul&gt;
          &lt;li&gt;항상 왜 성능 그래프를 ResNet가지고 비교하지?&lt;/li&gt;
          &lt;li&gt;Real World에서 많이 쓰는 모델들 중 MLP, LSTM은 GPU가 안좋은 경우도 있음&lt;/li&gt;
          &lt;li&gt;실제로 실험해본 결과 다 다름&lt;/li&gt;
          &lt;li&gt;CPU로 할 경우 250 TPS =&amp;gt; 데이터 다 전역에 올리고 로그 못찍고 하면 가능했음(BiLSTM)&lt;/li&gt;
          &lt;li&gt;GPU로 할 경우 16TPS&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;TensorRT 사용하는 방법
        &lt;ul&gt;
          &lt;li&gt;TensorRT를 이용하는 Restful API 사용하기&lt;/li&gt;
          &lt;li&gt;Flask로 TensorRT Engine 호출하기 =&amp;gt; 여전히 싱글 프로세스라 여전히 병목이 생길 수 있음(플라스크 앞단에서)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Pain Point 2 - Poor Python Performance
        &lt;ul&gt;
          &lt;li&gt;Python -&amp;gt; node로 바꿔도 성능이 개선됨&lt;/li&gt;
          &lt;li&gt;자바 버텍스 쓰니 성능 80배 올랐음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Pain Point 2 - 해결 팁
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/stglx1hpuafrycw/2019-10-20%2013.56.43.jpg?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/j1i56sajafgn3wl/2019-10-20%2013.59.15.jpg?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;Pandas를 빼고 순수 파이썬으로 쓴다&lt;/li&gt;
          &lt;li&gt;함수형 언어처럼 가상 함수를 사용(Data copy 병목 줄이기) =&amp;gt; Python에서 Map, Lambda 사용! functionstools.partial&lt;/li&gt;
          &lt;li&gt;Python Thread를 쓰지 않음 =&amp;gt; 고루틴처럼 쓸거면 멀티프로세스가 낫고.. Go의 Goroutin 쓰듯 하려면 cotyledon&lt;/li&gt;
          &lt;li&gt;MemoryView 활용
            &lt;ul&gt;
              &lt;li&gt;Data 핸들시 pointer 접근하듯&lt;/li&gt;
              &lt;li&gt;대용량 Data Memory 복사 방지&lt;/li&gt;
              &lt;li&gt;C언어로 데이터 핸들링할 때 병목이 생기는 부분은 메모리카피 =&amp;gt; 줄이기 위한 포인터&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Microservice로 잘게 쪼개고&lt;/li&gt;
          &lt;li&gt;모든 것은 비동기로&lt;/li&gt;
          &lt;li&gt;PMML + Java 컨버전&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;훈동님이 마소에서 발표한 사례를 실제 프러덕션에 적용하진 못함. gunicorn을 사용해 안정성을 잡음&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/90cccgn9smznivi/2019-10-20%2014.00.17.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;WSGI -&amp;gt; ASGI로 큰 도움이 됨&lt;/li&gt;
      &lt;li&gt;Pooling, streaming, web hook 등의 비동기 방법이 있는데 어떤 라이브러리 쓸지 정의해서 컨버전함&lt;/li&gt;
      &lt;li&gt;싱글톤을 데코레이터로 감싸기&lt;/li&gt;
      &lt;li&gt;CPU는 메모리가 더 많아서 멀티프로세스에 강함&lt;/li&gt;
      &lt;li&gt;어디서 병목이 생기는지 잘 봐야하고, Low Level Debug 필요 : CProfile, kCacheGrind 등을 사용함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Production AI Open Source Eco System
    &lt;ul&gt;
      &lt;li&gt;Pandas UDF
        &lt;ul&gt;
          &lt;li&gt;스파크를 깔고 pandas로&lt;/li&gt;
          &lt;li&gt;배치에 최적화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Horovod
        &lt;ul&gt;
          &lt;li&gt;분산, 스파크로 메모리 처리 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Petastorm
        &lt;ul&gt;
          &lt;li&gt;엄청 큰 데이터로 할 경우 장비에 로딩이 안되면 하둡에 수백기가 접근할 경우 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Horizon
        &lt;ul&gt;
          &lt;li&gt;강화학습시&lt;/li&gt;
          &lt;li&gt;파이토치로 하고 onnx&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ML WorkFlow
        &lt;ul&gt;
          &lt;li&gt;Airflow, Kubeflow&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;TFX
        &lt;ul&gt;
          &lt;li&gt;TensorFlow 모델을 쓰면 좋음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;mlflow
        &lt;ul&gt;
          &lt;li&gt;MLOps 솔루션으로 스파크쪽으로 만드는 것&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Serving at SCale : Seldon&lt;/li&gt;
      &lt;li&gt;Rapids.ai : GPU를 cuda 사용&lt;/li&gt;
      &lt;li&gt;Clipper.ai 딥러닝 쿼리 캐싱&lt;/li&gt;
      &lt;li&gt;ONNX : 압축 관련쪽에서 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Production AI DevOps
    &lt;ul&gt;
      &lt;li&gt;지속적 통합과 배포
        &lt;ul&gt;
          &lt;li&gt;도커&lt;/li&gt;
          &lt;li&gt;개발환경 깔끔하게 하기 / 다른 곳에서 재현 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;마이크로서비스
        &lt;ul&gt;
          &lt;li&gt;Stateless하게 사용&lt;/li&gt;
          &lt;li&gt;딥러닝은 state가 없음&lt;/li&gt;
          &lt;li&gt;멀티톤 고려하면 지옥이..&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;커뮤니케이션
        &lt;ul&gt;
          &lt;li&gt;많은 팀의 사람들이 각자 모델 만듬&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;코드형 인프라스트럭쳐
        &lt;ul&gt;
          &lt;li&gt;테라폼 =&amp;gt; 클라우드 서비스를 코드 레벨로 관리&lt;/li&gt;
          &lt;li&gt;인프라 생성이 아닌 쿠버네티스로 한번에 다 처리함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;쿠버네티스
        &lt;ul&gt;
          &lt;li&gt;Pod을 관리하는 상위 개념들
            &lt;ul&gt;
              &lt;li&gt;컨테이너일수도 있고, 여러 개를 관리하기 위한 개념 단위&lt;/li&gt;
              &lt;li&gt;Replicaset, Deployment 정도 집중&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;TargetCPUUtilizationPercentage를 지정하면 그 기준으로 처리함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;배포는 Azure Devops의 pipelines의 기능을 활용
        &lt;ul&gt;
          &lt;li&gt;Audit log : 누가 뭘 했다&lt;/li&gt;
          &lt;li&gt;새로운 이미지 배포를 위해 latest 태그 만드는 것을 지양..! 환경/설정이 변경된 것이 아니라 배포가 되지 않음&lt;/li&gt;
          &lt;li&gt;Kubectl 명령을 devops 내에서만 실행&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Rollback
        &lt;ul&gt;
          &lt;li&gt;배포 기록 관리해주고, 기록 기반 롤백이 됨&lt;/li&gt;
          &lt;li&gt;Azure에서다 해준다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;코드 내에서 env 호출로 사용하지만 왠만하면 환경 변수 안쓰는게 좋음
        &lt;ul&gt;
          &lt;li&gt;db에 접근하는 서비스를 만들고 진행해야 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;모델 서빙을 위한 패턴
        &lt;ul&gt;
          &lt;li&gt;One fat image
            &lt;ul&gt;
              &lt;li&gt;600k면 도커 이미지 올리는게 좋을숟도&lt;/li&gt;
              &lt;li&gt;10기가면… 이미지에 먼저 올린다? 빌드하는데 30분 넘음. 불가능한 이야기~&lt;/li&gt;
              &lt;li&gt;빌드할 떄 모델을 넣음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Model puller sidecar
            &lt;ul&gt;
              &lt;li&gt;Pod에 sidecar 개념이 있음. 다른 컨테이너를 붙여줌&lt;/li&gt;
              &lt;li&gt;볼륨을 공유하고 있는 웹 서버 + 스토리지 체크하는 친구만들어서 나눔&lt;/li&gt;
              &lt;li&gt;자연어는 전처리 후처리 코드를 만들까 사이드카를 넣을까? 고민 중&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Attached volumn
            &lt;ul&gt;
              &lt;li&gt;클라우드 기능 사용&lt;/li&gt;
              &lt;li&gt;자신 컴퓨터의 하드디스크처럼 mount&lt;/li&gt;
              &lt;li&gt;모델 경로 여기에 넣어주세요~ 이런 느낌&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;프러덕션-환경에서-연구하기&quot;&gt;프러덕션 환경에서 연구하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;하이퍼커넥트 AI lab 하성주님&lt;/li&gt;
  &lt;li&gt;프러덕션(서비스 중인/될 제품)과 연구(불확실한 기술 개발)의 이야기&lt;/li&gt;
  &lt;li&gt;AI Lab
    &lt;ul&gt;
      &lt;li&gt;모바일 환경에서 실시간으로 이미지 다루는 것에 고민함&lt;/li&gt;
      &lt;li&gt;기존 팀의 포커스는 모바일 환경에서 실시간으로 이미지 다루기였음(MMNet)&lt;/li&gt;
      &lt;li&gt;이제 뭐할까? 워크샵
        &lt;ul&gt;
          &lt;li&gt;10개 학회 =&amp;gt; 3700편 논문&lt;/li&gt;
          &lt;li&gt;유저 니즈/비즈니스 트렌드 기반 아이디어 브레인스토밍&lt;/li&gt;
          &lt;li&gt;300가지 정도의 잠재적인 활용처 고민&lt;/li&gt;
          &lt;li&gt;1년간 로드맵 구성&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로젝트 선정
    &lt;ul&gt;
      &lt;li&gt;실현 가능성&lt;/li&gt;
      &lt;li&gt;임팩트&lt;/li&gt;
      &lt;li&gt;기술적 중요도&lt;/li&gt;
      &lt;li&gt;트렌드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Keyword Spotting
    &lt;ul&gt;
      &lt;li&gt;특정 핵심어가 발성되었는지 검출하는 문제&lt;/li&gt;
      &lt;li&gt;고려 사항
        &lt;ul&gt;
          &lt;li&gt;도메인 확장
            &lt;ul&gt;
              &lt;li&gt;CV 외 도메인으로 확장&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;난이도
            &lt;ul&gt;
              &lt;li&gt;분류 문제라 상대적으로 쉬움&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;기존 전문성
            &lt;ul&gt;
              &lt;li&gt;경량 모델에서 모바일 배포를 많이 해서 좋은 성과를 금방 거둘 수 있다 판단&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Literature Survey
    &lt;ul&gt;
      &lt;li&gt;수백편을 목록으로 뽑고, 관력있을 것 같은 것들을 뽑음&lt;/li&gt;
      &lt;li&gt;데이터 오픈, 코드 정리 유무 등&lt;/li&gt;
      &lt;li&gt;스프레드시트 진행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Baseline
    &lt;ul&gt;
      &lt;li&gt;비교 대상이 되는 모델이 있어야 개선이 의미 있음&lt;/li&gt;
      &lt;li&gt;점진적으로 비교할 수 있는 모델을 늘려가며 다양한 컴포넌트를 확보&lt;/li&gt;
      &lt;li&gt;프로덕션에는 이미 연구된 모델을 구현하는 것이 충분할 수도 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Baseline Selection
    &lt;ul&gt;
      &lt;li&gt;합리적 성능이 나오는지? (SotA와 비교)&lt;/li&gt;
      &lt;li&gt;구현 난이도 및 공식 코드 공개 여부
        &lt;ul&gt;
          &lt;li&gt;재현이 까다로운 경우가 자주 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;프러덕션에서 적용될 제약 조건을 얼마나 만족하는지?
        &lt;ul&gt;
          &lt;li&gt;모바일 CPU에서 실시간 수행 가능한가?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data
    &lt;ul&gt;
      &lt;li&gt;공개 데이터셋
        &lt;ul&gt;
          &lt;li&gt;오픈된 데이터를 바탕으로 리포팅&lt;/li&gt;
          &lt;li&gt;학계에 없으면 줄 수 없다고 많이 말함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;비공개 데이터셋
        &lt;ul&gt;
          &lt;li&gt;내가 관심있는 도메인의 모델 성능은 다를 수 있음&lt;/li&gt;
          &lt;li&gt;데이터 수집에 대한 고민
            &lt;ul&gt;
              &lt;li&gt;어노테이션, 정합성 확인&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;데이터 탐색이 필수&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PoC
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/n2yp7gw858a1lun/2019-10-20%2014.30.11.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;일단 처음엔 큰 모델을 만들어서 우리가 원하는 정확도가 나오는지 파악함&lt;/li&gt;
      &lt;li&gt;중간 산출물이 프러덕션 활용될 수 있도록 고민함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Process
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/08ndrguwa2fghrk/2019-10-20%2014.31.16.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;일단 한바퀴 돌면 어디가 문제인지 알 수 있어서 어느정도 휴리스틱도 괜찮음&lt;/li&gt;
      &lt;li&gt;오디오 처음이라 컴포넌트 만듬&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Evaluation
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/xwijd2is6gv9352/2019-10-20%2014.32.19.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;모델 리포팅 결과가 재현 안되는 경우가 있음&lt;/li&gt;
      &lt;li&gt;모델 최적화하는 사람의 역량에 따라 다를 수 있음&lt;/li&gt;
      &lt;li&gt;Flops 연산량을 뽑아줌 =&amp;gt; 모바일에선 약한 상관관계가 있음&lt;/li&gt;
      &lt;li&gt;제품을 어떻게 사용할지에 대해 고민&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Research
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/g86a36pc02jsyl0/2019-10-20%2014.35.08.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;유망한 모델을 재현하며 아이디어 얻기&lt;/li&gt;
      &lt;li&gt;다른 도메인의 아이디어 훔쳐오기&lt;/li&gt;
      &lt;li&gt;팀원과 토론&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;KWS Research Progress
    &lt;ul&gt;
      &lt;li&gt;오리지널 REsNet과 다른 구조&lt;/li&gt;
      &lt;li&gt;최대한 맞추니 결과가 좀 좋아짐. 하지만 속도가 빠르지 않아 가속할 방법 고민
        &lt;ul&gt;
          &lt;li&gt;기존 모바일 컴퓨터 비전 전문성을 지렛대로 활용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Audio Processing
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/xnsyueqon98dwgr/2019-10-20%2014.37.19.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CNN Based KWS
    &lt;ul&gt;
      &lt;li&gt;네트워크가 깊어져야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Temporal Convolution
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/hd1c20jbtv1owga/2019-10-20%2014.38.08.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;모바일에서 만들면 1d가 매우 빠름(캐시 친화적인 이슈)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TC-ResNet
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/zi8owl743sm8y6b/2019-10-20%2014.39.12.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;2D -&amp;gt; 1D로 변환&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Result
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/4ofjigqbmtrbism/2019-10-20%2014.39.50.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;정확도 11% 개선, 모델 대비 385배 빠름&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Publishing
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/cb1k9zze7lhdfvm/2019-10-20%2014.40.21.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Ablation 테스트를 통해 불필요한 컴포넌트를 이해&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Ablation Test
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/qgnrqeqx6lykofb/2019-10-20%2014.41.16.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;프러덕션땐 잘되면 그냥 냅두지만 논문 쓰다보면 제거할 수 있음 =&amp;gt; 결국 다시 프러덕션때도 제거&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Retrospection
    &lt;ul&gt;
      &lt;li&gt;3개월만에 진행&lt;/li&gt;
      &lt;li&gt;기계학습 전문성 &amp;gt; 도메인 전문성이었떤 예&lt;/li&gt;
      &lt;li&gt;기존 전문성을 잘 활용함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Production + Research
    &lt;ul&gt;
      &lt;li&gt;제작을 중심으로 하는 회사에서 성공적인 기계학습 조직 운영하려면
        &lt;ul&gt;
          &lt;li&gt;서로 기대를 맞추고&lt;/li&gt;
          &lt;li&gt;서로 윈윈할 수 있어야 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Expectation Management
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/65m6efryci5lajj/2019-10-20%2014.42.49.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Positive Sum Game
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/txind7rfmc65n9r/2019-10-20%2014.44.14.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Ownership
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/kbinhnk24zolg2e/2019-10-20%2014.45.03.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;당근마켓-추천-시스템&quot;&gt;당근마켓 추천 시스템&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;당근마켓, 전무익님&lt;/li&gt;
  &lt;li&gt;초기 타겟은 여성 육아 맘이였는데 요샌 10대~60대 다양한 사람들이 생김&lt;/li&gt;
  &lt;li&gt;첫 화면, 홈 피드에서 추천을 제공하고 있음&lt;/li&gt;
  &lt;li&gt;큰 목적이 없어도 피드를 사용함
    &lt;ul&gt;
      &lt;li&gt;동네 사람들의 제품 구경, 득템하는 재미&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;첫 단계
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/3f0bao2qbtc1ir2/2019-10-20%2014.51.21.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;처음부터 완전한 피드 개인화 불가
        &lt;ul&gt;
          &lt;li&gt;소규모 스타트업&lt;/li&gt;
          &lt;li&gt;최신 글의 중요성 고려&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;추천 글을 피드 사이에 노출&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;유튜브 추천 시스템 논문을 활용&lt;/li&gt;
  &lt;li&gt;추천 시스템 구조
    &lt;ul&gt;
      &lt;li&gt;사용자 정보(봤던 글, 검색 키워드) =&amp;gt; 추천 모델 =&amp;gt; 다음 볼 글 예측&lt;/li&gt;
      &lt;li&gt;실시간 추천
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/oh89g3akxkk7kmv/2019-10-20%2014.52.31.jpg?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Two Stage
        &lt;ul&gt;
          &lt;li&gt;후보 모델 + 랭킹 모델&lt;/li&gt;
          &lt;li&gt;후보 모델만 구현함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;학습 데이터
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/1o8tigg8409u8po/2019-10-20%2014.53.33.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;학습 네트워크
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/1ppevq60ckehrkg/2019-10-20%2014.54.00.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;후보 모델의 역할
    &lt;ul&gt;
      &lt;li&gt;전체 글 중 사용자가 좋아할만한 200개 찾기&lt;/li&gt;
      &lt;li&gt;추천 후보 pool을 빠르게 준비&lt;/li&gt;
      &lt;li&gt;단일 모델론 수많은 글 중 단 하나를 맞추는건 쉽지 않아 이런 구조로 진행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;측정 결과
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/dod5jkmuqhq98tn/2019-10-20%2014.55.24.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실시간 처리
    &lt;ul&gt;
      &lt;li&gt;Articel vectors를 학습해 인덱스 구축&lt;/li&gt;
      &lt;li&gt;user vector와 모든 article vectors에 대한 dot product 연산 대체&lt;/li&gt;
      &lt;li&gt;매우 빠른 유사 벡터 검색이 가능하고, faiss 라이브러리 활용함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Nearest neighbor index 준비
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/6pzzxkgsvi5gj08/2019-10-20%2014.56.29.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Inference
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9m20wjz03ufnehz/2019-10-20%2014.57.03.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;CPU 0.01s 이하&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;추천 시스템 구축
    &lt;ul&gt;
      &lt;li&gt;데이터 수집
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/8fgriwxcrads011/2019-10-20%2014.57.57.jpg?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;학습 Examples
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/znafdjf66riqsoq/2019-10-20%2014.58.32.jpg?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;이전에 본 글을 BigQuery ARRAY_AGG 사용함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;CSV 추출
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/h1fivpuliojo7u4/2019-10-20%2014.59.19.jpg?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;데이터 전처리
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/rvv3usqm93u1u0g/2019-10-20%2015.00.19.jpg?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;병렬 분산 처리
        &lt;ul&gt;
          &lt;li&gt;데이터가 많을수록 데이터가 선형적으로 시간 소요&lt;/li&gt;
          &lt;li&gt;Tensorflow Transform 활용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;TF Transform
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/cdylbaxf51vrcx8/2019-10-20%2015.01.19.jpg?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Training-serving skew
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/gwdx12lhrt47emg/2019-10-20%2015.01.45.jpg?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Cloud Dataflow 사용
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9yq242bwrmall0x/2019-10-20%2015.02.34.jpg?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;모델 학습
        &lt;ul&gt;
          &lt;li&gt;지속적으로 안정적 학습이 중요&lt;/li&gt;
          &lt;li&gt;인프라 관리가 부담, 클라우드 관리형 서비스 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Cloud AI Platform
        &lt;ul&gt;
          &lt;li&gt;Tensorflow Estimator로 모델 작성&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;모델 서빙
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/a5xyo3ypkmliwqq/2019-10-20%2015.04.19.jpg?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;시간이 지나며 새로운 글을 추천하기 위해 지속적 학습, 업데이트&lt;/li&gt;
      &lt;li&gt;파이프라인 시스템
        &lt;ul&gt;
          &lt;li&gt;워크플로우 작업 실행&lt;/li&gt;
          &lt;li&gt;실행 로그/결과 확인&lt;/li&gt;
          &lt;li&gt;정해진 일정에 맞춰 실행&lt;/li&gt;
          &lt;li&gt;직접 구현하기보다 오픈소스 활용&lt;/li&gt;
          &lt;li&gt;Kubeflow pipelines
            &lt;ul&gt;
              &lt;li&gt;컨테이너 기반
                &lt;ul&gt;
                  &lt;li&gt;워브플로우 작업 정의 편리&lt;/li&gt;
                  &lt;li&gt;개발과 실행 환경을 동일하게 유지할 수 있음&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;파이프라인 작성
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/b9ytw24wqzcdxlv/2019-10-20%2015.06.25.jpg?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;파이프라인 배포
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/njf6q0lxwf66k1z/2019-10-20%2015.07.05.jpg?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;파이프라인 배포 코드
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/lmec44r71j30qzn/2019-10-20%2015.07.34.jpg?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Output Viewer
            &lt;ul&gt;
              &lt;li&gt;예측 결과를 쉽게 볼 수 있음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;홈 피드 목록 중간에 넣고 있음&lt;/li&gt;
  &lt;li&gt;피드 개인화 추천 효과
    &lt;ul&gt;
      &lt;li&gt;글 보기 +6%&lt;/li&gt;
      &lt;li&gt;방문 시간 +5%&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;라이트닝-토크&quot;&gt;라이트닝 토크&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Machina Black
    &lt;ul&gt;
      &lt;li&gt;기술로 법률 시장을 혁신&lt;/li&gt;
      &lt;li&gt;NLP + Legal&lt;/li&gt;
      &lt;li&gt;인공지능 변호사 : 계약서 자동 검토, 계약서 데이터 활용&lt;/li&gt;
      &lt;li&gt;인공지능 판사 : 판결 예측, 송무 데이터 활용&lt;/li&gt;
      &lt;li&gt;Legal Translation&lt;/li&gt;
      &lt;li&gt;법률 번역 =&amp;gt; 영어도 잘하고 법도 잘 알아야 함&lt;/li&gt;
      &lt;li&gt;연말에 베타 서비스&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Art LAB
    &lt;ul&gt;
      &lt;li&gt;AI &amp;amp; Robotics + Technology&lt;/li&gt;
      &lt;li&gt;Transformation : ART, 변혁으로 삶에 뿌리내림&lt;/li&gt;
      &lt;li&gt;Team : 친구이자 동료가 됨&lt;/li&gt;
      &lt;li&gt;Beauty AI
        &lt;ul&gt;
          &lt;li&gt;아름다움, 관리, 힐링 =&amp;gt; 나를 아끼고 존중하며 소중히 여김&lt;/li&gt;
          &lt;li&gt;기획 AI : 소비자 니즈 센싱, 맞춤형 추천, 신제품 기획&lt;/li&gt;
          &lt;li&gt;개발 AI : 원료-제품 관계, 재고 관리, 업무 효율화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Lomin
    &lt;ul&gt;
      &lt;li&gt;컴퓨터 비전 집중&lt;/li&gt;
      &lt;li&gt;DeepFake 검출&lt;/li&gt;
      &lt;li&gt;무상에서 개인 정보 비식별화&lt;/li&gt;
      &lt;li&gt;문자 인식 솔루션 개발 중&lt;/li&gt;
      &lt;li&gt;Visual Identity Protector : 개인 정보&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Nota
    &lt;ul&gt;
      &lt;li&gt;경량화 기술 연구&lt;/li&gt;
      &lt;li&gt;클라우드를 없애고 다른 Edge device에 모델이 돌아가도록 진행&lt;/li&gt;
      &lt;li&gt;Medical Device 회사와 의료 영상, 생채 진행&lt;/li&gt;
      &lt;li&gt;Security Company와 같이 CCTV 모델 연구&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;에스아이에이
    &lt;ul&gt;
      &lt;li&gt;RNN을 이용한 전력 가격 예측 Github&lt;/li&gt;
      &lt;li&gt;위성 데이터로 판별&lt;/li&gt;
      &lt;li&gt;위성 영상으로 지구에 뭐가 있는지 판단&lt;/li&gt;
      &lt;li&gt;다양한 논문 연구하고 제출함&lt;/li&gt;
      &lt;li&gt;경진대회 장려 중ㅋㅋㅋ&lt;/li&gt;
      &lt;li&gt;Object Detection, Ship Detection, Explainable AI, Vehicle Detection 등 집중&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Hutom
    &lt;ul&gt;
      &lt;li&gt;수술 중 발생하는 문제를 데이터 기반으로 해결&lt;/li&gt;
      &lt;li&gt;암 수술은 기구를 통해서 진행하고 있음&lt;/li&gt;
      &lt;li&gt;로봇 팔이 들어감&lt;/li&gt;
      &lt;li&gt;데이터
        &lt;ul&gt;
          &lt;li&gt;SEE : Stereo Camera&lt;/li&gt;
          &lt;li&gt;DO : Controller&lt;/li&gt;
          &lt;li&gt;키네마틱 데이터&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DACON
    &lt;ul&gt;
      &lt;li&gt;경진 대회&lt;/li&gt;
      &lt;li&gt;교육에 활용&lt;/li&gt;
      &lt;li&gt;국방 + 쎄트렉아이와 함께해서 곧 대회 열림&lt;/li&gt;
      &lt;li&gt;위성 이미지 객체 추출&lt;/li&gt;
      &lt;li&gt;비즈니스 데이터 Fit, 비즈니스 대회 Fit, 운영 자동화(치팅, 자동 리포팅 등), 고도화 및 적용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PR12
    &lt;ul&gt;
      &lt;li&gt;매주 일요일 밤 10시에 매주 2편씩 논문 읽고 발표 영상 녹화해 공유&lt;/li&gt;
      &lt;li&gt;여태 누적 200편&lt;/li&gt;
      &lt;li&gt;컴퓨터 비전 위주로 진행&lt;/li&gt;
      &lt;li&gt;ㅋㅋㅋㅋㅋㅋㅋㅋ 아침에 영상 보는 모임 나옴&lt;/li&gt;
      &lt;li&gt;총 View : 431,766&lt;/li&gt;
      &lt;li&gt;Like : 3,863&lt;/li&gt;
      &lt;li&gt;Unlike : 238&lt;/li&gt;
      &lt;li&gt;최다 조회수 3만회 =&amp;gt; Faster RCNN&lt;/li&gt;
      &lt;li&gt;외국인들이 영어 번역해달라고 하기도 함&lt;/li&gt;
      &lt;li&gt;진원님 최초 기수부터 마지막까지 계속 하고 계심! 파이팅!!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;kafka-스트림을-위한-멀티프로세스-딥러닝-추론&quot;&gt;Kafka 스트림을 위한 멀티프로세스 딥러닝 추론&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;네이버 쇼핑플랫폼&lt;/li&gt;
  &lt;li&gt;이성철님&lt;/li&gt;
  &lt;li&gt;쇼핑 카테고리 분류
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/0zzdd7eacmp6zwq/2019-10-20%2016.50.54.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;과거엔 관리자가 쇼핑몰 카테고리를 직접 매핑했으나, 요새는 딥러닝 기반 카테고리 분류를 하고 있음&lt;/li&gt;
  &lt;li&gt;Kafka 스트림을 위한 추론 시스템 개발
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/o5fjuh4h6dyf1fu/2019-10-20%2016.52.49.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;메세지 기반, 썸네일 만들고 카테고리 분류 절차 등을 카프카에 태움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Raw Data
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/yh8ra6l6u0ahqcu/2019-10-20%2016.53.48.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;텍스트 전처리 =&amp;gt; Numpy Array 만듬&lt;/li&gt;
  &lt;li&gt;이미지 전처리
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/q3phju2uzyi0wf2/2019-10-20%2016.55.59.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;디스크 IO가 없어야 함(메모리에서 올림)&lt;/li&gt;
      &lt;li&gt;나누기는 GPU에서 처리
        &lt;ul&gt;
          &lt;li&gt;나누기는 CPU consuming한 연산&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Multi-process inference
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/x534ktohfvtwu54/2019-10-20%2016.57.14.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Consumer : 토픽에서 메세지를 받아오는 역할&lt;/li&gt;
      &lt;li&gt;Preprocessor : 받아온 메세지를 모델에 입력할 수 있도록 데이터 변환&lt;/li&gt;
      &lt;li&gt;Classifier : GPU 모델을 로딩해서 들어오는 데이터를 계속 inference&lt;/li&gt;
      &lt;li&gt;GPU를 최대로 쓰기 위해 Classifier보다 더 많은 Preprocessor가 필요(이렇게 하면 분류기 앞에 배치 큐에 많은 것들이 담김)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Inference performance
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/1mgehwg5bhgtg26/2019-10-20%2016.59.20.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Multi process Class(Consumer의 예)
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/owrhafy0ezu4ny6/2019-10-20%2017.00.29.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Multiprocessing.Process 상속하고 잘 종료하기 위해 stop() 함수 작성하고&lt;/li&gt;
      &lt;li&gt;run() 함수 필수 작성
        &lt;ul&gt;
          &lt;li&gt;결과 quere가 full이면 대기&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Multiprocessing의 Array가 있구나&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;main.py
    &lt;ul&gt;
      &lt;li&gt;Process Start / Stop&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/h5v9reitc6jcdn6/2019-10-20%2017.01.25.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이미지와 텍스트 학습 데이터 준비
    &lt;ul&gt;
      &lt;li&gt;Training 데이터셋 만들기
        &lt;ul&gt;
          &lt;li&gt;이미지와 텍스트를 같이 담을 수 있어야 하고&lt;/li&gt;
          &lt;li&gt;Spark Tensorflow 사이에서 자유롭게 사용 가능해야 함&lt;/li&gt;
          &lt;li&gt;TFRecords가 가장 적합&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;이미지 URL만 아닌 바이너리 파일
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/cxjnoc5lxcjy8iw/2019-10-20%2017.03.51.jpg?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;100 ~ 200 MB가 적절&lt;/li&gt;
          &lt;li&gt;파티션 개수 조절!!&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Load data using tf.data
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/06zl67tqaj70pcq/2019-10-20%2017.05.32.jpg?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;런타임 shuffle은 미리 하고 저장&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;graph-neural-networks&quot;&gt;Graph Neural Networks&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;류성옥님&lt;/li&gt;
  &lt;li&gt;분자가 그래프로 표현됨&lt;/li&gt;
  &lt;li&gt;Inductive Biases in Neural networks
    &lt;ul&gt;
      &lt;li&gt;파라미터라이즈를 할 수 있음&lt;/li&gt;
      &lt;li&gt;뉴럴넷은 연속함수를 근사할 수 있단 사실 때문에 사용&lt;/li&gt;
      &lt;li&gt;MLP에서 더 나아가서 도메인에 맞게 학습
        &lt;ul&gt;
          &lt;li&gt;이미지 : CNN&lt;/li&gt;
          &lt;li&gt;Autoregressive : RNN&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;의도적으로 bias를 걸어주는 것을 inductive bias라 표현함&lt;/li&gt;
      &lt;li&gt;Social Graph, 3D Mesh, Molecular Graph는 illegular함. 물분자와 에탄올의 그래프가 모두 다름&lt;/li&gt;
      &lt;li&gt;주어진 그래프에 다르게 inductive bias를 걸 수 있을까?에 적합한 Graph neural network&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Node feature updates in GNNs
    &lt;ul&gt;
      &lt;li&gt;Graph Convolution networks
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ja9m0hc051c367q/2019-10-20%2017.13.21.jpg?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;Feature들이 벡터로 표현&lt;/li&gt;
          &lt;li&gt;노드가 어떻게 업데이트가 되는지를 표현하는 기본적인 식&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/tvllcles7vgbbzz/2019-10-20%2017.14.45.jpg?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;주변 사람과 connection을 의미하는 adjacency matrix&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Graph Attention Networks
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/irsjjmzfglugiee/2019-10-20%2017.15.54.jpg?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;관계를 더 고려해 feature update&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;self-attention, positonal encoding을 주로 사용함 =&amp;gt; 그래프 어텐션은 주변의 관계를 묘사할 때 어텐션을 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Message Passing Neural Networks
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/tvx6musidnxyakm/2019-10-20%2017.18.53.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;GRU&lt;/li&gt;
      &lt;li&gt;Edge passing이 있을 때 사용 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Learning tasks with GNN
    &lt;ul&gt;
      &lt;li&gt;Node-level prediction
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/lxna3k8cfzkypzt/2019-10-20%2017.20.32.jpg?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;노드 단위 예측&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Edge-level predictions
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/bhad5dzmpt508w9/2019-10-20%2017.20.46.jpg?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;유저, 아이템 노드가 있을 경우&lt;/li&gt;
          &lt;li&gt;주로 본 사람은 누구인가? =&amp;gt; 누가 뭘 봤다라는 connection 레이어를 예측하면 아이템의 관계를 inference 할 수 있음&lt;/li&gt;
          &lt;li&gt;Relational inference&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Graph-level prediction
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/6lhouzaecquotco/2019-10-20%2017.22.24.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;이 그래프 구조가 이 병을 해결할 수 있는가?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Graph generations
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/tbefh98741nip15/2019-10-20%2017.24.16.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;노드를 추가할 것인지?&lt;/li&gt;
      &lt;li&gt;엣지를 추가할 것인지?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Learning physical dynamics
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/2ztf1zwlzmk62vp/2019-10-20%2017.25.45.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;각자 다른 공들이 파티클이고 움직임(무슨 법칙이 있음)&lt;/li&gt;
      &lt;li&gt;움직임을 예측&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/552fokopox9t94b/2019-10-20%2017.26.38.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;더 궁금하시면 &lt;a href=&quot;https://github.com/SeongokRyu/Graph-neural-networks&quot;&gt;Graph Neural Networks Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;나만의-코퍼스는-없다-자연어처리-연구-데이터의-구축-검증-및-정제에-관하여&quot;&gt;나만의 코퍼스는 없다? 자연어처리 연구 데이터의 구축, 검증 및 정제에 관하여&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;조원익님&lt;/li&gt;
  &lt;li&gt;무엇을 위해 데이터를 만드는가?
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/yj1nagwclth75zm/2019-10-20%2017.39.15.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;코퍼스의 종류
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/lk5ztlu255pdmhj/2019-10-20%2017.41.34.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Annotation의 종류
    &lt;ul&gt;
      &lt;li&gt;통사(syntax)에서 의미(semantics)를 넘어 화용(pragmatics)가지!&lt;/li&gt;
      &lt;li&gt;이모션 태그, 다른 문장을 표현할 수 있는지? 말장난인지 아닌지 등&lt;/li&gt;
      &lt;li&gt;사실 영역의 경계가 점점 흐려지고 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MATTER cycle
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/abxlgo40iyjd730/2019-10-20%2017.45.25.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MAMA portion
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/qylwub4d3qdws6k/2019-10-20%2017.46.43.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;어노테이션은 2명 이상, 많을수록 좋음
    &lt;ul&gt;
      &lt;li&gt;주석자간 의견 일치도도 고려
        &lt;ul&gt;
          &lt;li&gt;Cohen’s Kappa&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;주석자
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/xm2kt61068nyeds/2019-10-20%2017.51.27.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;주석자들이 얼마나 언어학적 훈련을 받았는지 가늠을 해서 배정해야 함&lt;/li&gt;
      &lt;li&gt;언어 배경, L2 이상&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;케이스 스터디 1
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/pybno0sci1tz592/2019-10-20%2017.55.09.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;호출어 없이 알아서 반응하는 음성 대화 서비스&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/sr1poncg162v5oy/2019-10-20%2017.55.46.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/axx4ttgz17qd5xa/2019-10-20%2017.57.00.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;가이드라인 작성
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/d804msdgmp985hc/2019-10-20%2017.57.50.jpg?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;케이스 스터디 2
    &lt;ul&gt;
      &lt;li&gt;Keyphrase extraction&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/98drw07xyffbusq/2019-10-20%2017.59.45.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/c9i1nw4jkentuon/2019-10-20%2017.59.54.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ifn2x6fvppdkbhi/2019-10-20%2018.04.22.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정리
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/fxip05ihrpsaszt/2019-10-20%2018.05.52.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;행사-후기&quot;&gt;행사 후기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;기술적으로 깊은 이야기를 많이 진행해서 만족스러웠습니다
    &lt;ul&gt;
      &lt;li&gt;회사에서 사용할 수 있는 키워드도 꽤 얻었습니다!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;오랜만에 만났던 분들도 모두 반가웠습니다 :)&lt;/li&gt;
  &lt;li&gt;100분 넘는 분들이 일요일까지 오셔서 열정을 보여주셔서 자극받고 갑니다..!&lt;/li&gt;
  &lt;li&gt;그리고 Art Lab에서 이벤트하셨는데 제가 당첨되서 엄태웅님의 책을 받았습니다!!
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://www.yes24.com/Product/Goods/72231788&quot;&gt;대학원생 때 알았더라면 좋았을 것들&lt;/a&gt; 책 너무 좋으니 관심있으시면 꼭 보셔요 :)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다음엔 타임 테이블을 미리 공지해주셔도 좋을 것 같아요 /ㅁ/&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 20 Oct 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/etc/2019/10/20/tensorflow-kr-3th-meeting/</link>
        <guid isPermaLink="true">http://localhost:4000/etc/2019/10/20/tensorflow-kr-3th-meeting/</guid>
        
        <category>lecture</category>
        
        
        <category>etc</category>
        
      </item>
    
      <item>
        <title>팀원 성장시키기 : 발표 컨설팅</title>
        <description>&lt;ul&gt;
  &lt;li&gt;팀원을 성장시키는 다양한 방법 중, 개발 발표 컨설팅한 내용에 대해 작성한 글입니다
    &lt;ul&gt;
      &lt;li&gt;팀원들의 발표를 어떻게 동기부여하고 어떻게 발표 준비를 도왔는지에 대한 글입니다&lt;/li&gt;
      &lt;li&gt;데이터야놀자 2019에서 다음 발표를 도왔습니다
        &lt;ul&gt;
          &lt;li&gt;정민정님의 GAN을 활용한, 내 손글씨를 따라쓰는 인공지능&lt;/li&gt;
          &lt;li&gt;이창현님의 타다(TADA) 서비스의 데이터 웨어하우스 :
태초부터 현재까지&lt;/li&gt;
          &lt;li&gt;권윤환님의 모빌리티 데이터팀 신입 분석가의 1년 회고&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;팀원-성장시키기&quot;&gt;팀원 성장시키기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;회사에서 팀을 이끄는 역할을 하다보면, 팀원을 어떻게 더 빠르게 성장할 수 있도록 도울 수 있을까?를 고민하게 됩니다
    &lt;ul&gt;
      &lt;li&gt;우선 팀원이 성장할 의지를 가지고 있어야 하고&lt;/li&gt;
      &lt;li&gt;팀장이 팀원의 욕구를(바라는 커리어 등) 수시로 잘 파악해야 하고&lt;/li&gt;
      &lt;li&gt;욕구(바라는 커리어 등)와 회사에서 진행되는 일의 교집합을 잘 찾아 Task로 만들고, 적절하게 분배하면 좋다고 생각합니다&lt;/li&gt;
      &lt;li&gt;이 부분은 [&lt;a href=&quot;https://www.slideshare.net/zzsza/tf-9-160560910&quot;&gt;TF에서 팀 빌딩까지 9개월의 기록 : 성장하는 조직을 만드는 여정&lt;/a&gt;]에서 발표한 내용처럼, 팀원들과 계속 고민하고 실천하고 있습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;요즘 또 든 생각은 팀원들의 욕구는 계속 듣고 발전하며, 평소에 접하지 못했던 것을 하면 또 새롭게 성장하지 않을까?란 생각을 했습니다
    &lt;ul&gt;
      &lt;li&gt;단, 팀원들이 평소에 접하지 못했던 것 중 제가 경험했던 일이면 더 잘 도울 수 있을 것 같다고 생각했습니다&lt;/li&gt;
      &lt;li&gt;고민한 결과, 저는 과거에 광고 동아리에서 발표를 많이 했고,  경영학과에서 한학기에 6 전공 6 팀플 6 발표라는 경험, 개발 컨퍼런스 등에서 다양한 발표를 했기 때문에 발표에 대해 자신이 있었습니다&lt;/li&gt;
      &lt;li&gt;이번엔 팀원들을 발표하도록 권장하고, 발표의 모든 과정을 돕기로 결정했습니다&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/didaal9ffc9an8m/Screenshot%202019-10-19%2023.09.23.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;발표 컨설팅을 위해 제가 진행한 활동은 다음과 같습니다
    &lt;ul&gt;
      &lt;li&gt;발표가 좋은 이유 설명&lt;/li&gt;
      &lt;li&gt;발표할 의지가 있는 팀원 파악&lt;/li&gt;
      &lt;li&gt;발표할 컨퍼런스 찾기&lt;/li&gt;
      &lt;li&gt;발표 신청하기
        &lt;ul&gt;
          &lt;li&gt;발표 스토리 초안 작성 돕기&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;발표 자료 만드는 가이드라인 제시&lt;/li&gt;
      &lt;li&gt;발표 자료 초안 피드백&lt;/li&gt;
      &lt;li&gt;발표 자료 최종 피드백&lt;/li&gt;
      &lt;li&gt;발표 전 리허설&lt;/li&gt;
      &lt;li&gt;발표 후 자료 공유&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;발표가-좋은-이유&quot;&gt;발표가 좋은 이유&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;개발자에게 (개발자가 아니여도 모두에게 좋지만) 발표가 좋은 이유를 설명하면 좋습니다
    &lt;ul&gt;
      &lt;li&gt;단순히 “우리 회사 홍보할 겸 회사에서 일한거 발표 좀 해봐” 라는 수직적인 말과 함께 발표하라는 분도 있다고 들었습니다. 이런 방식은 노노.. 자발적인 의지가 중요합니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;(제가 생각하는) 발표가 좋은 이유 다음과 같습니다
    &lt;ul&gt;
      &lt;li&gt;1) 진행한 업무를 정리하는 시간
        &lt;ul&gt;
          &lt;li&gt;보통 회사에서 진행한 업무를 어딘가에 잘 메모해두지만, 발표용으로 이해하기 쉽게 정리하는 분들은 적은 것 같습니다(저도 그래요..!)&lt;/li&gt;
          &lt;li&gt;프로젝트가 끝난 후, 혹은 진행 과정에 한번 업무를 정리하면 자신이 했던 일을 정리하며 좋고, 추후에 다른 분들이 입사하셔도 발표 자료를 전달하며 이런 흐름으로 진행했다고 알릴 수 있습니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) 공식적으로 자신이 진행한 일을 외부에 알릴 수 있는 수단
        &lt;ul&gt;
          &lt;li&gt;보통 회사에서 진행한 일은 대부분 “대외비” 취급하는 경우가 있습니다. 이럴 경우 자신이 진행한 일에 대해 공식적으로 말하기 꺼려집니다&lt;/li&gt;
          &lt;li&gt;단, 발표를 하면 (필요할 경우 내부 피드백을 거치며) 공식적으로 자신이 진행한 일을 어느정도 가이드라인 하에 알릴 수 있기 때문에 커리어에 도움이 된다 생각합니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;3) 지식 나눔
        &lt;ul&gt;
          &lt;li&gt;자신이 가진 지식을 누군가에게 나누는 동시에 다른 분들도 자신의 지식을 공유하는 경우가 있습니다. 공유하는 문화가 더 아름다운 개발 생태계를 만든다고 생각합니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;4) 본인 커리어에 도움
        &lt;ul&gt;
          &lt;li&gt;2)의 맥락과 유사한데, 외부 발표를 통해 자신을 알릴 수 있는 계기가 됩니다. 학생이라면 추후 첫 취업에 영향을 미칠 수 있고, 이미 회사를 다니시는 분도 추후 먼 훗날의 커리어에 도움이 될 수 있습니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;5) 회사 PR
        &lt;ul&gt;
          &lt;li&gt;회사 업무에 대해 이야기하는 경우엔 회사의 기술력을 마음껏 뽐낼 수 있습니다! 회사에 더 좋은 분이 올 수 있는 계기가 될 수 있습니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;발표할-의지가-있는-팀원-파악하기&quot;&gt;발표할 의지가 있는 팀원 파악하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;발표가 좋은 이유를 팀원 개인에게도 말하고, 팀 전체에 말하고, 같이 일하는 동료에게도 말하고, 제가 운영하는 커뮤니티에도 말하며 발표할 의사가 있는 분들을 찾았습니다
    &lt;ul&gt;
      &lt;li&gt;꼭 팀원이 아니어도, 같이 일하는 동료와 커뮤니티에서 만난 인연, 대학생 분들 등 다양한 분을 돕는 것이 좋다고 생각해 총 3분의 의지를 확인했습니다&lt;/li&gt;
      &lt;li&gt;의지를 확인하기 위해 3번 정도 말한 것 같습니다..!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;회사에서 저희 팀 소속이신 팀원&lt;/li&gt;
  &lt;li&gt;회사에서 같이 일하는 동료&lt;/li&gt;
  &lt;li&gt;개발자 글쓰기 모임 글또에서 활동하시는 분&lt;/li&gt;
  &lt;li&gt;모두 “데이터” 관련 일을 하거나 데이터 업을 희망하기 때문에 포괄적인 “데이터야놀자 2019”에 발표하면 좋을 것 같다 말씀드렸습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;발표-신청하기&quot;&gt;발표 신청하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;개발 컨퍼런스에 발표하고 싶은 의지만 있다고 모두 발표할 수 있는 것은 아닙니다
    &lt;ul&gt;
      &lt;li&gt;컨퍼런스의 퀄리티 혹은 목적에 맞도록 사전에 발표 내용을 제출하고 그 내용을 토대로 최종 발표자가 선정됩니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 발표자 신청 과정부터 잘 통과하지 못하면 결국 발표를 못하기 때문에, 이 부분부터 같이 진행했습니다&lt;/li&gt;
  &lt;li&gt;신청하기 위해 파악한 내용은 다음과 같습니다
    &lt;ul&gt;
      &lt;li&gt;1) 개발 컨퍼런스의 슬로건과 유사한 발표 고민하기
        &lt;ul&gt;
          &lt;li&gt;개발 컨퍼런스에서 슬로건이 없는 경우도 있지만 보통은 작은 가이드라인이라도 있는 경우가 많습니다&lt;/li&gt;
          &lt;li&gt;예를 들면 파이콘 한국 2019의 슬로건은 “Connect the Pythonistas” 입니다. 다양한 분야의 파이써니스타를 연결한다는 의도입니다&lt;/li&gt;
          &lt;li&gt;데이터야놀자 2019는 “현업에서 얻은 데이터 경험”, “현장 또는 나와 함께하는 데이터” 를 큰 테마로 가졌습니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) 발표의 스토리라인 잡기
        &lt;ul&gt;
          &lt;li&gt;각자 발표할 내용과 무엇을 전달하고 싶은지 잘 고민해야 합니다&lt;/li&gt;
          &lt;li&gt;ㄱ) 발표를 통해 어떤 내용을 전달할 것인가?&lt;/li&gt;
          &lt;li&gt;ㄴ) 발표의 예상 청중은?&lt;/li&gt;
          &lt;li&gt;ㄷ) 발표의 예상 난이도는? 난이도가 있다면 어느 정도 알아야 수월하게 들을 수 있는가?&lt;/li&gt;
          &lt;li&gt;ㄹ) 희망하는 예상 시간대는?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3분과 대화를 한 결과, 모두 각자가 진행한 업무 또는 프로젝트가 있었습니다. 그 내용을 최대한 잘 반영해 발표 신청서에 담았습니다
    &lt;ul&gt;
      &lt;li&gt;발표 신청서를 정성스럽게 작성하고, 의도에 맞는다면 잘 될거라 믿었습니다&lt;/li&gt;
      &lt;li&gt;발표 신청서에 위에 말한 ㄱ ~ ㄹ + 발표의 서론/본론/결론을 작성하도록 했습니다(이 때 작성한 내용과 실제 발표의 흐름이 달라도 괜찮습니다)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서론/본론/결론의 스토리라인 초안 작성을 도울 때 아래와 같이 가이드 드렸습니다
    &lt;ul&gt;
      &lt;li&gt;발표를 위한 말랑말랑한 Intro(서론)이 있는가? 흥미 유발할 수 있는가?&lt;/li&gt;
      &lt;li&gt;본론 : 진행한 업무 / 프로젝트 흐름대로 일단 작성&lt;/li&gt;
      &lt;li&gt;결론 : 그래서 어떤 내용을 전달하고 싶은지 다시 정리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;발표-자료-초안-피드백&quot;&gt;발표 자료 초안 피드백&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;발표 자료 초안 피드백은 &lt;code class=&quot;highlighter-rouge&quot;&gt;발표일 -7일&lt;/code&gt; 쯤에 했습니다
    &lt;ul&gt;
      &lt;li&gt;보통 마감일에 자료를 만드는 경우가 있는데, 이럴 경우 발표를 많이 해보지 못한 분들은 발표 연습을 충분히 하지 못하는 경우가 있습니다&lt;/li&gt;
      &lt;li&gt;따라서 초안 피드백을 발표일 1주 전에 하고, 그 사이에 최종 자료를 만드는 방식을 제안했습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;초안 피드백에 보는 내용은 다음과 같습니다
    &lt;ul&gt;
      &lt;li&gt;1) 전달하고 싶은 내용을 한줄로 설명하면 무엇인가요?
        &lt;ul&gt;
          &lt;li&gt;이 부분은 발표 전체를 관통할 수 있는 내용이 있는지, 발표의 무게 중심을 잡을 수 있는 용도로 여쭤봤습니다&lt;/li&gt;
          &lt;li&gt;이 부분을 통해 자신이 어느정도 이야기할지(가끔 이야기가 산으로 가거나 끝없이 아무말 대잔치하는 분들이 있어서..) 고민하셨습니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) 내용을 단순 “나열”한 것이 아닌 적절한 “스토리”가 같이 있는지?
        &lt;ul&gt;
          &lt;li&gt;발표 시간에 따라 다르지만 25분 혹은 40분 발표는 구성에 따라 짧게 느껴질 수도, 길게 느껴질 수도 있습니다&lt;/li&gt;
          &lt;li&gt;짧게 느껴지는 경우엔 발표자분의 발표력이 좋거나, 흥미로운 내용을 전달했거나, 스토리가 적절하게 있는 경우라고 생각합니다&lt;/li&gt;
          &lt;li&gt;발표 경험이 적으면 발표력이 좋지 않을 수 있기 때문에, 최대한 흥미로운 내용 + 스토리를 적절히 조합하도록 권장하고 있습니다&lt;/li&gt;
          &lt;li&gt;스토리라고 하면 “왜 이 일을 하게 되었는가? 어떤 생각을 하다 이렇게 했는가?”로 시작해 의식의 흐름을 나열하곤 합니다&lt;/li&gt;
          &lt;li&gt;“이 일을 하며 힘들었던 상황은? 그걸 어떻게 극복했는가?”&lt;/li&gt;
          &lt;li&gt;더 쉽게 이해할 수 있도록 도식화를 할 수 있지만 일단 초안 피드백에선 스킵합니다. 일단 전체적인 틀을 채우고 시각화나 도식화는 발표 전 최종 피드백에서 진행합니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;3) 발표를 보는 분들이 유용하게 얻어갈 수 있는 내용이 있는지?
        &lt;ul&gt;
          &lt;li&gt;발표를 통해 정보를 얻는 경우가 많습니다. 이 부분은 발표를 듣는 청자분들에 따라 달라질 수 있지만, 저는 발표를 보는 분들이 카메라를 들고 사진을 찍고 싶어하는 내용이 있는지? 정도로 생각하고 있습니다&lt;/li&gt;
          &lt;li&gt;또는 자료 조사를 충분히 했던 내용 정리해서 공유하거나, 트러블 슈팅했던 내용을 공유하곤 합니다&lt;/li&gt;
          &lt;li&gt;이 부분이 쌓이면 핵심 포인트가 많다고 생각합니다&lt;/li&gt;
          &lt;li&gt;저는 항상 큰 이야기가 끝나면 한 장에 요약하도록 요청했습니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 부분에선 디테일을 보기 보다 발표의 큰 흐름, 주제, 발표의 핵심 포인트 위주로 피드백 드리고 시각화할 수 있는 내용은 아이디어 위주로 드렸습니다
    &lt;ul&gt;
      &lt;li&gt;예시로 제가 발표한 &lt;a href=&quot;https://www.slideshare.net/zzsza/little-big-data-1&quot;&gt;Little Big Data #1. 바닥부터 시작하는 데이터 인프라&lt;/a&gt;를 예시로 공유드렸습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;오프라인과 온라인에서 둘 다 피드백드렸는데, 온라인에서 드린 내용을 예시로 보여드리면 아래와 같습니다
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/p1jm3vpo6kx14vz/Screenshot%202019-10-19%2023.23.09.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/yo1lt8r5bf7ps5l/Screenshot%202019-10-19%2023.27.01.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;발표-자료-최종-피드백&quot;&gt;발표 자료 최종 피드백&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;초안 피드백 후 3~4일 뒤, 즉 &lt;code class=&quot;highlighter-rouge&quot;&gt;발표일 -3일&lt;/code&gt; 쯤에 그 순간까지 완성한 자료를 통해 최종 피드백 드렸습니다
    &lt;ul&gt;
      &lt;li&gt;1) 이 최종 피드백에선 내용을 크게 틀지 않고 주어진 시간 안에 발표를 마무리할 수 있는지?
        &lt;ul&gt;
          &lt;li&gt;발표일이 가까워지면 내용을 크게 더 넣으려고 하다가 오히려 발표를 더 못할수도 있기 때문에 내용을 크게 틀지 않는 선에서 피드백 드리는 것이 중요한 핵심입니다&lt;/li&gt;
          &lt;li&gt;발표 시간이 총 40분이고 크게 전달할 내용이 3개라면 intro 5분, 첫 이야기 8분, 두번째 이야기 8분, 세번째 이야기 8분, 마무리 5분 정도로 말씀드렸습니다(강조하고 싶은 부분 위주로 조정 가능하고, 타이트하게 시간을 계산하도록 했습니다)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) 시각적 표현에서 더 부드럽고 재미있게 할 수 있는지?
        &lt;ul&gt;
          &lt;li&gt;시각적 표현을 하느냐에 따라 발표력이 달라진다고 생각하고 있습니다&lt;/li&gt;
          &lt;li&gt;이미지를 구글에서 어떻게 검색할지, 어떻게 추상화하면 좋을지 등을 같이 고민합니다&lt;/li&gt;
          &lt;li&gt;Icon 이미지의 경우 &lt;a href=&quot;https://www.flaticon.com/&quot;&gt;Flaticon&lt;/a&gt;을 사용하면 깔끔할 수 있다는 점을 말씀드렸습니다&lt;/li&gt;
          &lt;li&gt;단, 저작권 표시는 꼭-!&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/e2zsw00b1u6rtdq/Screenshot%202019-10-19%2023.36.48.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;3) 단순 나열 같은 흐름이 있는지? 발표의 구성을 효과적으로 어떻게 바꿀까?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;초안 - 최종 피드백의 경계가 사실 오묘하긴 하지만, 시기에 따라 집중하는 부분이 달랐습니다&lt;/li&gt;
  &lt;li&gt;피드백 예시입니다
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/4uh4vr7rk7el83c/Screenshot%202019-10-19%2023.31.00.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;발표-전-리허설&quot;&gt;발표 전 리허설&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;발표일 -1일&lt;/code&gt;에 제가 컨설팅 해드리는 3분을 모두 회사 사무실로 불러 사전 리허설을 진행했습니다
    &lt;ul&gt;
      &lt;li&gt;이왕이면 프레젠테이션 포인터를 구해서 서서 실전처럼 발표할 수 있으면 좋습니다(없다면 마우스라도 사용)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/a6qrbwkvxtedstn/2019-10-18%2021.56.35.jpg?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;이 때 주로 보는 것은 다음과 같습니다
    &lt;ul&gt;
      &lt;li&gt;1) 주어진 시간 안에 잘 발표하는지?
        &lt;ul&gt;
          &lt;li&gt;주어진 시간 기준으로 너무 빨리 끝내면 유용한 내용이 적을수도 있고, 혹은 말을 너무 빨리하는 습관이 있을 수 있습니다&lt;/li&gt;
          &lt;li&gt;주어진 시간 기준으로 너무 늦게 끝내면 행사에 차질이 생길 수 있고, 발표하다가 급한 마음에 발표의 뒷 부분을 빠르게 끝내느라 정신없을 수 있습니다&lt;/li&gt;
          &lt;li&gt;주어진 발표 시간에서 질문 시간 5분을 제외하고 적당하게 끝내는지를 파악했고, 만약 발표가 길어 질문 시간이 없는 경우도 있었습니다&lt;/li&gt;
          &lt;li&gt;스탑워치를 통해 1장당 몇 초 사용했는지를 기록해 전달했습니다&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/cowqi0w413iapmp/Screenshot%202019-10-19%2023.40.57.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) 발표자의 특징 파악해서 전달
        &lt;ul&gt;
          &lt;li&gt;실제 발표 시간과 리허설의 시간이 비슷할 수 있지만 사람에 따라 달라질 수 있습니다&lt;/li&gt;
          &lt;li&gt;발표하는 톤과 평소에 알던 성격 기반으로 실제 발표에선 말이 빨라지는 스타일일지, 말이 느려지는 스타일일지에 대한 제 의견을 말씀드렸습니다&lt;/li&gt;
          &lt;li&gt;또한 리허설을 하다가 목이 약한 것 같은 분이 계시면 발표 전에 꿀물이나 도라지차 마시고, 발표 전에 꼭 물을 챙겨가도록 말씀드렸습니다(목 관리 중요..)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;3) 실전 발표시 유용한 Tip
        &lt;ul&gt;
          &lt;li&gt;발표에서 갑자기 예상치 않은 TMI를 할 수도 있는데(혹은 갑자기 예상이 없던 드립 등..) 그럴 분들은 없었지만 그냥 딱 지금까지 한 것만 하는 것이 좋을 것 같다 정도로 제안했습니다&lt;/li&gt;
          &lt;li&gt;발표가 너무 일찍 끝나면 질문을 많이 받거나 중간 중간에 시간을 체크해서 발표 시간을 조절하는 방법&lt;/li&gt;
          &lt;li&gt;발표에서 죄송합니다 &amp;lt;- 같은 표현을 굳이 쓰지 말고 당당하게 진행하면 좋다 등을 이야기했습니다(굳이 쓰지 않아도 될 표현)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최대한 잘할 수 있다는 응원과 격려를 가득! 했습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;발표&quot;&gt;발표&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;실제 발표하는 모습을 잘 지켜보고 모두 사진을 찍어드렸습니다&lt;/li&gt;
  &lt;li&gt;발표 전에 떨려하시는 분 계시면 가서 대화 해드리고 멘탈 관리(?)를 해드렸습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;발표-후-자료-공유&quot;&gt;발표 후 자료 공유&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;발표만 했다고 끝이 아닌, 자료 공유도 적절하게 잘 하면 좋습니다&lt;/li&gt;
  &lt;li&gt;슬라이드쉐어 또는 스피커덱 추천드리고 있습니다
    &lt;ul&gt;
      &lt;li&gt;슬라이드쉐어는 조금 더 생태계가 크고, 한번 올리면 수정 불가능, 키노트에서 작성한 내용은 수정이 필요 등의 특징&lt;/li&gt;
      &lt;li&gt;스피커덱은 수정은 가능하지만 생태계가 (상대적으로) 작음&lt;/li&gt;
      &lt;li&gt;기존에 슬라이드쉐어를 많이 사용하셨다면 아예 다 스피커덱으로 옮기는 방법도 추천드리고 있습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;키노트 자료를 슬라이드쉐어에 올리실 경우 터미널에서 아래 내용을 입력해주셔야 한국어가 잘 보입니다. &lt;a href=&quot;https://item4.github.io/2016-10-31/Way-to-Use-Homeland-Fonts-on-SlideShare/&quot;&gt;관련 링크&lt;/a&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  LANG=C LC_ALL=C sed -i '' s'|/Registry (Adobe) /Ordering (Korea1) /Supplement [0-9]|/Registry(Adobe) /Ordering(Identity) /Supplement 0|g' 파일.pdf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;발표 자료를 업로드한 후, 필요하다면 페이스북 그룹에 공유해 자신이 진행한 내용을 컨퍼런스에 오지 않은 분들도 알 수 있도록 공유하도록 권장하고 있습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;진행하며-느낀-점&quot;&gt;진행하며 느낀 점&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사실 처음엔 “컨설팅”은 생각보다 수월하겠지? 란 생각을 했는데 사실 제가 발표 준비하는 것보다 더 많은 시간을 투자했습니다
    &lt;ul&gt;
      &lt;li&gt;하지만 주변 분들(팀원)이 성장하는 모습을 볼 수 있었고, 앞으로도 시간이 생긴다면 이런 부분을 같이 고민하고 나누고 싶습니다 :)&lt;/li&gt;
      &lt;li&gt;다만.. 무상으로 하기엔 시간을 너무 많이 투자해서 고민이 되네요..!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;제 빡센(?) 피드백 받으며 발표를 준비하신 정민정님, 이창현님, 권윤환님 고생하셨습니다!&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 20 Oct 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/diary/2019/10/20/helping-presentation/</link>
        <guid isPermaLink="true">http://localhost:4000/diary/2019/10/20/helping-presentation/</guid>
        
        <category>diary</category>
        
        
        <category>diary</category>
        
      </item>
    
      <item>
        <title>Full Stack Deep Learning Bootcamp 정리</title>
        <description>&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://fullstackdeeplearning.com/march2019&quot;&gt;Spring 2019 Full Stack Deep Learning Bootcamp&lt;/a&gt;의 영상을 보고 정리한 내용입니다
    &lt;ul&gt;
      &lt;li&gt;Lab(실습), Guest Lecture는 정리하지 않았습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;부트캠프-후기&quot;&gt;부트캠프 후기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;오프라인에서 참석한 것은 아니지만, 강의를 듣고 후기를 남김&lt;/li&gt;
  &lt;li&gt;일단 강의가 매우 고퀄!!!!!!(감동)&lt;/li&gt;
  &lt;li&gt;국내에선 이런 내공을 담은 강의를 거의 보지 못했음&lt;/li&gt;
  &lt;li&gt;프로젝트를 어떻게 해야되는가, 프로젝트 우선순위를 선정하는 부분도 알려줘서 매우 좋았음. 실제 현업에서도 매번 고민하는 이슈들(Lecture 2)&lt;/li&gt;
  &lt;li&gt;데이터를 어떻게 다룰까에 대해 말해주는 점이 좋았음. 단순 로컬/클라우드만 하는게 아니라 Database도 말해줌(lecture 6)&lt;/li&gt;
  &lt;li&gt;팀 구성이 어떻게 되는지, 직군이 무엇이 있는지 알려준 점이 좋았음(lecture 7)&lt;/li&gt;
  &lt;li&gt;딥러닝 트러블 슈팅에 대해 알려줘서 좋았음. 언더피팅, 오버피팅일 때의 전략을 제공함(lecture 10)&lt;/li&gt;
  &lt;li&gt;모델의 성능 개선할 때 결과를 어떻게 봐야하는지에 대한 직관을 얻게 해줌(lecture 10)&lt;/li&gt;
  &lt;li&gt;이 부트캠프는 단순히 강의만 듣는게 끝이 아니고, 꼭 Lab(실습)을 해야함!! 코드를 보면 현업에서 사용할 소재들이 꽤 많음(Lambda 배포라던가) =&amp;gt; &lt;a href=&quot;https://github.com/full-stack-deep-learning/fsdl-text-recognizer-project&quot;&gt;Github&lt;/a&gt; 참고&lt;/li&gt;
  &lt;li&gt;앞으로 어떤 분야를 연구할 것인가에 대해 흥미로운 주제를 던져주는 부분도 좋았음(lecture 13)&lt;/li&gt;
  &lt;li&gt;단, Serving하는 부분에 대해 엄청 깊게 알려주는건 아니고, 부트캠프답게 큰 그림을 그려주고 실습을 같이 하며 하나를 구현해봄 =&amp;gt; 이 부분은 결국 키워드를 캐치해서 스스로 해보는게 좋을듯..!
    &lt;ul&gt;
      &lt;li&gt;MLOps는 &lt;a href=&quot;https://github.com/EthicalML/awesome-production-machine-learning&quot;&gt;Awesome Production Machine Learning&lt;/a&gt; 자료가 매우 풍부하며, Facebook &lt;a href=&quot;https://www.facebook.com/groups/MLOpsKR/&quot;&gt;MLOps KR&lt;/a&gt; 그룹도 있습니다 :)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;어떤-사람에게-이-강의가-좋을까요&quot;&gt;어떤 사람에게 이 강의가 좋을까요?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;어느정도 머신러닝/딥러닝 공부를 한 후, 실제 서비스 구현에 흥미있는 분&lt;/li&gt;
  &lt;li&gt;개발 베이스에서 머신러닝/딥러닝 공부를 하셨던 분&lt;/li&gt;
  &lt;li&gt;프로젝트를 어떻게 하면 좋을지 고민되는 분&lt;/li&gt;
  &lt;li&gt;딥러닝 프로젝트 트러블슈팅에 대해 고민되는 분&lt;/li&gt;
  &lt;li&gt;Production 과정 전반에 대해 관심있는 분&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;bootcamp의-목적&quot;&gt;Bootcamp의 목적&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;개발자가 딥러닝에 친숙해지기 위한 Hands-on 프로그램&lt;/li&gt;
  &lt;li&gt;모델 학습은 딥러닝 Production의 일부분이고, 이 코스에선 Production화하기 위한 모든 것들을 가르칠 예정
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Problem&lt;/strong&gt;을 명확히하고 프로젝트의 &lt;strong&gt;cost&lt;/strong&gt;를 측정&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Data&lt;/strong&gt;를 찾고, 전처리하고, 라벨링&lt;/li&gt;
      &lt;li&gt;적절한 &lt;strong&gt;Framework&lt;/strong&gt;와 &lt;strong&gt;Infra&lt;/strong&gt;를 선정&lt;/li&gt;
      &lt;li&gt;학습의 &lt;strong&gt;reproducibility&lt;/strong&gt; 관련 트러블슈팅&lt;/li&gt;
      &lt;li&gt;대규모 모델 &lt;strong&gt;Deploy&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컴퓨터 비전과 자연어 처리 시스템을 프러덕션 환경에 배포하는 프로젝트를 진행
    &lt;ul&gt;
      &lt;li&gt;선택적 필기 시험으로 지식을 테스트&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/c2lco1wr5q9szvq/Screenshot%202019-10-05%2013.20.27.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로젝트
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/3e8q7z0q5ms0mv5/Screenshot%202019-10-05%2013.20.42.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;lecture-1--introduction&quot;&gt;Lecture 1 : Introduction&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://fullstackdeeplearning.com/assets/slides/fsdl_1_intro.pdf&quot;&gt;발표 자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Organizer
    &lt;ul&gt;
      &lt;li&gt;Pieter Abbeel : 버클리 교수님, Covariant.AI  Scientist&lt;/li&gt;
      &lt;li&gt;Sergey Karayev : STEM AI Head&lt;/li&gt;
      &lt;li&gt;Josh Tobin : Research Scientist at OpenAI&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Object Detection in Computer Vision
    &lt;ul&gt;
      &lt;li&gt;2012년까지의 대세
        &lt;ul&gt;
          &lt;li&gt;Image =&amp;gt; Hand-engineered features(SIFT, HOG, DAISY) =&amp;gt; SVM =&amp;gt; 분류&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;딥러닝 이후
        &lt;ul&gt;
          &lt;li&gt;Image =&amp;gt; 8 레이어 뉴럴넷 =&amp;gt; 분류&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;딥러닝이 발전한 예시를 보여줌(다양한 업계)&lt;/li&gt;
  &lt;li&gt;Google, OpenAI, Facebook, Uber 등 다양한 딥러닝 엔지니어와 리더들과 이야기해서 컨텐츠를 만듬&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;lecture-2--machine-learning-projects&quot;&gt;Lecture 2 : Machine Learning Projects&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;목표
    &lt;ul&gt;
      &lt;li&gt;머신러닝 프로젝트를 이해하기 위한 프레임워크 도입&lt;/li&gt;
      &lt;li&gt;머신러닝 프로젝트 Best Practices&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;머신러닝 프로젝트 Lifecycle
    &lt;ul&gt;
      &lt;li&gt;1) Planning &amp;amp; Project setup
        &lt;ul&gt;
          &lt;li&gt;어떤 프로젝트를 하기로 했는지&lt;/li&gt;
          &lt;li&gt;요구사항, 목표 설정&lt;/li&gt;
          &lt;li&gt;리소스 할당 등&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) Data Collection &amp;amp; Labeling
        &lt;ul&gt;
          &lt;li&gt;데이터 수집&lt;/li&gt;
          &lt;li&gt;센서 설치&lt;/li&gt;
          &lt;li&gt;annotation 노가다 등&lt;/li&gt;
          &lt;li&gt;그러나 데이터를 얻기 너무 어려움&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;3) Training &amp;amp; debugging
        &lt;ul&gt;
          &lt;li&gt;OpenCV로 베이스라인 구현&lt;/li&gt;
          &lt;li&gt;SoTA 모델 찾고 구현&lt;/li&gt;
          &lt;li&gt;구현체 디버깅&lt;/li&gt;
          &lt;li&gt;Task에 맞도록 모델 개선&lt;/li&gt;
          &lt;li&gt;잘 안되면
            &lt;ul&gt;
              &lt;li&gt;데이터를 더 수집&lt;/li&gt;
              &lt;li&gt;labeling이 신뢰할 수 없음을 깨달음&lt;/li&gt;
              &lt;li&gt;Task가 어려운 것을 깨닫고 각각의 trade off를 비교해 어떤 것이 제일 중요한가 고민&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;4) Deploying &amp;amp; testing
        &lt;ul&gt;
          &lt;li&gt;프로토타입&lt;/li&gt;
          &lt;li&gt;테스트하고 프러덕션화&lt;/li&gt;
          &lt;li&gt;그러나 프러덕션에서 작동 안될 수 있음
            &lt;ul&gt;
              &lt;li&gt;training data와 deployment의 데이터의 mismatching을 고치고&lt;/li&gt;
              &lt;li&gt;데이터를 더 수집&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Metric &amp;amp; Performance
        &lt;ul&gt;
          &lt;li&gt;선택한 Metric이 사용자 행동을 유지하지 않음 =&amp;gt; 다시 고민&lt;/li&gt;
          &lt;li&gt;프러덕션시 Performance가 좋지 않음(더 빠르거나 정확해야 할까?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;더 알아야 하는 것
        &lt;ul&gt;
          &lt;li&gt;도메인에서 SOTA가 뭔지 확인
            &lt;ul&gt;
              &lt;li&gt;가능하면 이해하고&lt;/li&gt;
              &lt;li&gt;다음에 무엇을 시도할지 알아야 함&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/lw56aw0jm7fn74y/Screenshot%202019-10-05%2014.17.53.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/oco7mwpicoxabb7/Screenshot%202019-10-05%2014.18.11.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;강의의 나머지 개요
    &lt;ul&gt;
      &lt;li&gt;프로젝트 우선 순위 지정 및 목표 선택&lt;/li&gt;
      &lt;li&gt;모델을 평가할 지표 선택&lt;/li&gt;
      &lt;li&gt;비교의 기준이 될 베이스라인 선택&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로젝트 우선 순위를 정하는 방법
    &lt;ul&gt;
      &lt;li&gt;1) 영향력이 큰 ML 문제
        &lt;ul&gt;
          &lt;li&gt;파이프라인의 복잡한 부분이 있는가&lt;/li&gt;
          &lt;li&gt;간단한 예측이 가치가 있는가&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/2vncihdy51pvefq/Screenshot%202019-10-05%2020.01.38.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/g9tjvw3a0dm3kan/Screenshot%202019-10-05%2020.03.01.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;Feasibility(실행 가능성)
            &lt;ul&gt;
              &lt;li&gt;데이터 사용 유무, 정확도 요구사항, 문제의 어려움이 모여 Cost를 만듬&lt;/li&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/hqayevkl47sha10/Screenshot%202019-10-05%2020.05.40.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) ML 프로젝트의 Cost는 데이터의 가용성에 의해 결정되지만 정확성 요구도 큰 역할을 함(예 : 95%의 정확도는 가져야 해!)
        &lt;ul&gt;
          &lt;li&gt;Accuracy requirements가 중요한 이유
            &lt;ul&gt;
              &lt;li&gt;높은 성능까지 가려면 cost가 지수함수처럼 증가함&lt;/li&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/6c7qc2chvvbresd/Screenshot%202019-10-05%2020.21.38.png?raw=1&quot; /&gt;&lt;/li&gt;
              &lt;li&gt;제품 설계로 이런 Accuracy 요구를 줄일 수 있음(=목적이나 활용 방법에 따라 다르게 할 수 있다는 뜻)&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9p85w0c7h4nh1xj/Screenshot%202019-10-05%2020.24.04.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/zr0jc4s97g7urt1/Screenshot%202019-10-05%2020.24.53.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;정리
        &lt;ul&gt;
          &lt;li&gt;1) 영향력이 큰 ML 문제를 찾으려면, 파이프라인의 복잡한 부분과 cheap prediction이 가치있는 곳을 찾아보기&lt;/li&gt;
          &lt;li&gt;2) ML 프로젝트이 cost는 데이터의 가용성 + 정확도 요구사항에 의해 결정됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;지표 선택의 핵심
    &lt;ul&gt;
      &lt;li&gt;1) 현실 세계는 지저분하고, 일반적으로 많은 측정 항목에 관심있음&lt;/li&gt;
      &lt;li&gt;2) 그러나 머신러닝 시스템은 단일 숫자를 최적화할 때 가장 잘 작동함&lt;/li&gt;
      &lt;li&gt;3) 결과적으로 metric 결합해서 공식을 만들어야 함&lt;/li&gt;
      &lt;li&gt;4) 공식은 변경될 수 있음&lt;/li&gt;
      &lt;li&gt;어떤 Metric이 좋은가?
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/mt5moo1gh29y5vw/Screenshot%202019-10-05%2020.32.00.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Metric Combine
        &lt;ul&gt;
          &lt;li&gt;Simple average, weighted average
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/zwl37f6aopssdc8/Screenshot%202019-10-05%2020.33.42.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;threshold n-1 metric, n번째 평가 등
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/3w0yg4x3qob6b5u/Screenshot%202019-10-05%2020.33.59.png?raw=1&quot; /&gt;&lt;/li&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/xh0noyhyh93v18e/Screenshot%202019-10-05%2020.34.27.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;복잡하고 도메인 특화된 공식
            &lt;ul&gt;
              &lt;li&gt;Average precision(AP) = curve의 아래 지역&lt;/li&gt;
              &lt;li&gt;mAP = mean AP&lt;/li&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ogvjyh66l0tkqhc/Screenshot%202019-10-05%2020.34.45.png?raw=1&quot; /&gt;&lt;/li&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/o19d04r4igdpvte/Screenshot%202019-10-05%2020.35.06.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Pose estimation Metric 고르는 예시
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/42br20980u46d6w/Screenshot%202019-10-05%2020.38.22.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;Evaluate current performance
            &lt;ul&gt;
              &lt;li&gt;Train a few models&lt;/li&gt;
              &lt;li&gt;현재 모델로 어떤 문제가 있는지 파악할 수 있음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/t27ej7kwqejypcd/Screenshot%202019-10-05%2020.39.16.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/pw2zda0g656t8z8/Screenshot%202019-10-05%2020.39.28.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;베이스라인 선택의 핵심
    &lt;ul&gt;
      &lt;li&gt;1) 베이스라인은 모델 성능에 대한 하한선을 제공(최소한 이거 이상은 해야한다)&lt;/li&gt;
      &lt;li&gt;2) 하한선이 엄격할수록 더 유용함(출판된 내용, 사람보다 좋다는 기준 등)&lt;/li&gt;
      &lt;li&gt;베이스라인이 중요한 이유
        &lt;ul&gt;
          &lt;li&gt;같은 모델이 다른 베이스라인을 가지면 다음 행동이 달라짐&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/cwa1u1nj5hyt8ri/Screenshot%202019-10-05%2020.44.47.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;베이스라인을 찾을 수 있는 곳
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/fwqlem5aakbm9zi/Screenshot%202019-10-05%2020.47.23.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;Scripted baseline의 예시 : OpenCV 스크립트, Rule based 방법 등&lt;/li&gt;
          &lt;li&gt;Simple ML baseline의 예시 : 일반적인  feature based model(bag-of-words classifier), linear classifier, Basic neural network model(vgg without batch norm, weight norm) 등&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;사람 관련 베이스라인을 어떻게 만들 수 있을까
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9qttjlnauxycpc7/Screenshot%202019-10-05%2020.48.52.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;질문
    &lt;ul&gt;
      &lt;li&gt;머신러닝 모델이 잘못되었다는 것을 어떻게 방지할 수 있을까?
        &lt;ul&gt;
          &lt;li&gt;좋은 질문. 모델의 confidence를 사용&lt;/li&gt;
          &lt;li&gt;그러나 머신러닝에서 여전히 어려운 문제. 모델은 자주 잘못되었는지 모름&lt;/li&gt;
          &lt;li&gt;매우 적대적인 사례를 넣어서 어떻게 나오는지 보는 방법도 있고, 고민이 필요&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;lecture-3--intro-to-the-text-reecognizer-project&quot;&gt;Lecture 3 : Intro to the Text Reecognizer Project&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://fullstackdeeplearning.com/assets/slides/fsdl_3_project_intro.pdf&quot;&gt;발표 자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;프로젝트 Architecture
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/x39mv56l4v489ti/Screenshot%202019-10-05%2021.28.33.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;POST request =&amp;gt; 이미지 Decode =&amp;gt; Line Detector =&amp;gt; Line Text Recognizer =&amp;gt; Encode Response의 흐름&lt;/li&gt;
      &lt;li&gt;LineDetector와 LineTextRecognizer가 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실습 개요
    &lt;ul&gt;
      &lt;li&gt;Lab 1: Codebase walkthrough&lt;/li&gt;
      &lt;li&gt;Lab 2: Single-character prediction. Before predicting full lines, try a simpler problem&lt;/li&gt;
      &lt;li&gt;Lab 3: LineTextRecognizer. Build a synthetic dataset. LSTM + CTC loss model&lt;/li&gt;
      &lt;li&gt;Lab 4: Tools for experimentation. Weights &amp;amp; Biases, parallel experiment running&lt;/li&gt;
      &lt;li&gt;Lab 5. Experimentation. Try some things and run some things overnight&lt;/li&gt;
      &lt;li&gt;Lab 6. LineDetector. Train the line detection model&lt;/li&gt;
      &lt;li&gt;Lab 7. Data. Managing data, including label and versioning&lt;/li&gt;
      &lt;li&gt;Lab 8. Continuous integration. Testing your model&lt;/li&gt;
      &lt;li&gt;Lab 9. Deployment. Put the model into production&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Project Structure
    &lt;ul&gt;
      &lt;li&gt;Web backend : Serving predictions, provisioning&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  api/                        # Code for serving predictions as a REST API.
      tests/test_app.py           # Test that predictions are working
      Dockerfile                  # Specificies Docker image that runs the web server.
      __init__.py
      app.py                      # Flask web server that serves predictions.
      serverless.yml              # Specifies AWS Lambda deployment of the REST API.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;Data&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  data/                            # Training data lives here
  	raw/
     	 emnist/metadata.toml     # Specifications for downloading data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;Experimentation : 평가나 여러 노트북 파일&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  evaluation/                     # Scripts for evaluating model on eval set.
      evaluate_character_predictor.py

  notebooks/                  # For snapshots of initial exploration, before solidfying code as proper Python files.
      01-look-at-emnist.ipynb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;Convenience scripts&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  tasks/
      # Deployment
      build_api_docker.sh
      deploy_api_to_lambda.sh

      # Code quality
      lint.sh

      # Tests
      run_prediction_tests.sh
      run_validation_tests.sh
      test_api.sh

      # Training
      train_character_predictor.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;Main model and training code&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  text_recognizer/                # Package that can be deployed as a self-contained prediction system
      __init__.py

      character_predictor.py      # Takes a raw image and obtains a prediction
      line_predictor.py

      datasets/                   # Code for loading datasets
          __init__.py
          dataset.py              # Base class for datasets - logic for downloading data
          emnist_dataset.py
          emnist_essentials.json
          dataset_sequence.py

      models/                     # Code for instantiating models, including data preprocessing and loss functions
          __init__.py
          base.py                 # Base class for models
          character_model.py

      networks/                   # Code for building neural networks (i.e., 'dumb' input-&amp;gt;output mappings) used by models
          __init__.py
          mlp.py

      tests/
          support/                        # Raw data used by tests
          test_character_predictor.py     # Test model on a few key examples

      weights/                            # Weights for production model
          CharacterModel_EmnistDataset_mlp_weights.h5

      util.py

  training/                       # Code for running training experiments and selecting the best model.
      gpu_util_sampler.py
      run_experiment.py           # Parse experiment config and launch training.
      util.py                     # Logic for training a model with a given config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;LineTextRecognizer Model architecture
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/c77bl3xrih5a8rr/Screenshot%202019-10-05%2023.20.34.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/waomkflnvpv804p/Screenshot%202019-10-05%2023.21.16.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/3koxo1tn5oevbek/Screenshot%202019-10-05%2023.22.58.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;lecture-4--infrastructure-and-tooling&quot;&gt;Lecture 4 : Infrastructure and Tooling&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://fullstackdeeplearning.com/assets/slides/fsdl_4_infra_tooling.pdf&quot;&gt;발표 자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;이상과 현실
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/uj2khr8fpy6grnv/Screenshot%202019-10-05%2023.30.19.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zzsza.github.io/data/2018/01/28/hidden-technical-debt-in-maching-learning-systems/&quot;&gt;Hidden Technical Debt in Machine Learning Systems&lt;/a&gt; 이야기함
    &lt;ul&gt;
      &lt;li&gt;논문 리뷰 링크 참고&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다양한 도구들
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/5bi7seqkqludsqa/Screenshot%202019-10-05%2023.35.35.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Deep Learning Frameworks
    &lt;ul&gt;
      &lt;li&gt;Tensorflow가 Production에 사용하기 편함&lt;/li&gt;
      &lt;li&gt;특별한 이유가 없으면 Tensorflw/Keras or PyTorch 사용&lt;/li&gt;
      &lt;li&gt;둘 다 동일한 포인트로 수렴
        &lt;ul&gt;
          &lt;li&gt;define by run으로 쉽게 개발&lt;/li&gt;
          &lt;li&gt;execution graph를 다양한 플랫폼에서 최적화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;일화로, 사람들이 파이토치로 바꿀때 행복해함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Development, Training/Evaluation
    &lt;ul&gt;
      &lt;li&gt;하드웨어
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/vxqennollh324a9/Screenshot%202019-10-05%2023.42.09.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;GPU Basics
        &lt;ul&gt;
          &lt;li&gt;NVIDIA가 유일한 선택이였던 시절이 있음
            &lt;ul&gt;
              &lt;li&gt;Google TPU가 현재 제일 빠름&lt;/li&gt;
              &lt;li&gt;Intel, AMD가 곧 시작될 예정&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;NVIDIA가 매년 새로운 아키텍쳐를 공개함&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/wsd9j7srvskre15/Screenshot%202019-10-05%2023.47.05.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/m89xjn9wnllwcq5/Screenshot%202019-10-05%2023.47.20.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/yc7urww5oaz6b8l/Screenshot%202019-10-05%2023.47.34.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/73n4fw29fsz5u9w/Screenshot%202019-10-05%2023.47.56.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Cloud Providers
        &lt;ul&gt;
          &lt;li&gt;AWS, GCP, Azure의 3파전&lt;/li&gt;
          &lt;li&gt;AWS가 제일 비쌈
            &lt;ul&gt;
              &lt;li&gt;Spot 요금을 사용하면 많이 할인되지만 갑자기 꺼질 수 있음&lt;/li&gt;
              &lt;li&gt;하이퍼 파라미터 서치 실험엔 적합하지만, 실패를 처리하려면 인프라가 필요&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;GCP는 TPU도 사용할 수 있음
            &lt;ul&gt;
              &lt;li&gt;GCP도 Spot이 있음, 거의 AWS보다 저렴함&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Azure
            &lt;ul&gt;
              &lt;li&gt;AWS와 꽤 비슷&lt;/li&gt;
              &lt;li&gt;Spot 없음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;On-prem Options
        &lt;ul&gt;
          &lt;li&gt;4개까진 꽤 쉬움&lt;/li&gt;
          &lt;li&gt;사전 구축된 것을 구매
            &lt;ul&gt;
              &lt;li&gt;Lambda Labs, NVIDIA, Supermicro, Cirrascale etc&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/hhrq08lzr1ljlz5/Screenshot%202019-10-05%2023.55.25.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/svt75hm893vp261/Screenshot%202019-10-05%2023.55.39.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Cost Analysis도 했음&lt;/li&gt;
      &lt;li&gt;다른 고려 사항
        &lt;ul&gt;
          &lt;li&gt;Data location
            &lt;ul&gt;
              &lt;li&gt;클라우드에 데이터가 1TB 이상 있따면 compute하기 수월&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Data privacy
            &lt;ul&gt;
              &lt;li&gt;데이터를 클라우드에 올릴 수 없다면 on-prem&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Security&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;추천
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/dgvk500ctkeislf/Screenshot%202019-10-06%2000.01.20.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Resource Management
    &lt;ul&gt;
      &lt;li&gt;많은 사람들이 여러 GPU를 사용하고, 격리된 환경을 가져야 함&lt;/li&gt;
      &lt;li&gt;바라는 것
        &lt;ul&gt;
          &lt;li&gt;실험하기 쉽고, 적절한 의존성과 리소스 할당&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Solutions
        &lt;ul&gt;
          &lt;li&gt;스프레드시트
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/w8kwezah8e0v38e/Screenshot%202019-10-06%2000.07.05.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;파이썬 스크립트
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/8wer2frze3tmsjm/Screenshot%202019-10-06%2000.07.24.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;SLURM
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/qxmfx0vo5oywc8i/Screenshot%202019-10-06%2000.07.41.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Docker + Kubernetes
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/t13gseke38fpef4/Screenshot%202019-10-06%2000.07.53.png?raw=1&quot; /&gt;&lt;/li&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/p0e3sxjfys3npfb/Screenshot%202019-10-06%2000.08.09.png?raw=1&quot; /&gt;&lt;/li&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/saxtqyhttof0grg/Screenshot%202019-10-06%2000.08.45.png?raw=1&quot; /&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;https://github.com/Langhalsdino/Kubernetes-GPU-Guide&quot;&gt;Kubernetes-GPU-Guide&lt;/a&gt; 참고&lt;/li&gt;
              &lt;li&gt;최근 Kubeflow도 열심히 만들고 있음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Software specialized for ML use cases&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Distributed Training
    &lt;ul&gt;
      &lt;li&gt;모델을 학습할 때 여러 GPU를 사용해야할 경우가 있음&lt;/li&gt;
      &lt;li&gt;단순히 병렬로 실행하는 것은 덜 유용했으나, 데이터가 커지며 프레임워크의 병렬화가 좋아지고 있음&lt;/li&gt;
      &lt;li&gt;Data vs Model Parallelism
        &lt;ul&gt;
          &lt;li&gt;Iteration time이 너무 길어지면, 데이터를 parallel하게 학습해야 함&lt;/li&gt;
          &lt;li&gt;모델 병렬처리는 복잡성을 증가시키며 거의 가치가 없음&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/vqfumyaz4kzshku/Screenshot%202019-10-06%2001.15.07.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Tensorflow Distributed
        &lt;ul&gt;
          &lt;li&gt;코드를 크게 재구성해야 함&lt;/li&gt;
          &lt;li&gt;점점 좋아지고 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Horovod
        &lt;ul&gt;
          &lt;li&gt;Tensorflow, Keras, PyTorch 지원&lt;/li&gt;
          &lt;li&gt;MPI를 사용해 Tensorflow Distributed보다 덜 복잡함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Experiment Management
    &lt;ul&gt;
      &lt;li&gt;실험할 때 코드, 매개변수, 데이터셋을 추적하기 어려움&lt;/li&gt;
      &lt;li&gt;여러 실험을 하면 더 어려움&lt;/li&gt;
      &lt;li&gt;모델을 자동으로 저장하는 것도 좋음&lt;/li&gt;
      &lt;li&gt;Tensorboard
        &lt;ul&gt;
          &lt;li&gt;단일 실험에서 좋은 솔루션&lt;/li&gt;
          &lt;li&gt;다양한 실험을 커버하진 못함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Losswise, Comet.ml 등&lt;/li&gt;
      &lt;li&gt;Weights &amp;amp; Biases : 실습때 활용할 예정, &lt;a href=&quot;https://github.com/wandb/client&quot;&gt;Document&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;Sacred도 좋아요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Hyperparameter Optimization
    &lt;ul&gt;
      &lt;li&gt;하이퍼파라미터 서치할 때 유용&lt;/li&gt;
      &lt;li&gt;간단하게 정의해서 사용할 수 있음&lt;/li&gt;
      &lt;li&gt;keras와 잘 맞는 것들&lt;/li&gt;
      &lt;li&gt;talos&lt;/li&gt;
      &lt;li&gt;Hyperas&lt;/li&gt;
      &lt;li&gt;Hyperopt
        &lt;ul&gt;
          &lt;li&gt;머신러닝의 일반적 패키지와 다 맞음&lt;/li&gt;
          &lt;li&gt;Non-bayesian 알고리즘&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;SIGOPT : Hyperparameter 서비스 제공&lt;/li&gt;
      &lt;li&gt;Weights &amp;amp; Biases도 제공&lt;/li&gt;
      &lt;li&gt;Microsoft의 nni도 좋음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;All-in-one Solutions
    &lt;ul&gt;
      &lt;li&gt;최근 트렌드 : 하나의 시스템에 모두 넣음&lt;/li&gt;
      &lt;li&gt;개발(hosted notebook)&lt;/li&gt;
      &lt;li&gt;AutoML을 사용해 실험을 여러 컴퓨터로 스케일링&lt;/li&gt;
      &lt;li&gt;버전 관리 및 결과 review&lt;/li&gt;
      &lt;li&gt;모델 배포&lt;/li&gt;
      &lt;li&gt;성능 모니터링&lt;/li&gt;
      &lt;li&gt;FBLearner Flow
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ud4981l85b1sca6/Screenshot%202019-10-06%2001.24.24.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/65dkmk7peruu660/Screenshot%202019-10-06%2001.26.21.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Michelangelo
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/g7qiy86lclt8sb0/Screenshot%202019-10-06%2001.25.52.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/wlo8r3kafyqjjic/Screenshot%202019-10-06%2001.26.07.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/53mmymswoqje9px/Screenshot%202019-10-06%2001.26.44.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Cloud ML Engine(AI Platform)
        &lt;ul&gt;
          &lt;li&gt;AI Platform의 일부가 됨&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/94qsxuds8ch18vg/Screenshot%202019-10-06%2001.27.41.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;TFX
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/5j2bg8tzjrdonr0/Screenshot%202019-10-06%2001.28.32.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Kubeflow
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/94se75dalngx3d2/Screenshot%202019-10-06%2001.28.48.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Amazon SageMaker
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/huggsjpp5h7ur0k/Screenshot%202019-10-06%2001.29.20.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Neptune
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/6uexjt4h1tzzbmr/Screenshot%202019-10-06%2001.29.34.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;FLOYD&lt;/li&gt;
      &lt;li&gt;Paperspace&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/lkm09yqih6h6330/Screenshot%202019-10-06%2001.30.00.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;lecture-5-tooling-and-experimentation-labs&quot;&gt;Lecture 5: Tooling and Experimentation Labs&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;코드로 실습함&lt;/li&gt;
  &lt;li&gt;Weights &amp;amp; Biases
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/lxzg1g5uy0ivlcf/Screenshot%202019-10-06%2001.39.23.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;lecture-6--data-management&quot;&gt;Lecture 6 : Data Management&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://fullstackdeeplearning.com/assets/slides/fsdl_6_data.pdf&quot;&gt;발표 자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/aevefth4udm6vuw/Screenshot%202019-10-06%2001.41.19.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Introduction
    &lt;ul&gt;
      &lt;li&gt;대부분 딥러닝은 레이블된 많은 데이터가 필요함
        &lt;ul&gt;
          &lt;li&gt;스스로 플레이하는 RL이나 GAns은 제외하고 =&amp;gt; 아직 실용적이지 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;공공 데이터셋은 경쟁 우위를 가질 수 없음
        &lt;ul&gt;
          &lt;li&gt;그러나 스타트 포인트로는 괜찮음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Roadmap
    &lt;ul&gt;
      &lt;li&gt;1) Data Labeling&lt;/li&gt;
      &lt;li&gt;2) Data Storage
        &lt;ul&gt;
          &lt;li&gt;Data(images, sound) and metadata(labels, user activity)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;3) Data versioning
        &lt;ul&gt;
          &lt;li&gt;데이터셋은 사용자 활동, 추가 레이블을 통해 업데이트되며 모델에 영향을 미침&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;4) Data workflow
        &lt;ul&gt;
          &lt;li&gt;원본 데이터와 메타 데이터를 학습 가능한 데이터로 집계 및 변환&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data Labeling
    &lt;ul&gt;
      &lt;li&gt;User Interfaces
        &lt;ul&gt;
          &lt;li&gt;HIVE 사이트를 통해 bounding box, segmentation, keypoints, cuboids 등을 뽑음&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/t195sv08fkogmnd/Screenshot%202019-10-06%2010.28.10.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;Annotator는 매우 중요하고, 퀄리티 보장이 되야함&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/kw8ulpe4dsfxzo0/Screenshot%202019-10-06%2010.28.50.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Sources of labor
        &lt;ul&gt;
          &lt;li&gt;사람을 고용함, 퀄리티 품질을 관리할 수 있음
            &lt;ul&gt;
              &lt;li&gt;그러나 비싸고 스케일업이 느림&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;크라우드 소싱&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Service companies
        &lt;ul&gt;
          &lt;li&gt;기간 선정&lt;/li&gt;
          &lt;li&gt;좋은 사례(Godl standard)를 직접 라벨링&lt;/li&gt;
          &lt;li&gt;여러 경쟁 업체와 샘플 요청&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Software
        &lt;ul&gt;
          &lt;li&gt;풀 서비스 데이터 라벨링은 비쌈&lt;/li&gt;
          &lt;li&gt;일부 회사는 소프트웨어 제공, 오픈소스도 있음(Prodigy)&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/7rbdho3hmx9nza1/Screenshot%202019-10-06%2010.32.05.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/i9gei7cn747dazp/Screenshot%202019-10-06%2010.32.19.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data Storage
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/jesaz31dry1y9f9/Screenshot%202019-10-06%2010.35.09.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Filesystem
        &lt;ul&gt;
          &lt;li&gt;Storage의 기초 layer&lt;/li&gt;
          &lt;li&gt;기본 단위는 텍스트나 binary가 가능한 “file”이고 버전이 지정되지 않고 쉽게 덮어씀&lt;/li&gt;
          &lt;li&gt;네트워크로 연결 가능(ex: NFS) : 여러 머신이 네트워크를 통해 액세스&lt;/li&gt;
          &lt;li&gt;분산 가능(ex: HDFS) 	: 여러 곳에 저장하고 액세스 가능&lt;/li&gt;
          &lt;li&gt;Access 패턴이 주의! 빠르지만 병렬을 아님&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Objest Storage
        &lt;ul&gt;
          &lt;li&gt;S3, Google Storage&lt;/li&gt;
          &lt;li&gt;API로 파일에 접근 가능, 직접 데이터 저장하지 않아도 됨&lt;/li&gt;
          &lt;li&gt;기본 단위는 “object”, 보통 binary, image, sound&lt;/li&gt;
          &lt;li&gt;versioning이나 redundancy가 서비스에서 가능함&lt;/li&gt;
          &lt;li&gt;parallel이 가능하지만 빠르지 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Database
        &lt;ul&gt;
          &lt;li&gt;구조적인 데이터에 지속적이고, 빠르고, 확장 가능함&lt;/li&gt;
          &lt;li&gt;실제로 모든 것이 RAM에 있지만, software가 디스크에 모든 것을 기록하고 유실되지 않도록 함&lt;/li&gt;
          &lt;li&gt;기본 단위는 “row”, unique id, rows, columns&lt;/li&gt;
          &lt;li&gt;binary 데이터가 아님&lt;/li&gt;
          &lt;li&gt;Postgres가 거의 90% 이상 좋을 수 있음, 비정형 JSON도 지원&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Data Lake
        &lt;ul&gt;
          &lt;li&gt;다양한 소스에서 데이터를 가공해 저장&lt;/li&gt;
          &lt;li&gt;Redshift, BigQuery 등&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;정리하면
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/8rwddxz89x2mhb7/Screenshot%202019-10-06%2010.42.08.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data versioning
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/v0bz5dn0htu6tgb/Screenshot%202019-10-06%2010.43.06.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ugqfmdoam4n05r5/Screenshot%202019-10-06%2010.44.05.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/gfwyoq2l4gan7td/Screenshot%202019-10-06%2010.44.21.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ukk604oxfj65rbs/Screenshot%202019-10-06%2010.44.38.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ldrymm5lhv1fwej/Screenshot%202019-10-06%2010.44.50.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;DVC
        &lt;ul&gt;
          &lt;li&gt;Data versioning에 특화된 솔루션&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/rzjsh3wx421ktiw/Screenshot%202019-10-06%2010.45.57.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data workflows
    &lt;ul&gt;
      &lt;li&gt;Train시 아래와 같은 데이터를 가져와야 함
        &lt;ul&gt;
          &lt;li&gt;metadata : posting time, title, location&lt;/li&gt;
          &lt;li&gt;log&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;그리고 classifiers를 돌려서 결과 도출&lt;/li&gt;
      &lt;li&gt;Task Dependencies
        &lt;ul&gt;
          &lt;li&gt;A가 끝나고 B 작업을 해야하고, B 작업 이후에 C, D, E를 하고 C, D, E가 완료되면 F 진행하는 이런 의존 관계가 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Makefiles
        &lt;ul&gt;
          &lt;li&gt;Makefile에서 파이프라인 연산 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Luigi and Airflow&lt;/li&gt;
      &lt;li&gt;Distributing work&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;lecture-7--ml-teams&quot;&gt;Lecture 7 : ML Teams&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://fullstackdeeplearning.com/assets/slides/fsdl_7_teams.pdf__vUzdzk%2FAxRhOPagFTz0ERFg28e7e20c61988c6abe0cfdd887bde6e4&quot;&gt;발표 자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Job Role
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/nranvigqpwcatv7/Screenshot%202019-10-06%2010.51.52.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/nhb0loh9eoy91kx/Screenshot%202019-10-06%2010.52.11.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;ML DevOps
        &lt;ul&gt;
          &lt;li&gt;주로 소프트웨어 개발자 Role이고, SWE 파이프라인을 구축&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Data Engineer
        &lt;ul&gt;
          &lt;li&gt;ML Team과 적극적으로 SWE&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ML Engineer(머신러닝 엔지니어)
        &lt;ul&gt;
          &lt;li&gt;ML 기술 + SWE 기술의 Mix&lt;/li&gt;
          &lt;li&gt;보통 SWE로 일하시던 분들이나 공부하고 발전&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ML Researcher
        &lt;ul&gt;
          &lt;li&gt;ML 전문가&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ML team structures
    &lt;ul&gt;
      &lt;li&gt;대부분 팀은 SWE + ML 스킬이 혼합됨&lt;/li&gt;
      &lt;li&gt;팀의 모든 사람들이 어느정도 SWE 기술을 가져야 함&lt;/li&gt;
      &lt;li&gt;ML Researcher의 다른 견해
        &lt;ul&gt;
          &lt;li&gt;SWE와 통합하기 어려움&lt;/li&gt;
          &lt;li&gt;빠르게 움직이기 위해 알아야 한다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Data Engineer의 다른 견해
        &lt;ul&gt;
          &lt;li&gt;일부 조직은 ML팀과 같이함&lt;/li&gt;
          &lt;li&gt;별도의 팀이어야 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Managing ML Teams
    &lt;ul&gt;
      &lt;li&gt;Task가 쉬울지 어려울지 미리 말하는건 매우 어려움&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/m4aaifd1wjwebzu/Screenshot%202019-10-06%2010.58.26.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;ML progress는 nonlinear
        &lt;ul&gt;
          &lt;li&gt;무엇이 효과있을지 불명확해 계획이 어렵긴 함&lt;/li&gt;
          &lt;li&gt;프로젝트 타임라인 추정이 매우 어려움&lt;/li&gt;
          &lt;li&gt;Production ML은 research와 engineering 사이에 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;research와 engineering의 문화 gap이 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;면접 질문의 큰 틀
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/c5e3fwjlvyndgig/Screenshot%202019-10-06%2011.01.23.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Why does the Residual Block in the ResNet architecture help with the vanishing gradient problem?&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/d2d559bmky3c71z/Screenshot%202019-10-06%2011.01.50.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;lecture-10--troubleshooting&quot;&gt;Lecture 10 : Troubleshooting&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://fullstackdeeplearning.com/assets/slides/fsdl_10_troubleshooting.pdf&quot;&gt;발표 자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;딥러닝에서 디버깅은 매우 어렵지만, 중요한 주제&lt;/li&gt;
  &lt;li&gt;왜 어려울까? 당신의 퍼포먼스가 좋지 않은 이유
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/zxkh3qu2xn2h204/Screenshot%202019-10-06%2011.48.29.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;흔한 Dataset 구조 이슈
        &lt;ul&gt;
          &lt;li&gt;충분하지 않은 데이터&lt;/li&gt;
          &lt;li&gt;Class imbalances&lt;/li&gt;
          &lt;li&gt;Noisy labels&lt;/li&gt;
          &lt;li&gt;Train / Test 데이터셋의 분포가 다름&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Key mindset for DL troubleshooting
    &lt;ul&gt;
      &lt;li&gt;Pessimism(비관적으로 보자)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;트러블슈팅 전략
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/rud5idogr9tsot9/Screenshot%202019-10-06%2011.51.16.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Start simple
    &lt;ul&gt;
      &lt;li&gt;1) 간단한 아키텍쳐 선택
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/mhr4mymm6et358v/Screenshot%202019-10-06%2011.56.51.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) 일반적으로 좋은 default 사용
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/jyv7gj8k1fxvams/Screenshot%202019-10-06%2011.58.43.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/it9i162yn9n37ud/Screenshot%202019-10-06%2011.59.04.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;3) Input 정규화&lt;/li&gt;
      &lt;li&gt;4) 문제를 간단히하기
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/xql8rzo8774i0e8/Screenshot%202019-10-06%2012.01.01.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/g83b7xq3p082wmv/Screenshot%202019-10-06%2012.03.02.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Implement &amp;amp; debug
    &lt;ul&gt;
      &lt;li&gt;자주 발생하는 실수
        &lt;ul&gt;
          &lt;li&gt;Tensor의 shape가 안맞는 경우&lt;/li&gt;
          &lt;li&gt;전처리 실수(정규화를 잊거나 너무 많이하거나)&lt;/li&gt;
          &lt;li&gt;loss function의 부정확함&lt;/li&gt;
          &lt;li&gt;train/eval 모드 설정을 까먹음&lt;/li&gt;
          &lt;li&gt;수치적 불안정 : inf, NaN&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;모델 구현을 위한 일반적인 조언
        &lt;ul&gt;
          &lt;li&gt;가벼운 구현
            &lt;ul&gt;
              &lt;li&gt;v1은 가능하면 간소하게&lt;/li&gt;
              &lt;li&gt;200줄 미만&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;이미 구현된 component 사용
            &lt;ul&gt;
              &lt;li&gt;tf.nn.relu(tf/matmul(W, x)) 대신 tf.layers.dense!&lt;/li&gt;
              &lt;li&gt;tf.losses.cross_entropy&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;복잡한 데이터 파이프라인은 나중에! 일반 메모리에 올려서 진행&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;1) 모델 Run
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/cwpi2rkjro59t11/Screenshot%202019-10-06%2012.09.36.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;Debuggers for DL code
            &lt;ul&gt;
              &lt;li&gt;Pytorch : 쉬움, ipdb 사용&lt;/li&gt;
              &lt;li&gt;tensorflow : trick(허나 2.0이 나왔으니 이 방법은 안해도?)
                &lt;ul&gt;
                  &lt;li&gt;graph session 만들고, training loop 갖고, tfdb 사용&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Shape mismatch
            &lt;ul&gt;
              &lt;li&gt;와 대박 꿀팁&lt;/li&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/8fo6tm4wl9u0aa1/Screenshot%202019-10-06%2012.12.29.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Casting issue
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/5lfca53staw3gj8/Screenshot%202019-10-06%2012.13.14.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;OOM
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/s3klr3phs9yix5w/Screenshot%202019-10-06%2012.13.30.png?raw=1&quot; /&gt;&lt;/li&gt;
              &lt;li&gt;Tensor가 너무 크거나, 데이터가 많거나, operation에 중복이 있거나 등&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Other common errors
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/1xh7i58ym2xak8q/Screenshot%202019-10-06%2012.13.58.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) single batch에 오버피팅
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/g1p5tbtwd4ysnlo/Screenshot%202019-10-06%2012.15.30.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;3) 알고있던 결과와 비교
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/urslbq88br6oeq6/Screenshot%202019-10-06%2012.16.48.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Evaluate
    &lt;ul&gt;
      &lt;li&gt;Test error = irreducible error + bias + variance + val overfitting
        &lt;ul&gt;
          &lt;li&gt;이건 train, val, test가 모두 같은 분포를 가진다는 가정을 가짐. 진짜 그럴까?&lt;/li&gt;
          &lt;li&gt;2개의 Validation 구성해보기
            &lt;ul&gt;
              &lt;li&gt;하나는 Train에서 샘플링, 하나는 Test에서 샘플링&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;결과 분석
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ruoflpo36mjift5/Screenshot%202019-10-06%2012.49.45.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/lf8i0arapxr3e4r/Screenshot%202019-10-06%2012.49.58.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/wqwp8sfdsnj8rwc/Screenshot%202019-10-06%2012.50.08.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;정리하면, Test error = irreducible error + bias + variance + distribution shift + val overfitting&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Improve model/data
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/2zoiynbq876jf92/Screenshot%202019-10-06%2012.51.00.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;1) 언더피팅인 경우
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/s10m0nzqgcnpnhy/Screenshot%202019-10-06%2012.52.01.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/3dli0ya7hsgxx0p/Screenshot%202019-10-06%2012.52.25.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;ConvNet, ResNet, 파라미터 튜닝 등을 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) 오버피팅인 경우
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/zc5pd9yhvwr50u7/Screenshot%202019-10-06%2012.54.17.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;H ~ J는 추천하지 않음&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/o9z3at5557r5qvv/Screenshot%202019-10-06%2012.56.16.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;데이터 추가하고, weight decay 추가, data augmentation도 했음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;3) 분포 이동
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/86r628r5msyt7x7/Screenshot%202019-10-06%2012.58.05.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;Error analysis
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/5zdrrjl5981fkvv/Screenshot%202019-10-06%2012.59.04.png?raw=1&quot; /&gt;&lt;/li&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/i8wmaf8rj1d36dx/Screenshot%202019-10-06%2012.59.18.png?raw=1&quot; /&gt;&lt;/li&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/fbracbimpedemw5/Screenshot%202019-10-06%2012.59.57.png?raw=1&quot; /&gt;&lt;/li&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/98mc6mmbujjk5jp/Screenshot%202019-10-06%2013.00.11.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Domain adaptation
            &lt;ul&gt;
              &lt;li&gt;레이블이 없는 데이터 또는 제한된 레이블이 있는 데이터가 있는 상황에서 source 분포를 학습해 또다른 target 데이터를 일반화하는 기술&lt;/li&gt;
              &lt;li&gt;레이블된 test 데이터가 적을 경우, 유사 데이터가 존재할 경우 유용&lt;/li&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/y6ga3d5zz921lay/Screenshot%202019-10-06%2013.04.57.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;4) Re-balance datasets
        &lt;ul&gt;
          &lt;li&gt;test set보다 val이 더 좋아보이면, 오버피팅일 수 있음&lt;/li&gt;
          &lt;li&gt;보통 작은 val set 또는 많은 하이퍼 파라미터 튜닝에서 발생함&lt;/li&gt;
          &lt;li&gt;그렇다면, val data를 다시 수집해야 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Tune hyper-parameters
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/g7yu5unucd9kaf5/Screenshot%202019-10-06%2013.06.58.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/qxm2oseypzifuhe/Screenshot%202019-10-06%2013.07.10.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;어떤 파라미터가 민감한지 작성해보고 조정&lt;/li&gt;
      &lt;li&gt;Method 1: manual 하이퍼파라미터 최적화
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/pt12lhgzrdq72lz/Screenshot%202019-10-06%2013.07.48.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Method 2: grid search
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9kd4lasmg89nkm4/Screenshot%202019-10-06%2013.08.17.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Method 3: random search
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/euyzoglo6p2kzej/Screenshot%202019-10-06%2013.08.37.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Method 4: coarse-to-fine
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/wxxe424jluggv8m/Screenshot%202019-10-06%2013.09.50.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Method 5: Bayesian hyperparam opt
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/xzpgtqrapjov0ou/Screenshot%202019-10-06%2013.10.30.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;lecture-12--testing-and-deployment&quot;&gt;Lecture 12 : Testing and Deployment&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://fullstackdeeplearning.com/assets/slides/fsdl_12_testing.pdf&quot;&gt;발표 자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/72rf1pwvdlg0pvx/Screenshot%202019-10-06%2013.13.40.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/r6q1w8ai1qlqbl0/Screenshot%202019-10-06%2013.13.55.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;ML Test Score
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/k7xk3hefbdbaa04/Screenshot%202019-10-06%2013.55.00.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9gcpmm407dic5xm/Screenshot%202019-10-06%2013.55.23.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Testing / CI
    &lt;ul&gt;
      &lt;li&gt;Unit / Integration Tests
        &lt;ul&gt;
          &lt;li&gt;각각의 모듈과 전체 시스템을 테스트&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Continuous Integration
        &lt;ul&gt;
          &lt;li&gt;테스트는 항상 모델이 deploy되기 전에 새로운 코드로 repository에 푸시되야 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Saas for CI
        &lt;ul&gt;
          &lt;li&gt;CircleCI, Travis, Jenkins&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Containerization(via docker)
        &lt;ul&gt;
          &lt;li&gt;테스트를 위한 격리된 환경&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/zep1fw3lnpuk26z/Screenshot%202019-10-06%2013.58.28.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;CircleCI / Travis
        &lt;ul&gt;
          &lt;li&gt;Saas for continuous integration&lt;/li&gt;
          &lt;li&gt;repository와 통합되서 테스트&lt;/li&gt;
          &lt;li&gt;docker container의 command로 job을 정의할 수 있고, 리뷰 결과를 저장할 수 있음&lt;/li&gt;
          &lt;li&gt;No GPU&lt;/li&gt;
          &lt;li&gt;CircleCI has a free plan&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Jenkins / Buidkite
        &lt;ul&gt;
          &lt;li&gt;개인 하드웨어, 클라우드 등에서 CI하기에 좋은 옵션&lt;/li&gt;
          &lt;li&gt;GPU 사용하기 좋음&lt;/li&gt;
          &lt;li&gt;Very flexible&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Docker
    &lt;ul&gt;
      &lt;li&gt;도커에 이해하면 좋음&lt;/li&gt;
      &lt;li&gt;Docker vs VM
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/4rcwwp3d2f2dqa0/Screenshot%202019-10-06%2014.01.53.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Dockerfile and layer-based images
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/rrraq2zs7xzmqmk/Screenshot%202019-10-06%2014.02.17.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Dockerhub and the ecosystem
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/7j9rwd73dw0q26l/Screenshot%202019-10-06%2014.02.29.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Kubernetes and other orchestrators
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/tmcw7wk9kb4tnyf/Screenshot%202019-10-06%2014.03.07.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Web Deployment
    &lt;ul&gt;
      &lt;li&gt;REST API
        &lt;ul&gt;
          &lt;li&gt;HTTP requests - response를 사용해 serving&lt;/li&gt;
          &lt;li&gt;웹서버가 띄워져 있고, prediction system을 call&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Option
        &lt;ul&gt;
          &lt;li&gt;VM에 deploy&lt;/li&gt;
          &lt;li&gt;Container에 deploy&lt;/li&gt;
          &lt;li&gt;Serverless function에 deploy&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/jsw485tifmkd38m/Screenshot%202019-10-06%2014.05.04.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Cloud instance에 배포
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/1vaz8wqhjwp8f44/Screenshot%202019-10-06%2014.05.23.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;단점
            &lt;ul&gt;
              &lt;li&gt;프로비저닝이 힘듬&lt;/li&gt;
              &lt;li&gt;인스턴스는 사용하지 않는 경우에도 비용 지불&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Container에 배포
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/uk2grew7wf6639n/Screenshot%202019-10-06%2014.06.18.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;단점
            &lt;ul&gt;
              &lt;li&gt;컴퓨팅 시간이 아닌 자체 서버 가동 시간에 비용 지불&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Serverless function으로 배포
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/5pmln43totco37k/Screenshot%202019-10-06%2014.07.10.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;단점
            &lt;ul&gt;
              &lt;li&gt;전체 배포 패키지는 500MB, 5분 이내 실행, 3기가 메모리 이하 등을 만족해야 함(AWS Lambda)&lt;/li&gt;
              &lt;li&gt;CPU 연산만 가능&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Model Serving
    &lt;ul&gt;
      &lt;li&gt;머신러닝 모델에 특화된 Web development options&lt;/li&gt;
      &lt;li&gt;종류
        &lt;ul&gt;
          &lt;li&gt;Tensorflow Serving(Google)&lt;/li&gt;
          &lt;li&gt;Model Server for MXNet(Amazon)&lt;/li&gt;
          &lt;li&gt;Clipper(Berkely RISE lab)&lt;/li&gt;
          &lt;li&gt;Saas solutions like ALgorithmia&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Tensorflow Serving
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/zd4e07dy5vgkzsy/Screenshot%202019-10-06%2014.10.15.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;MXNet Model Server
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/hywjhqke0syd3hi/Screenshot%202019-10-06%2014.10.40.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Clipper
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/xc80kjx42epsfs3/Screenshot%202019-10-06%2014.11.18.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Algorithmia
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/380ddm9ggb2xfjg/Screenshot%202019-10-06%2014.11.29.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;핵심 정리
    &lt;ul&gt;
      &lt;li&gt;CPU inference를 수행할 경우, 더 많은 서버를 사용하거나 서버리스로 가는 방법이 있음
        &lt;ul&gt;
          &lt;li&gt;Dream : Lambda처럼 Docker를 쉽게 배포&lt;/li&gt;
          &lt;li&gt;모델의 요구 사항에 따라 Lambda 또는 Docker가 제일 좋음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;GPU inference를 수행할 경우, TF Serving 및 Clipper 같은 adaptive batching 방법이 유용함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Monitoring
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/paq95fmjfq5v1ag/Screenshot%202019-10-06%2014.15.30.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;무언가 잘못되면 알람해줘야 함&lt;/li&gt;
      &lt;li&gt;Cloud provider는 최근에 모니터링 솔루션을 가짐&lt;/li&gt;
      &lt;li&gt;기록할 수 있는 모든 것을 모니터링할 수 있어야 함(예 : Data Skew)&lt;/li&gt;
      &lt;li&gt;실습에서 보여줌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Interchange
    &lt;ul&gt;
      &lt;li&gt;ONNX&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/oe24uofv1ov0mgp/Screenshot%202019-10-06%2014.19.30.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Hardware / Mobile
    &lt;ul&gt;
      &lt;li&gt;Problems
        &lt;ul&gt;
          &lt;li&gt;모바일 기기는 메모리가 작아서 연산하기 느림
            &lt;ul&gt;
              &lt;li&gt;network size를 줄이거나, trick, quantize weight해야 함&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;모바일 딥러닝 프레임워크는 full version보다 덜 발전함
            &lt;ul&gt;
              &lt;li&gt;네트워크 구조를 바꿔야할 수 있음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/1fauo080jov41mh/Screenshot%202019-10-06%2014.21.03.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Tensorflow Options
        &lt;ul&gt;
          &lt;li&gt;Tensorflow Lite
            &lt;ul&gt;
              &lt;li&gt;최근 솔루션으로 사용됨&lt;/li&gt;
              &lt;li&gt;operator가 제한되긴 함&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Tensorflow Mobile
            &lt;ul&gt;
              &lt;li&gt;더 많은(그러나 전체는 아닌) operator가 있음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Mobile
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9d8g4hfgwhkr4r8/Screenshot%202019-10-06%2014.22.09.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;NVIDIA for Embedded
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/s070zi3vppob26x/Screenshot%202019-10-06%2014.22.48.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;lecture-13--research-directions&quot;&gt;Lecture 13 : Research Directions&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://fullstackdeeplearning.com/assets/slides/fsdl_13_research.pdf&quot;&gt;발표 자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;연구 방향성에 대해 알려주려는 시간&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/53v83cyoawnsjjd/Screenshot%202019-10-06%2014.33.25.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;다양한 연구 분야에 대해 쉽게 설명해주고, 참고하면 좋을 논문들을 제공했음&lt;/li&gt;
  &lt;li&gt;이 부분은 정리하기보다, 키워드를 캐치하고 추후에 따로 정리하는게 더 좋을듯&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://fullstackdeeplearning.com/march2019&quot;&gt;Full Stack Deep Learning Homepage&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/full-stack-deep-learning/fsdl-text-recognizer-project&quot;&gt;Full Stack Deep Learning Labs Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 06 Oct 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/mlops/2019/10/06/fullstack-deeplearning-bootcamp/</link>
        <guid isPermaLink="true">http://localhost:4000/mlops/2019/10/06/fullstack-deeplearning-bootcamp/</guid>
        
        <category>basic</category>
        
        
        <category>mlops</category>
        
      </item>
    
      <item>
        <title>BigQuery UDF 사용하기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Google Cloud Platform의 BigQuery에서 udf 사용하는 방법에 대해 작성한 글입니다
    &lt;ul&gt;
      &lt;li&gt;이 글은 2019년 9월에 작성되었습니다&lt;/li&gt;
      &lt;li&gt;BigQuery temp udf, BigQuery persistent udf에 대해 다룹니다&lt;/li&gt;
      &lt;li&gt;아직 persistent UDF는 pre-release이므로 추후에 기능이나 방식이 변경될 가능성이 있습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;bigquery-udf&quot;&gt;BigQuery UDF&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;UDF
    &lt;ul&gt;
      &lt;li&gt;UDF는 User Define Function의 약자로 사용자가 정의한 함수&lt;/li&gt;
      &lt;li&gt;Python 같은 프로그래밍 언어에서 함수를 만드는 것처럼, SQL에서 함수를 만드는 것을 UDF라고 표현하기도 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;UDF의 종류
    &lt;ul&gt;
      &lt;li&gt;Temp UDF : 쿼리문 위에 정의해서 사용하는 방식&lt;/li&gt;
      &lt;li&gt;Persistent UDF : BigQuery의 Dataset에 저장해서 사용하는 방식으로 여러 사람과 사용할 경우 유용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;UDF로 사용할 수 있는 언어
    &lt;ul&gt;
      &lt;li&gt;SQL 표현식&lt;/li&gt;
      &lt;li&gt;자바스크립트&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Useful UDF 모음집
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/GoogleCloudPlatform/bigquery-utils/tree/master/udfs/community&quot;&gt;bigquery-utils&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/jatorre/bigquery-jslibs&quot;&gt;bigquery-jslibs&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;temp-udfsql&quot;&gt;Temp UDF(SQL)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;일반 UDF는 Temp udf로 쿼리문을 작성할 때 함께 작성해야 함&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  CREATE  { TEMPORARY | TEMP }  FUNCTION function_name ([named_parameter[, ...]])
  [RETURNS data_type]
  AS (function_definition);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;RETURNS 뒤엔 리턴될 데이터의 타입(생략 가능하지만 명시적으로 적는 것을 추천)&lt;/li&gt;
      &lt;li&gt;AS 뒤엔 함수 정의&lt;/li&gt;
      &lt;li&gt;정의 후 &lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt;를 꼭 붙여야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SQL 표현식을 사용한 예시&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  CREATE TEMP FUNCTION add_three_and_divide(x INT64, y INT64) 
  RETURNS FLOAT64
  AS ((x + 3) / y);
	
  # 밑에는 Sample Data
  WITH numbers AS
    (SELECT 1 as val
    UNION ALL
    SELECT 4 as val)
  SELECT val, add_three_and_divide(val, 2) AS result
  FROM numbers;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;temp-udfjavascript&quot;&gt;Temp UDF(Javascript)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Javascript UDF 외부 javascript 파일을 참고하거나 직접 javascript 문법을 사용할 수 있음&lt;/li&gt;
  &lt;li&gt;심플한 문법을 사용하면 “ 하나만 사용해도 되고, snippet이거나 여러 줄이면 triple-quoted(“””) 사용&lt;/li&gt;
  &lt;li&gt;Best 사례나 한계점은 &lt;a href=&quot;https://cloud.google.com/bigquery/docs/reference/standard-sql/user-defined-functions?#best-practices-for-javascript-udfs&quot;&gt;링크&lt;/a&gt; 참고&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자바스크립트 문법을 사용할 경우&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  CREATE  { TEMPORARY | TEMP }  FUNCTION function_name ([named_parameter[, ...]])
  RETURNS data_type
  LANGUAGE js 
  AS &quot;&quot;&quot;body&quot;&quot;&quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;예시&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  CREATE TEMP FUNCTION customGreeting(a STRING)
  RETURNS STRING
  LANGUAGE js AS &quot;&quot;&quot;
    var d = new Date();
    if (d.getHours() &amp;lt; 12) {
      return 'Good Morning, ' + a + '!';
    } else {
      return 'Good Evening, ' + a + '!';
    }
    &quot;&quot;&quot;;
	  
  SELECT customGreeting(names) as everyone
  FROM UNNEST([&quot;Hannah&quot;, &quot;Max&quot;, &quot;Jakob&quot;]) AS names;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;외부 자바스크립트 파일을 참고할 경우
    &lt;ul&gt;
      &lt;li&gt;Google Storage에 라이브러리 파일을 넣은 후 사용&lt;/li&gt;
      &lt;li&gt;해당 라이브러리에 있는 함수를 AS 뒤에 넣어서 사용&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  CREATE  { TEMPORARY | TEMP }  FUNCTION function_name ([named_parameter[, ...]])
  RETURNS data_type
  LANGUAGE js 
  OPTIONS (
      library=['gs://bucket/library.js']
  )
  AS &quot;&quot;&quot;librarys_method()&quot;&quot;&quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;persistent-udf&quot;&gt;Persistent UDF&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Temp UDF는 쿼리를 작성할 때마다 위에서 정의해야 하는 불편함이 있음
    &lt;ul&gt;
      &lt;li&gt;따라서 이런 정의를 저장해두고, 활용하고 싶을 경우 Persistent UDF 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Dataset 아래에 UDF로 저장해서 활용함&lt;/li&gt;
  &lt;li&gt;CREATE 문 뒤에 TEMP 없이 바로 FUNCTION을 작성&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;persistent-udf-생성하기sql&quot;&gt;Persistent UDF 생성하기(SQL)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;BigQuery udf 데이터셋 생성&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;multiply_inputs 함수 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  CREATE OR REPLACE FUNCTION udf.multiply_inputs(x FLOAT64, y FLOAT64)
  RETURNS FLOAT64
  AS (x * y);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;udf 데이터셋 확인
    &lt;ul&gt;
      &lt;li&gt;언어, 반환 유형, 정의, 인수&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/op2xlsfodp3j93p/Screenshot%202019-09-21%2017.33.39.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;쿼리에서 UDF 사용하기
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Dataset.function_name&lt;/code&gt;으로 사용 =&amp;gt; 여기선 udf.multiply_inputs&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  WITH numbers AS
    (SELECT 1 AS x, 5 as y
    UNION ALL
    SELECT 2 AS x, 10 as y
    UNION ALL
    SELECT 3 as x, 15 as y)
  SELECT x, y, udf.multiply_inputs(x, y) as product
  FROM numbers
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;persistent-udf-생성하기javascript&quot;&gt;Persistent UDF 생성하기(Javascript)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;SQL에서 하는 방식과 동일&lt;/li&gt;
  &lt;li&gt;BigQuery udf 데이터셋 생성(이미 존재하면 생략)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;custom_greeting 함수 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  CREATE OR REPLACE FUNCTION udf.custom_greeting(a STRING)
  RETURNS STRING
  LANGUAGE js AS &quot;&quot;&quot;
    var d = new Date();
    if (d.getHours() &amp;lt; 12) {
      return 'Good Morning, ' + a + '!';
    } else {
      return 'Good Evening, ' + a + '!';
    }
    &quot;&quot;&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;udf 데이터셋 확인
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/rkimy3xsup7vlvo/Screenshot%202019-09-21%2017.41.33.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;쿼리에서 UDF 사용하기&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  SELECT udf.custom_greeting(&quot;BYEON&quot;) AS result
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;외부 자바스크립트 파일을 활용할 경우
    &lt;ul&gt;
      &lt;li&gt;temp UDF처럼 Google Storage에 저장하고 사용&lt;/li&gt;
      &lt;li&gt;Uber의 H3 함수를 사용해보는 예시&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/jatorre/bigquery-jslibs/blob/master/libs/h3/3.5.0/h3-js.umd.3.5.0.js&quot;&gt;Github&lt;/a&gt;에서 자바스크립트 파일 다운로드
        &lt;ul&gt;
          &lt;li&gt;Raw 클릭 후 다른 이름으로 저장&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Google Storage에 해당 파일 업로드
        &lt;ul&gt;
          &lt;li&gt;저는 geultto-udf라는 곳에 저장&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/7v0f8n1m7qfysts/Screenshot%202019-09-21%2017.53.45.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;BigQuery에서 함수 정의&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  CREATE OR REPLACE FUNCTION udf.geo_to_h3(lat FLOAT64, lng FLOAT64, resolution INT64)
  RETURNS STRING 
  LANGUAGE js 
  AS
  '''return h3.geoToH3(lat, lng, resolution)''' 
  OPTIONS (library=[&quot;gs://geultto-udf/h3-js.umd.3.5.0.js&quot;]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;udf 데이터셋 확인
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/uvscxluv12j79lx/Screenshot%202019-09-21%2017.55.16.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;쿼리 예시&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  SELECT udf.geo_to_h3(36.123123, 128.123123, 8) as h3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;정리&quot;&gt;정리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CREATE TEMP FUNCTION을 사용하면 TEMP UDF 생성&lt;/li&gt;
  &lt;li&gt;CREATE FUNCTION을 사용하면 Persistent UDF 생성
    &lt;ul&gt;
      &lt;li&gt;Dataset 아래에 저장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CREATE OR REPLACE FUNCTION는 기존에 함수가 저장할 경우 수정함&lt;/li&gt;
  &lt;li&gt;UDF는 SQL, Javascript로 생성 가능
    &lt;ul&gt;
      &lt;li&gt;Javascript 활용시 단순 문법으로 생성 가능하고, 자바스크립트 라이브러리 파일을 사용해 생성 가능&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/bigquery/docs/reference/standard-sql/user-defined-functions#best-practices-for-javascript-udfs&quot;&gt;공식 문서&lt;/a&gt; : 권장 사항, 한도, 제한사항이 있으니 꼭 확인!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/bigquery/docs/reference/standard-sql/user-defined-functions&quot;&gt;Standard SQL User-Defined Functions&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@hoffa/new-in-bigquery-persistent-udfs-c9ea4100fd83&quot;&gt;New in BigQuery: Persistent UDFs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@mentin/persistent-udfs-bq-gis-66c8db903e4f&quot;&gt;Persistent UDFs + BQ GIS = ♥&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/GoogleCloudPlatform/bigquery-utils/tree/master/udfs/community&quot;&gt;bigquery-utils&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/jatorre/bigquery-jslibs&quot;&gt;bigquery-jslibs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 20 Sep 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/gcp/2019/09/20/bigquery-udf/</link>
        <guid isPermaLink="true">http://localhost:4000/gcp/2019/09/20/bigquery-udf/</guid>
        
        <category>BigQuery</category>
        
        
        <category>gcp</category>
        
      </item>
    
      <item>
        <title>Python SimPy 사용법 - 파이썬으로 시뮬레이션 만들기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Python SimPy 프레임워크를 사용해 파이썬으로 시뮬레이션 만드는 방법에 대해 작성한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;simpy&quot;&gt;SimPy&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;SimPy는 process 기반 discreate-event 시뮬레이션 프레임워크
    &lt;ul&gt;
      &lt;li&gt;코루틴을 잘 사용한 예시&lt;/li&gt;
      &lt;li&gt;SimPy의 process는 Python 제네레이터 함수로 정의되고, 고객, 차량 에이전트 같은 active component를 모델링할 때 사용될 수 있음&lt;/li&gt;
      &lt;li&gt;제한된 용량을 모델링하기 위해 shared resource도 제공함(서버나 체크아웃 카운터, 터널 등)&lt;/li&gt;
      &lt;li&gt;이론적으로 SimPy로 continuous simulation을 할 수 있지만, 도와주는 기능은 없음&lt;/li&gt;
      &lt;li&gt;반면 SimPy는 공유된 자원끼리 상호작용이 없는 고정된 크기의 시뮬레이션엔 오버 스펙임&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://readthedocs.org/projects/simpy/downloads/pdf/latest/&quot;&gt;SimPy Document&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Bk91DoAEcjY&quot;&gt;영상 자료&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;소스코드 : &lt;a href=&quot;https://bitbucket.org/simpy/simpy/&quot;&gt;Bitbucket&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;짧은 예제
    &lt;ul&gt;
      &lt;li&gt;2개의 시계가 다른 time interval로 움직이는 예제&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import simpy
	    
  def clock(env, name, tick):
      while True:
          print(name, env.now)
          yield env.timeout(tick)
	    
  env = simpy.Environment()
  env.process(clock(env, 'fast', 0.5))
  env.process(clock(env, 'slow', 1))
	    
  env.run(until=2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;설치&quot;&gt;설치&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip3 install simpy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사실 SimPy는 단순한 비동기 이벤트 dispatcher임
    &lt;ul&gt;
      &lt;li&gt;주어진 시뮬레이션 시간에 이벤트를 생성하고 예약함&lt;/li&gt;
      &lt;li&gt;이벤트는 우선 순위, 시뮬레이션 시간, event id에 의해 정렬됨&lt;/li&gt;
      &lt;li&gt;이벤트는 콜백 list를 가지고 있으며, event loop에 의해 실행됨&lt;/li&gt;
      &lt;li&gt;이벤트는 return value를 가질 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구성 요소
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/0d64nggr9ifd034/Screenshot 2019-09-01 23.57.27.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;1) Process&lt;/li&gt;
      &lt;li&gt;2) Resource
        &lt;ul&gt;
          &lt;li&gt;2-1) Resources
            &lt;ul&gt;
              &lt;li&gt;Resource&lt;/li&gt;
              &lt;li&gt;PriorityResource&lt;/li&gt;
              &lt;li&gt;PreemptiveResource&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;2-2) Containers&lt;/li&gt;
          &lt;li&gt;2-3) Stores
            &lt;ul&gt;
              &lt;li&gt;Store&lt;/li&gt;
              &lt;li&gt;FilterStore&lt;/li&gt;
              &lt;li&gt;PriorityStore&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;3) Environment&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;1-process&quot;&gt;1) Process&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;customer, vehicles 등 일반적인 agent를 모델링&lt;/li&gt;
  &lt;li&gt;순서가 있는 형태의 프로세스&lt;/li&gt;
  &lt;li&gt;Event 인스턴스를 yield하는 제네레이터 함수를 만듬&lt;/li&gt;
  &lt;li&gt;Generator 형태로 생성
    &lt;ul&gt;
      &lt;li&gt;제네레이터 내부에서 특정 activity가 수행될 때 resource에서 request를 날려 resource를 일정 시간동안 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;process의 이벤트 시간이 모두 지나면, 이벤트의 value를 받을 수 있음&lt;/li&gt;
  &lt;li&gt;중요한 이벤트 유형 : &lt;code class=&quot;highlighter-rouge&quot;&gt;Timeout&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;이 유형은 일정 시간이 지난 후 트리거됨. 주어진 시간동안 휴면 상태를 유지함&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Environment.timeout()&lt;/code&gt;으로 사용할 수 있음&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import simpy
	    
  def car(env):
      &quot;&quot;&quot;
      자동차 프로세스
      주차하고 여행을 떠남
      parking과 driving 상태를 스위칭함
      &quot;&quot;&quot;
      while True:
          print('Start parking at %d' % env.now)
          parking_duration = 5
                  # 환경에서 timeout 이벤트를 발생시킴(parking_duration동안 휴면)
          yield env.timeout(parking_duration)
	    
          print('Start driving at %d' % env.now)
          trip_duration = 2
          yield env.timeout(trip_duration)
	    
  env = simpy.Environment()
  env.process(car(env))
  env.run(until=15)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/m5r2i3x0awuwbw4/Screenshot 2019-09-02 00.03.57.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/lpkx2fovalw16bb/Screenshot 2019-09-02 00.04.11.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/i1rv04i2527jm5c/Screenshot 2019-09-02 00.04.23.png?raw=1&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;2-resource&quot;&gt;2) Resource&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;용량이 제한된 일종의 컨테이너&lt;/li&gt;
  &lt;li&gt;프로세스는 자원에 무언가를 넣거나 얻으려고 시도함&lt;/li&gt;
  &lt;li&gt;리소스가 꽉 찼거나 비어있으면 대기열에서 대기해야 함&lt;/li&gt;
  &lt;li&gt;모든 리소스엔 최대 용량과 두 개의 대기열이 있음
    &lt;ul&gt;
      &lt;li&gt;대기열 1개는 리소스를 넣기 위한 프로세스용 : put ⇒ request&lt;/li&gt;
      &lt;li&gt;다른 하나는 꺼내기를 위한 프로세스용 : get ⇒ release&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세스가 resource에 request하고, 사용한 후 release함
    &lt;ul&gt;
      &lt;li&gt;예를 들어 주유소에 차량이 도착하고, fule pump가 되면 떠남&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리소스 구조&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  BaseResource(capacity):
     put_queue
     get_queue
	    
     put(): event
     get(): event
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;총 3가지로 구현됨
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Resources&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;Resource : 양수여야 하고 기본값은 1
            &lt;ul&gt;
              &lt;li&gt;현재 사용자 또는 대기중인 사용자 목록, 리소스 용량을 검색할 수 있음&lt;/li&gt;
            &lt;/ul&gt;

            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import simpy
            
  res = simpy.Resource(env, capacity=1)
            
  def print_stats(res):
      print('%d of %d slots are allocated.' % (res.count, res.capacity))
      print('  Users:', res.users)
      print('  Queued events:', res.queue)
            
  def user(res):
      print_stats(res)
      with res.request() as req:
          yield req
          print_stats(res)
      print_stats(res)
            
  procs = [env.process(user(res)), env.process(user(res))]
  env.run()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/515rnaqx78rt9ev/Screenshot 2019-09-02 00.05.24.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;PriorityResource
            &lt;ul&gt;
              &lt;li&gt;프로세스가 각 요청에 우선 순위를 제공할 수 있음&lt;/li&gt;
              &lt;li&gt;더 중요한 요청 먼저 리소스에 액세스함&lt;/li&gt;
              &lt;li&gt;숫자가 작을수록 우선 순위가 높음&lt;/li&gt;
            &lt;/ul&gt;

            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import simpy
            
  def resource_user(name, env, resource, wait, prio):
      yield env.timeout(wait)
      with resource.request(priority=prio) as req:
          print('%s requesting at %s with priority=%s' % (name, env.now, prio))
          yield req
          print('%s got resource at %s' % (name, env.now))
          yield env.timeout(3)
            
  env = simpy.Environment()
  res = simpy.PriorityResource(env, capacity=1)
  p1 = env.process(resource_user(1, env, res, wait=0, prio=0))
  p2 = env.process(resource_user(2, env, res, wait=1, prio=0))
  p3 = env.process(resource_user(3, env, res, wait=2, prio=-1))
  env.run()
  # p3이 p2보다 늦게 리소스 요청했지만 우선 순이가 높아 더 일찍 리소스 사용함
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;PreemptiveResource
            &lt;ul&gt;
              &lt;li&gt;종종 새로운 요청이 기존 자원을 내쫓고 점유해야할 수 있음&lt;/li&gt;
              &lt;li&gt;PriorityResource에서 상속하고 preempt flag를 추가 request함(True로)&lt;/li&gt;
              &lt;li&gt;PreemptiveResource는 preemption보다 priorities가 더 우선순위가 높음&lt;/li&gt;
              &lt;li&gt;low priority, preemptive가 high priority를 뛰어넘을 수 없음&lt;/li&gt;
            &lt;/ul&gt;

            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import simpy
            
  def resource_user(name, env, resource, wait, prio):
      yield env.timeout(wait)
      with resource.request(priority=prio) as req:
          print('%s requesting at %s with priority=%s' % (name, env.now, prio))
          yield req
          print('%s got resource at %s' % (name, env.now))
          try:
              yield env.timeout(3)
          except simpy.Interrupt as interrupt:
              by = interrupt.cause.by
              usage = env.now - interrupt.cause.usage_since
              print('%s got preempted by %s at %s after %s' %
                    (name, by, env.now, usage))
            
  env = simpy.Environment()
  res = simpy.PreemptiveResource(env, capacity=1)
  p1 = env.process(resource_user(1, env, res, wait=0, prio=0))
  p2 = env.process(resource_user(2, env, res, wait=1, prio=0))
  p3 = env.process(resource_user(3, env, res, wait=2, prio=-1))
  env.run()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Containers&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;미분화된 대량 생산, 소비를 모델링할 수 있음&lt;/li&gt;
          &lt;li&gt;물 같은 연속적인 것과 사과와 같은 불연속적인 것이 사용 가능&lt;/li&gt;
          &lt;li&gt;주유소의 가스 / 휘발유 탱크를 모델링할 때 사용할 수 있음&lt;/li&gt;
          &lt;li&gt;현재 level을 검색할 수 있음. capacity(GasStation.monitor_tank()&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import simpy
        
  class GasStation:
      def __init__(self, env):
          self.fuel_dispensers = simpy.Resource(env, capacity=2)
          self.gas_tank = simpy.Container(env, init=100, capacity=1000)
          self.mon_proc = env.process(self.monitor_tank(env))
        
      def monitor_tank(self, env):
          while True:
              if self.gas_tank.level &amp;lt; 100:
                  print('Calling tanker at %s' % env.now)
                  env.process(tanker(env, self))
              yield env.timeout(15)
        
  def tanker(env, gas_station):
      yield env.timeout(10)  # Need 10 Minutes to arrive
      print('Tanker arriving at %s' % env.now)
      amount = gas_station.gas_tank.capacity - gas_station.gas_tank.level
      yield gas_station.gas_tank.put(amount)
        
  def car(name, env, gas_station):
      print('Car %s arriving at %s' % (name, env.now))
      with gas_station.fuel_dispensers.request() as req:
          yield req
          print('Car %s starts refueling at %s' % (name, env.now))
          yield gas_station.gas_tank.get(40)
          yield env.timeout(5)
          print('Car %s done refueling at %s' % (name, env.now))
        
  def car_generator(env, gas_station):
  		&quot;&quot;&quot;
  		차량을 생성하는 함수
  		&quot;&quot;&quot;
      for i in range(4):
          env.process(car(i, env, gas_station))
          yield env.timeout(5)
        
  env = simpy.Environment()
  gas_station = GasStation(env)
  car_gen = env.process(car_generator(env, gas_station))
  env.run(35)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Stores&lt;/code&gt; : object의 생산과 소비를 모델링 할 수 있음
        &lt;ul&gt;
          &lt;li&gt;일반적인 Store&lt;/li&gt;
        &lt;/ul&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import simpy
        
  def producer(env, store):
      for i in range(100):
          yield env.timeout(2)
          yield store.put('spam %s' % i)
          print('Produced spam at', env.now)
        
        
  def consumer(name, env, store):
      while True:
          yield env.timeout(1)
          print(name, 'requesting spam at', env.now)
          item = yield store.get()
          print(name, 'got', item, 'at', env.now)
        
        
  env = simpy.Environment()
  store = simpy.Store(env, capacity=2)
        
  prod = env.process(producer(env, store))
  consumers = [env.process(consumer(i, env, store)) for i in range(2)]
        
  env.run(until=5)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;ul&gt;
          &lt;li&gt;FilterStore : store에서 object를 가져갈 때 커스텀 함수를 사용하는 store
            &lt;ul&gt;
              &lt;li&gt;다양한 속성이 있는 기계 공장을 모델링함&lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;FilterStore의 items에 값을 저장함!!&lt;/p&gt;

                &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import simpy
		        
  from collections import namedtuple
		        
  Machine = namedtuple('Machine', 'size, duration')
  m1 = Machine(1, 2)  # Small and slow
  m2 = Machine(2, 1)  # Big and fast
		        
  env = simpy.Environment()
  machine_shop = simpy.FilterStore(env, capacity=2)
  machine_shop.items = [m1, m2]  # Pre-populate the machine shop
		        
  def user(name, env, ms, size):
      machine = yield ms.get(lambda machine: machine.size == size)
      print(name, 'got', machine, 'at', env.now)
      yield env.timeout(machine.duration)
      yield ms.put(machine)
      print(name, 'released', machine, 'at', env.now)
		        
		        
  users = [env.process(user(i, env, machine_shop, (i % 2) + 1))
           for i in range(3)]
  env.run()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                &lt;/div&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;PriorityStore : 우선 순위에 따라 필터링할 수 있는 store
            &lt;ul&gt;
              &lt;li&gt;inspector 프로세스가 maintainer 프로세스가 우선 순위에 따라 복구되도록 기록함&lt;/li&gt;
            &lt;/ul&gt;

            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import simpy
	    
  env = simpy.Environment()
  issues = simpy.PriorityStore(env)
			    
  def inspector(env, issues):
      for issue in [simpy.PriorityItem('P2', '#0000'),
                    simpy.PriorityItem('P0', '#0001'),
                    simpy.PriorityItem('P3', '#0002'),
                    simpy.PriorityItem('P1', '#0003')]:
          yield env.timeout(1)
          print(env.now, 'log', issue)
          yield issues.put(issue)
			    
  def maintainer(env, issues):
      while True:
          yield env.timeout(3)
          issue = yield issues.get()
          print(env.now, 'repair', issue)
			    
  _ = env.process(inspector(env, issues))
  _ = env.process(maintainer(env, issues))
  env.run()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;3-environment&quot;&gt;3) Environment&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;simulation 하려는 환경&lt;/li&gt;
  &lt;li&gt;환경은 이벤트 목록에 이벤트들을 저장하고 현재 시뮬레이션 시각을 추적함&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ztbxm58ebklyxgx/Screenshot 2019-09-02 00.01.45.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/f05xzo8ql4v8uhp/Screenshot 2019-09-02 00.02.30.png?raw=1&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;예시&quot;&gt;예시&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;차량 인스턴스 예시&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import simpy
	    
  class Car:
      def __init__(self, env):
          self.env = env
          # Start the run process everytime an instance is created.
          self.action = env.process(self.run())
	    
      def run(self):
          while True:
              print('Start parking and charging at %d' % self.env.now)
              charge_duration = 5
              # We yield the process that process() returns
              # to wait for it to finish
              yield self.env.process(self.charge(charge_duration))
	    
              # The charge process has finished and
              # we can start driving again.
              print('Start driving at %d' % self.env.now)
              trip_duration = 2
              yield self.env.timeout(trip_duration)
	    
      def charge(self, duration):
          yield self.env.timeout(duration)
	    
  env = simpy.Environment()
  car = Car(env)
  env.run(until=15)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;자동차가 완전히 충전될 때까지 기다리지 않고 도중에 충전 중단하고 운전할 경우
    &lt;ul&gt;
      &lt;li&gt;interrupt()를 호출해 실행 중 프로세스를 중단할 수 있음&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  import simpy
    
  def driver(env, car):
      yield env.timeout(3)
      car.action.interrupt()
        
  class Car:
      def __init__(self, env):
          self.env = env
          self.action = env.process(self.run())
    
      def run(self):
          while True:
              print('Start parking and charging at %d' % self.env.now)
              charge_duration = 5
              # We may get interrupted while charging the battery
              try:
                  yield self.env.process(self.charge(charge_duration))
              except simpy.Interrupt:
                  # When we received an interrupt, we stop charging and
                  # switch to the &quot;driving&quot; state
                  print('Was interrupted. Hope, the battery is full enough ...')
    
              print('Start driving at %d' % self.env.now)
              trip_duration = 2
              yield self.env.timeout(trip_duration)
    
      def charge(self, duration):
          yield self.env.timeout(duration)
            
  env = simpy.Environment()
  car = Car(env)
  env.process(driver(env, car))
  env.run(until=15)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 글에선 같이 시뮬레이션 예제를 구현해보는 글을 작성할 예정입니다 :)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 02 Sep 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/2019/09/02/simpy-intro/</link>
        <guid isPermaLink="true">http://localhost:4000/data/2019/09/02/simpy-intro/</guid>
        
        <category>simulation</category>
        
        
        <category>data</category>
        
      </item>
    
      <item>
        <title>Constraint Programming의 이해</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Constraint Programming에 대해 작성한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;constraint-programming&quot;&gt;Constraint Programming&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2가지 흥미로운 포인트
    &lt;ul&gt;
      &lt;li&gt;Computational paradigm
        &lt;ul&gt;
          &lt;li&gt;제약 조건을 사용해 각각의 변수가 취할 수 있는 값들의 집합을 줄임(=Search Space를 줄임)&lt;/li&gt;
          &lt;li&gt;어떤 솔루션에도 나타나지 않을 값을 제거&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Modeling methodology
        &lt;ul&gt;
          &lt;li&gt;문제의 구조를 가능한한 명확하게 전달&lt;/li&gt;
          &lt;li&gt;문제의 세부구조를 표현&lt;/li&gt;
          &lt;li&gt;가능하면 solver에게 많은 정보를 제공&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구체적 예시
    &lt;ul&gt;
      &lt;li&gt;체스판에서 8개의 퀸이 있고 서로 공격함&lt;/li&gt;
      &lt;li&gt;같은 column, row, diagonal에 있으면 서로 공격&lt;/li&gt;
      &lt;li&gt;upper and lowd diaagonal로 이동 가능&lt;/li&gt;
      &lt;li&gt;여왕이 점점 배치되며 feasible solution이 없는 것을 볼 수 있음, 다른 곳에 두었어야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Choice란?
    &lt;ul&gt;
      &lt;li&gt;엄청 많은 선택이 있음&lt;/li&gt;
      &lt;li&gt;일단 처음에 우리가 다루는 선택은 특정 값을 할당하는 것&lt;/li&gt;
      &lt;li&gt;선택이 잘못될 수 있음
        &lt;ul&gt;
          &lt;li&gt;최적화에서 자주 잘못되곤 함&lt;/li&gt;
          &lt;li&gt;solver가 역추적해서 다른 값을 선택해야 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Coloring a Map
    &lt;ul&gt;
      &lt;li&gt;인접한 두 지역에 같은 색을 받지 않도록 지도에 색을 칠하기&lt;/li&gt;
      &lt;li&gt;4개의 Color
        &lt;ul&gt;
          &lt;li&gt;모든 map은 4가지 색으로 칠해져야 함&lt;/li&gt;
          &lt;li&gt;컴퓨터로 입증된 최초의 정리&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;constraint programming을 어떻게 적용할까?
        &lt;ul&gt;
          &lt;li&gt;Decision variable를 선택&lt;/li&gt;
          &lt;li&gt;Decision variable의 constraints를 표현&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Decision variables : 각각의 나라에 색칠된 색&lt;/li&gt;
      &lt;li&gt;Decision variables의 도메인
        &lt;ul&gt;
          &lt;li&gt;4 color&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Constraint
        &lt;ul&gt;
          &lt;li&gt;인접한 나라에 같은 색을 사용할 수 없음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Branch and prune
    &lt;ul&gt;
      &lt;li&gt;pruning
        &lt;ul&gt;
          &lt;li&gt;가능한만큼 search space를 줄임&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;branching
        &lt;ul&gt;
          &lt;li&gt;문제를 하위 문제로 분해하고 하위 문제를 탐색&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Constraint의 역할
    &lt;ul&gt;
      &lt;li&gt;feasibility checking&lt;/li&gt;
      &lt;li&gt;pruning&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The propagation engine
    &lt;ul&gt;
      &lt;li&gt;constraint programming의 core&lt;/li&gt;
      &lt;li&gt;간단한 알고리즘&lt;/li&gt;
      &lt;li&gt;너 feasible이니? =&amp;gt; T/F&lt;/li&gt;
      &lt;li&gt;서치 스페이스 줄임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Feasibility checking
    &lt;ul&gt;
      &lt;li&gt;변수의 값이 주어지면 제약 조건을 충족시킬 수 있는지 확인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pruning
    &lt;ul&gt;
      &lt;li&gt;만족할 경우 도메인의 값을 결정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;알고리즘은 각 제약조건마다 전용 알고리즘이 존재&lt;/li&gt;
  &lt;li&gt;Send More Money Problem
    &lt;ul&gt;
      &lt;li&gt;복면산은 문자나 그림으로 표현된 숫자를 맞히는 것&lt;/li&gt;
      &lt;li&gt;숫자는 겹치지 않고, 맨 앞자리 숫자는 0이 아님&lt;/li&gt;
      &lt;li&gt;Decision Variables
        &lt;ul&gt;
          &lt;li&gt;글자 값을 나타내는 각 글자들을 변수로 지정&lt;/li&gt;
          &lt;li&gt;carry마다 변수 존재&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/bwvexeo55ql3xai/Screenshot%202019-08-27%2022.17.45.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/o0acbs6bzgp6zkd/Screenshot%202019-08-27%2022.40.36.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Propagation engine
        &lt;ul&gt;
          &lt;li&gt;constraint programming solver의 핵심&lt;/li&gt;
          &lt;li&gt;간단한 고정된 알고리즘&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/30spxepayq0ph6e/Screenshot%202019-08-27%2022.42.35.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/vtu1spqcyaox6ds/Screenshot%202019-08-27%2022.44.27.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/4onlqx3tw1uk1lz/Screenshot%202019-08-27%2022.44.48.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;global-constraint&quot;&gt;Global Constraint&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Constraint programming의 중요한 특징
    &lt;ul&gt;
      &lt;li&gt;다양한 어플리케이션에서 발생하는 하위 조합을 표현&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Global constraint도 마찬가지로 하위 조합 표현&lt;/li&gt;
  &lt;li&gt;Global Constraint가 존재하는 이유
    &lt;ul&gt;
      &lt;li&gt;constraint c(x1, …xn)&lt;/li&gt;
      &lt;li&gt;x1 in D1, … xn in Dn&lt;/li&gt;
      &lt;li&gt;1) Feasibility testing
        &lt;ul&gt;
          &lt;li&gt;제약 조건이 유지되도록 변수 도메인에서 값을 찾을 수 있는지 테스트&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) Pruning
        &lt;ul&gt;
          &lt;li&gt;D_{i}의 v_{i}가 주어졌을 때, x_{i}=v_{i}를 만족하는 솔루션이 있는가?&lt;/li&gt;
          &lt;li&gt;constraint를 만족하는 variable domain을 찾을 수 있는가? 이런 질문과 함께 search space 정리함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Global Constraint의 종류
    &lt;ul&gt;
      &lt;li&gt;1) AllDifferent
        &lt;ul&gt;
          &lt;li&gt;모든 값이 다른 제약 조건&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/bpj7wz88d5zcxw8/Screenshot%202019-08-31%2013.47.37.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/abb5oh69gumslg6/Screenshot%202019-08-31%2013.54.13.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2) Table Constraints
        &lt;ul&gt;
          &lt;li&gt;가능한 집합을 Table로 만들고, 특정 조건을 만족하는 경우를 찾음&lt;/li&gt;
          &lt;li&gt;모든 변수에 대한 카테시안 곱의 하위 집합을 명시&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/5balccombtfpwii/Screenshot%202019-09-01%2000.14.03.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;패러다임 도식화
        &lt;ul&gt;
          &lt;li&gt;여러 Constraint
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/dh5vtkuu1i8vw0f/Screenshot%202019-08-31%2023.24.10.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Global Constraint
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/rvdrx6qd01kpjmn/Screenshot%202019-08-31%2023.33.01.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스도쿠
    &lt;ul&gt;
      &lt;li&gt;Constraint Programming을 활용해 스도쿠를 풀 수 있음&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/tkh5ckzcenvv5fc/Screenshot%202019-08-31%2023.46.20.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Graph Coloring
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/8end8gdp7a7zmey/Screenshot%202019-09-01%2000.16.13.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Constraint Programming에서 집중하는 것
    &lt;ul&gt;
      &lt;li&gt;Feasibility&lt;/li&gt;
      &lt;li&gt;Optimize 하는 방법
        &lt;ul&gt;
          &lt;li&gt;Solve a sequence of satisfaction problems&lt;/li&gt;
          &lt;li&gt;Find a solution&lt;/li&gt;
          &lt;li&gt;impose a constraint that the next solution must be better&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;최적의 솔루션을 찾도록 보장하는 경우
        &lt;ul&gt;
          &lt;li&gt;이론적으론 알지만 실제로 찾는 시간이 너무 오래 걸림&lt;/li&gt;
          &lt;li&gt;새로운 제약 조건이 search space를 감소할 때 효과적(스케쥴링 문제가 그 예시)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;constraint-programming-modeling-techniques&quot;&gt;Constraint Programming modeling techniques&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Symmetry breaking
    &lt;ul&gt;
      &lt;li&gt;많은 문제들이 대칭적임&lt;/li&gt;
      &lt;li&gt;검색 공간의 대칭 부분을 탐색하는 것은 쓸모없음&lt;/li&gt;
      &lt;li&gt;symmetries의 종류
        &lt;ul&gt;
          &lt;li&gt;variable symmetries&lt;/li&gt;
          &lt;li&gt;value symmetries&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Balanced Incomplete Block Designs(BIBDs)
        &lt;ul&gt;
          &lt;li&gt;Input : (v,b,r,k,l)&lt;/li&gt;
          &lt;li&gt;Output : 0/1로 구성된 행렬&lt;/li&gt;
          &lt;li&gt;Constraint : row의 수는 r, 컬럼의 수는 k, 스칼라곱은 I&lt;/li&gt;
          &lt;li&gt;Why BIBDs?
            &lt;ul&gt;
              &lt;li&gt;combinatorial design 예제&lt;/li&gt;
              &lt;li&gt;variable symmetries 예제&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/vda51rltrme68du/Screenshot%202019-09-01%2009.51.31.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;행과 열을 swap할 수 있음 =&amp;gt; 대칭
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/2jjcwwprhj3sz3s/Screenshot%202019-09-01%2009.58.52.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;variable symmetries를 해결하는 방법
            &lt;ul&gt;
              &lt;li&gt;변수에 순서를 정함&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;row symmetries를 고려
            &lt;ul&gt;
              &lt;li&gt;사전(lexicographic) 제약을 추가함&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;lexicographic ordering
            &lt;ul&gt;
              &lt;li&gt;첫 값을 비교해서 어떤 것이 큰지? 같으면 그 다음값&lt;/li&gt;
              &lt;li&gt;a: 0 1 1 0 0 1 0 / b: 1 0 1 0 1 0 0 =&amp;gt; a&amp;lt;=b&lt;/li&gt;
              &lt;li&gt;a: 1 1 1 0 0 1 0 / b: 1 0 1 0 1 0 0 =&amp;gt; a&amp;gt;=b&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ehmovqtl50csqkm/Screenshot%202019-09-01%2010.07.27.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/wkp5ql9k3604pvz/Screenshot%202019-09-01%2010.09.46.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Scene Allocation
        &lt;ul&gt;
          &lt;li&gt;영화의 scene을 찍음
            &lt;ul&gt;
              &lt;li&gt;배우들은 scene에서 연기하며, 하루에 k개의 scnes을 찍을 수 있음&lt;/li&gt;
              &lt;li&gt;배우들 고용시 하루마다 비용이 나감&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Objective
            &lt;ul&gt;
              &lt;li&gt;minimize the total cost&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/evhyfoojstf7sle/Screenshot%202019-09-01%2010.19.10.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;Value symmetries
            &lt;ul&gt;
              &lt;li&gt;day는 교환 가능&lt;/li&gt;
              &lt;li&gt;1일차랑 2일차 장면을 모두 바꿔도 됨&lt;/li&gt;
              &lt;li&gt;s가 solution일 때, p(s)는 s의 날짜가 순열 p에 의해 순서가 배열된 솔루션임&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;이 symmetries를 없애려면?
            &lt;ul&gt;
              &lt;li&gt;하루에 1개식만 생각&lt;/li&gt;
              &lt;li&gt;월요일 화요일 등 모두 같음(단, 급여가 달라지면 다른 방법..)&lt;/li&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/rth57wdqpgwtofe/Screenshot%202019-09-01%2010.44.42.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/cqe6f8pnyko3gz7/Screenshot%202019-09-01%2010.44.53.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Redundant constraints(중복 제약)
    &lt;ul&gt;
      &lt;li&gt;Motivation
        &lt;ul&gt;
          &lt;li&gt;Semantically redundant
            &lt;ul&gt;
              &lt;li&gt;do not exclude any solution&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;computationally significant
            &lt;ul&gt;
              &lt;li&gt;reduce the search space&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;redundant constraint를 어떻게 찾을까?
        &lt;ul&gt;
          &lt;li&gt;모델에 포착되지 않는 솔루션의 속성을 나타냄&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;모델에 constraint을 더 많이 넣을수록 컴파일 속도가 더 빨라짐&lt;/li&gt;
      &lt;li&gt;Constraint Programming의 중요한 측면&lt;/li&gt;
      &lt;li&gt;Magic Series
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9vy4gutbdyilgbo/Screenshot%202019-09-01%2011.11.02.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;Decision variables는 발생 횟수를 나타내고 발생 횟수가 제한됨&lt;/li&gt;
          &lt;li&gt;중간 값이 얼마인지 알면 더 강한 제약조건을 나타낼 수 있음
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/xd2854qqm8tonuh/Screenshot%202019-09-01%2011.12.34.png?raw=1&quot; /&gt;&lt;/li&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9gfvaq207u2tlwk/Screenshot%202019-09-01%2011.15.58.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Redundant constraints의 역할
        &lt;ul&gt;
          &lt;li&gt;1) First
            &lt;ul&gt;
              &lt;li&gt;solution의 property 표현&lt;/li&gt;
              &lt;li&gt;다른 제약조건의 전파를 강화&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;2) Second
            &lt;ul&gt;
              &lt;li&gt;gloval view 제공&lt;/li&gt;
              &lt;li&gt;존재하는 제약조건 결합&lt;/li&gt;
              &lt;li&gt;커뮤니케이션 증가&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Market Split Problems
        &lt;ul&gt;
          &lt;li&gt;Surrogate constraint
            &lt;ul&gt;
              &lt;li&gt;존재하는 제약조건 결합&lt;/li&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/gxxzn407wljn8o3/Screenshot%202019-09-01%2011.25.00.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/8zvu779biphpp4s/Screenshot%202019-09-01%2011.24.46.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Car Sequencing
    &lt;ul&gt;
      &lt;li&gt;redundant constraint이 존재&lt;/li&gt;
      &lt;li&gt;조립 공정에서 일정 순서가 있고, 특정 옵션이 있음&lt;/li&gt;
      &lt;li&gt;생산 유닛당 capacity constraint가 존재 : 5대 중 최대 2대는 moonroof가 필요할 수 있음&lt;/li&gt;
      &lt;li&gt;capacity constraint이 충족되도록 자동차 생산&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/e1fu15j8b66szex/Screenshot%202019-09-01%2011.30.55.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/1ag346w8xbopn86/Screenshot%202019-09-01%2011.31.15.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/04n2zrin222qyyk/Screenshot%202019-09-01%2011.39.08.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/4jegf069satu27h/Screenshot%202019-09-01%2011.39.31.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;차를 몇대 생산할 수 있는지 추론가능하고, 10대에서 2대 생산 =&amp;gt; 이제 8대 =&amp;gt; 이렇게 계속 실제 자동차수를 제한할 수 있음. 본질적으로 알고있는 제약임
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/dfmvu08dyea09f9/Screenshot%202019-09-01%2012.19.53.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Dual Modeling
    &lt;ul&gt;
      &lt;li&gt;문제를 모델링할 때 다양한 방법이 존재할 수 있음
        &lt;ul&gt;
          &lt;li&gt;같은 decision variable을 사용하지 않아도 됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;두 모델은 서로 보완하는 강점을 가질 수 있음
        &lt;ul&gt;
          &lt;li&gt;그들 사이에 선택하는게 어려움&lt;/li&gt;
          &lt;li&gt;어떤 모델은 특정 제약조건을 잘 표현하고, 다른 모델은 다른 제약조건을 잘 표현&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;따라서 dual modeling은 문제의 여러 모델을 설명하고 제약 조건과 연결하는 아이디어에서 시작&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/bon3miuuwe8nuhe/Screenshot%202019-09-01%2012.26.49.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/vjc4ph5zhlojwbi/Screenshot%202019-09-01%2012.28.22.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CP 8&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Coursera &lt;a href=&quot;https://www.coursera.org/learn/discrete-optimization&quot;&gt;Discrete Optimization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 01 Sep 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/2019/09/01/constraint_programming/</link>
        <guid isPermaLink="true">http://localhost:4000/data/2019/09/01/constraint_programming/</guid>
        
        <category>optimization</category>
        
        
        <category>data</category>
        
      </item>
    
      <item>
        <title>if kakao 2019 2일차 후기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;if kakao 2019 2일차 세션을 들으며 메모한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;금융사기-잡는-카카오뱅크의-데이터-사이언스&quot;&gt;금융사기 잡는 카카오뱅크의 데이터 사이언스&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;전상현님&lt;/li&gt;
  &lt;li&gt;금융사기를 어떻게 잡는지, 시도했던 것들을 소개&lt;/li&gt;
  &lt;li&gt;카카오뱅크의 데이터 사이언스 소개
    &lt;ul&gt;
      &lt;li&gt;Anomaly Detection, Topological, Network Analysis 등&lt;/li&gt;
      &lt;li&gt;7월에 고객 1000만명 돌파&lt;/li&gt;
      &lt;li&gt;2030세대 전체의 45%가 카카오뱅크 이용&lt;/li&gt;
      &lt;li&gt;카카오택시 내역을 신용평가에 반영하고 있음&lt;/li&gt;
      &lt;li&gt;은행 업무 중 발생하는 데이터 문제를 해결
        &lt;ul&gt;
          &lt;li&gt;데이터에서 인상이트 찾기
            &lt;ul&gt;
              &lt;li&gt;예 : 모임통장 이후 카뱅의 변화 분석&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;기계학습/딥러닝 모형 개발
            &lt;ul&gt;
              &lt;li&gt;보이스피싱 탐지 모형 개발&lt;/li&gt;
              &lt;li&gt;이상거래 탐지 모형 개발&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;금융사기와 FDS
    &lt;ul&gt;
      &lt;li&gt;보이스피싱은 점점 늘고 있고, 금융사기도 지능화되고 있음&lt;/li&gt;
      &lt;li&gt;스미싱, 보이스피싱, 파밍, 대포통장 등의 방법&lt;/li&gt;
      &lt;li&gt;FDS(이상금융거래 탐지 시스템)
        &lt;ul&gt;
          &lt;li&gt;앱 원격 조종?
            &lt;ul&gt;
              &lt;li&gt;기기 정보 / 앱 실행 정보 / 악성 앱 설치 여부&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;거래가 없던 계좌에 큰 금액 이체?
            &lt;ul&gt;
              &lt;li&gt;거래 내역&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;카카오뱅크는 금융사기 문제는 어떻게 접근하고 있나?
    &lt;ul&gt;
      &lt;li&gt;카카오뱅크는 전자금융 FDS와 체크카드 FDS가 존재&lt;/li&gt;
      &lt;li&gt;전자금융
        &lt;ul&gt;
          &lt;li&gt;자체 개발&lt;/li&gt;
          &lt;li&gt;인터넷 은행, 카뱅만의 상품, 활동적인 고객이 존재&lt;/li&gt;
          &lt;li&gt;빠른 사기 탐지, 더 정확한 탐지, 신종 사기 대응해야 함&lt;/li&gt;
          &lt;li&gt;더 맞는 규칙 기반 모형 + 머신러닝 모형&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;머신러닝
        &lt;ul&gt;
          &lt;li&gt;지도학습
            &lt;ul&gt;
              &lt;li&gt;극단적인 데이터 불균형, 정상 99.9% 사기 0.1%
                &lt;ul&gt;
                  &lt;li&gt;데이터 불균형이 심하면 사기 예측 모형이 동작하지 않음&lt;/li&gt;
                  &lt;li&gt;고객 정보, 금융 활동, 앱 활동을 토대로 DNN =&amp;gt; 모든게 정상이라 예측함. 사기를 잡을 수 없음&lt;/li&gt;
                  &lt;li&gt;따라서 언더샘플링과 오버샘플링을 통한 정상/사기 비율 개선&lt;/li&gt;
                  &lt;li&gt;정상은 언더, 사기는 오버&lt;/li&gt;
                  &lt;li&gt;딥러닝 사용시 정상과 사기의 Loss 비율을 조절, 정상 loss : 사기 loss = 1:10&lt;/li&gt;
                  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/vhlwfkzwrt3pl3c/2019-08-30%2011.08.11.jpg?raw=1&quot; /&gt;&lt;/li&gt;
                  &lt;li&gt;ANN을 통해 정상 근처의 데이터만 샘플링&lt;/li&gt;
                  &lt;li&gt;사기 데이터 생성을 위해 VAE 사용(그냥 늘리거나 통계적으로 할 수 있지만 VAE 사용)&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;시계열 이벤트 데이터 처리 : 앱 활동 =&amp;gt; 로그인 =&amp;gt; 간편이체 =&amp;gt; 대출금조회 =&amp;gt; 마이너스대출 =&amp;gt; 로그아웃
                &lt;ul&gt;
                  &lt;li&gt;앱 활동은 FastText로 벡터화&lt;/li&gt;
                  &lt;li&gt;계좌이체, 간편이체, 계자조회(잔고&amp;lt;0), 계자조회(잔고&amp;gt;0), 해외송금, 계좌개설, 마이너스대출, 신용대출 등&lt;/li&gt;
                  &lt;li&gt;벡터화한 이벤트는 1D CNN을 통과시킴, 속도 때문에 1D CNN씀 =&amp;gt; 정상과 사기 비율 맞춤&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;비지도학습
            &lt;ul&gt;
              &lt;li&gt;Auto-Encoder를 통한 이상거래 탐지
                &lt;ul&gt;
                  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/nazq98ge8y5qne7/2019-08-30%2011.12.32.jpg?raw=1&quot; /&gt;&lt;/li&gt;
                  &lt;li&gt;원본 데이터를 넣으면 z로 압축하고, 그 압축된 데이터를 복원하는 모형&lt;/li&gt;
                  &lt;li&gt;정상 데이터로 학습한 뒤, 이상 데이터가 들어오면 X와 X’의 차이가 커지는 것으로 이상 거래를 탐지&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;z를 같이 고려한 Deep Autoencoding Gaussian Mixture Model for Unsupervised Anomaly Detection
                &lt;ul&gt;
                  &lt;li&gt;보다 세밀하게 이상거래를 탐지할 수 있지만 충분하진 않음&lt;/li&gt;
                  &lt;li&gt;실제 정상적인 행동이지만 사기도 많음&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;성능 개선 정도
            &lt;ul&gt;
              &lt;li&gt;데이터 샘플링, Loss 조절, 이벤트 벡터화, 1D CNN, Auto Encoder를 통해 Recall 50% 상승, Precision 20% 상승
                &lt;ul&gt;
                  &lt;li&gt;Recall은 쉽지만 Precision 올리는게 어려워서 더 개선할 예정&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정리
    &lt;ul&gt;
      &lt;li&gt;탐지 모형 개발은 금융 사기 탐지의 극히 일부분&lt;/li&gt;
      &lt;li&gt;복잡한 딥러닝 모형이 답을 주진 않음&lt;/li&gt;
      &lt;li&gt;모형도 중요하지만 변수 선택 및 전처리가 더 주용&lt;/li&gt;
      &lt;li&gt;서비스 반영은 또 다른 큰 산&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;요새 실험중인 기법들
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ddlzeiyc1tfmc86/2019-08-30%2011.15.20.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;TDA(Topoglocial Data Analysis)
        &lt;ul&gt;
          &lt;li&gt;이상탐지, 기계학습 모형 설명, 시각화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Graph Deep Learning
        &lt;ul&gt;
          &lt;li&gt;그래프 데이터, 노드와 엣지의 특성 반영&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Label Propagation
        &lt;ul&gt;
          &lt;li&gt;준지도학습, 라벨의 일부만 알 때&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TDA
    &lt;ul&gt;
      &lt;li&gt;2007년 mapper 알고리즘 발표 후 주목됨&lt;/li&gt;
      &lt;li&gt;이상탐지에 많이 사용되고, 의학/금융 분야에서 활용&lt;/li&gt;
      &lt;li&gt;AYASDI라는 회사가 많은 특허 보유함&lt;/li&gt;
      &lt;li&gt;Google에 TDA 치면 한국분 1분 나오는데, 카뱅분임&lt;/li&gt;
      &lt;li&gt;핵심
        &lt;ul&gt;
          &lt;li&gt;Topological - Data - Analysis&lt;/li&gt;
          &lt;li&gt;데이터가 갖는 모양으로 모양의 의미를 분석&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/keg7pmoba33l1ok/2019-08-30%2011.17.55.jpg?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;테이블 데이터가 가운데 이미지처럼 그래프로 나오고, 어느쪽은 정상 1형 당뇨 등등이 구분됨&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9b0s4b0jkdyrnfu/2019-08-30%2011.18.51.jpg?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/b44uznz2jtdfjhk/2019-08-30%2011.20.05.jpg?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;원본 데이터를 가로축 따라 데이터 나누고(데이터 영역이 겹침), 그 데이터를 kmeans로 클러스터링 =&amp;gt; Topology 구성
            &lt;ul&gt;
              &lt;li&gt;노드 : 각 영역의 데이터 군집&lt;/li&gt;
              &lt;li&gt;연결 : 공통 데이터가 존재하는 인접한 군집&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;k-means와 topological 비교
            &lt;ul&gt;
              &lt;li&gt;
                &lt;사진&gt;
&lt;/사진&gt;
              &lt;/li&gt;
              &lt;li&gt;데이터 특성을 잘 표현하는 군집과 관계를 찾아냄&lt;/li&gt;
              &lt;li&gt;Outlier 또한 군집으로 잘 찾아냄&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TDA for Credit Card Fraud Detection
    &lt;ul&gt;
      &lt;li&gt;신용카드 데이터에 대해 TDA 해봄&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/qb2v0qv5f9fp3j1/2019-08-30%2011.21.19.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;색이 진할수록 군집에 사기가 많다는 것&lt;/li&gt;
      &lt;li&gt;뉴럴넷은 사기가 있다 없다만 알 수 있는데, 몇가지의 사기냐는 어려움. TDA는 어떤 형태의 사기가 있다는 것을 파악할 수 있음&lt;/li&gt;
      &lt;li&gt;풀리커넥티드 들어가기 전 데이터로 TDA를 해봤는데, 색이 진할수록 사기가 많음&lt;/li&gt;
      &lt;li&gt;이제 더 분석해서 결과를 얻을 예정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;질문
    &lt;ul&gt;
      &lt;li&gt;새로운 사기 대응은 어떻게 하는가?
        &lt;ul&gt;
          &lt;li&gt;비지도로 탐지할 수도 있고, 평상시에 데이터 분석하며 할 수 있고, 새로운 사기가 올라오면 금융권끼리 사례 공유가 됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Autoencoder의 쓰레솔드 어떻게 줬는지?
        &lt;ul&gt;
          &lt;li&gt;실제로 오토인코더로 탐지하지 않음. 정상과 사기가 잘 분리가 안됨. 탐지는 안되고 feature 정도로만 사용&lt;/li&gt;
          &lt;li&gt;쓰레솔드를 다 조절해봤는데, 오탐이 너무 높았음&lt;/li&gt;
          &lt;li&gt;이걸 통해 정상이나 아니다 나누진 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;후기
    &lt;ul&gt;
      &lt;li&gt;Anoamly Detection하는 방법을 깔끔하게 말씀해주셔서 만족스러운 발표!&lt;/li&gt;
      &lt;li&gt;TDA란 것도 알게되서 유익했음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;buffalo-open-source-project-for-recommender-system&quot;&gt;Buffalo: Open Source Project for Recommender System&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;김광섭님&lt;/li&gt;
  &lt;li&gt;버팔로의 특징
    &lt;ul&gt;
      &lt;li&gt;지원 알고리즘&lt;/li&gt;
      &lt;li&gt;뛰어난 생싼성과 성능&lt;/li&gt;
      &lt;li&gt;편의 기능
        &lt;ul&gt;
          &lt;li&gt;실험할 때 필요한 기능들&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;추천시스템과 버팔로의 관계
    &lt;ul&gt;
      &lt;li&gt;왜 오픈소스를 개발했는가?&lt;/li&gt;
      &lt;li&gt;추천시스템을 보통 협업 필터링, 무비렌즈 데이터에 대해 주로 이야기함&lt;/li&gt;
      &lt;li&gt;사용자에게 콘텐츠 혹은 정보를 소비하는 경험을 제공하는 기술&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;카카오 추천시스템 토로스의 일부 기능
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/gc1zsea56fb34tc/2019-08-30%2012.04.06.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;개발 배경
    &lt;ul&gt;
      &lt;li&gt;2010년 초반에 오픈 소스 프로젝트가 거의 없었음&lt;/li&gt;
      &lt;li&gt;특히, 원하는 크기의 데이터를 적절한 시간에 효과적인 자원으로 분석할 수 있는 프로젝트가 없었음&lt;/li&gt;
      &lt;li&gt;초기엔 Matrix Factorization 모듈&lt;/li&gt;
      &lt;li&gt;쓰기 편하고 실용적이고 스케일러블, 만족스러운 품질의 결과를 줄 라이브러리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;6년정도 된 프로젝트인데 이제 공개한 것&lt;/li&gt;
  &lt;li&gt;버팔로 알고리즘
    &lt;ul&gt;
      &lt;li&gt;Alternating Least Square&lt;/li&gt;
      &lt;li&gt;Bayesian Personalized ranking matrxi factorization&lt;/li&gt;
      &lt;li&gt;Word2vec&lt;/li&gt;
      &lt;li&gt;CoFactors&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Matrix Factorization
    &lt;ul&gt;
      &lt;li&gt;행렬로 표현된 데이터를 더 작은 차원의 행렬로 분해하는 방법&lt;/li&gt;
      &lt;li&gt;장점
        &lt;ul&gt;
          &lt;li&gt;데이터의 압축&lt;/li&gt;
          &lt;li&gt;숨겨진 특성의 활용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4개의 MF 알고리즘을 제공하는데 왜 4개나 필요한가?
    &lt;ul&gt;
      &lt;li&gt;행렬 분해할 때 목적 함수의 정의, 데이터의 구성과 변형에 따라 서로 다른 성질의 은닉 벡터를 구할 수 있음&lt;/li&gt;
      &lt;li&gt;여러 행렬 분해 알고리즘을 사용해 다양한 특질을 확보할 수 있음&lt;/li&gt;
      &lt;li&gt;버팔로는 원하는 크기의 데이터를 적절한 시간에 효과적인 자원으로 수행할 수 있는 알고리즘 위주로 선택하며, 품질보다 확장성이 더 중요함&lt;/li&gt;
      &lt;li&gt;그러나 scalabiltiy &amp;gt; quality가 항상 성립하는 것은 아님. 대부분 문제는 Scalability는 타협 가능하지 않고 Quality는 타협 가능함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Scalability가 중요한 이유
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/n7bmjrf6jyhomwh/2019-08-30%2012.14.08.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;NNZ 20M : 0이 아닌 값이 이만큼 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;품질은 어디까지 타협해야 할까?
    &lt;ul&gt;
      &lt;li&gt;다양한 알고리즘을 실험한 결과 체감상 차이가 미미하고 시스템 성능에 미치는 영향도 차이가 크지 않음&lt;/li&gt;
      &lt;li&gt;초반엔 조금만해도 성능이 오르지만 점점 하다보면.. 시간대비 효율이 안나옴&lt;/li&gt;
      &lt;li&gt;투자 대비 효율로 전환
        &lt;ul&gt;
          &lt;li&gt;긴 파이프라인으로 구성된 시스템&lt;/li&gt;
          &lt;li&gt;Ceiling Analysis&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다른 알고리즘과 비교
 	- implicit, gmf, pyspark랑 비교
 	- 대비해서 빠름
 	- 자원을 효과적으로 쓰고 있는지도 테스트해봄 =&amp;gt; latent vector 크기 고정하고 cpu core 하나씩 늘리며 얼마나 빨라지는지 봄)
    &lt;ul&gt;
      &lt;li&gt;batch learning으로 잘라서 사용 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;높은 생산성
    &lt;ul&gt;
      &lt;li&gt;유사 콘텐츠 추천과 개인화 추천에 대한 병렬처리 기능 제공함&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from buffalo.algo.ali import ALS
  from buffalo.parallel.base import ParALS
  als = ALS.new('./ml20m.bin')
	
  als.most_similar('Starwars')
	
  #parallel
  par = ParALS(als)
  par.num_worker = 8
  par.most_similar(['Starwars', 'Startrek'])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;진행한 노력들
    &lt;ul&gt;
      &lt;li&gt;Python/C++ 코드 베이스와 병렬처리를 효과적으로 구현&lt;/li&gt;
      &lt;li&gt;쓰레드 작업할 때 job으로 쓰레드를 나누는데 job의 크기가 다 다름&lt;/li&gt;
      &lt;li&gt;병목이 누적되며 차이를 만듬&lt;/li&gt;
      &lt;li&gt;데이터 사이즈를 고려해 job을 배분하면 전체적 속도가 월등히 빨라짐&lt;/li&gt;
      &lt;li&gt;청크화된 데이터베이스를 사용해서, SSD에 내려둠
 	- 자세한 것은 Github repo&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;편의 기능
    &lt;ul&gt;
      &lt;li&gt;Validation
        &lt;ul&gt;
          &lt;li&gt;Stream 데이터에서 Matrix Market 데이터로 변환 가능&lt;/li&gt;
          &lt;li&gt;데이터 순서 기록을 고려해 최근 데이터만 추가하는 등&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Evaluation
        &lt;ul&gt;
          &lt;li&gt;어쩧게 할지 지정할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Tensorboard
        &lt;ul&gt;
          &lt;li&gt;텐서보드 옵션을 지정하면 버팔로가 넘김&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Hyper-parameter optimization
        &lt;ul&gt;
          &lt;li&gt;연구 목적 + 서비스 개발에도 중요한 부분&lt;/li&gt;
          &lt;li&gt;모든 머신러닝 알고리즘에서 하이퍼파라미터가 가장 중요하다고 해도 과언이 아닌데, 이런 기능을 내장하고 있음&lt;/li&gt;
          &lt;li&gt;hyperopt를 wrapping
            &lt;ul&gt;
              &lt;li&gt;min, max가 이슈가 있어서 조금 수정한 것은 있지만 거의 hyperopt와 유사&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;모델 deploy도 됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;요약
    &lt;ul&gt;
      &lt;li&gt;C++/Python&lt;/li&gt;
      &lt;li&gt;CPU 최적화, GPU 지원&lt;/li&gt;
      &lt;li&gt;효과적인 시스템 자원 활용&lt;/li&gt;
      &lt;li&gt;연구/개발 목적의 편의 기능 제공&lt;/li&gt;
      &lt;li&gt;벤치마크 표준화
        &lt;ul&gt;
          &lt;li&gt;예측, 유사도&lt;/li&gt;
          &lt;li&gt;맥락 고려&lt;/li&gt;
          &lt;li&gt;다양한 데이터&lt;/li&gt;
          &lt;li&gt;양질의 데이터 등&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;지속적인 오픈소스 활동
        &lt;ul&gt;
          &lt;li&gt;신규 작업: 실시간 추천 어플리케이션 서버&lt;/li&gt;
          &lt;li&gt;기존 성과물 개선 작업 : n2, buffalo&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;후기
    &lt;ul&gt;
      &lt;li&gt;추천할 때 한번 써봐야겠음&lt;/li&gt;
      &lt;li&gt;오픈소스에 기여하는 카카오 추천팀 멋짐..!&lt;/li&gt;
      &lt;li&gt;루카스님 리스펙&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tensorrt를-이용한-카카오-ocr-모델-inference-성능-최적화&quot;&gt;TensorRT를 이용한 카카오 OCR 모델 Inference 성능 최적화&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;이현수님&lt;/li&gt;
  &lt;li&gt;딥러닝 모델의 Trade off
    &lt;ul&gt;
      &lt;li&gt;연산량 증가하면 정확도 향상됨&lt;/li&gt;
      &lt;li&gt;정확도와 속도는 반비례&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Inference 성능 향상을 위한 방법들
    &lt;ul&gt;
      &lt;li&gt;네트워크 구조 개선
        &lt;ul&gt;
          &lt;li&gt;정확도도 좋고, 연산도 효율적인 모델 학습&lt;/li&gt;
          &lt;li&gt;MobileNet, EfficientNet, Parallel decoding&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;학습된 모델의 inference 과정 최적화
        &lt;ul&gt;
          &lt;li&gt;compression&lt;/li&gt;
          &lt;li&gt;quantization + a
            &lt;ul&gt;
              &lt;li&gt;TensorRT Framework 활용&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OCR Model 구조
    &lt;ul&gt;
      &lt;li&gt;Detection Model + Recognition Model로 구성&lt;/li&gt;
      &lt;li&gt;Text Detection Model
        &lt;ul&gt;
          &lt;li&gt;Convolution + Unpool layer, unet&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/eqh9w6nx1mkh3xa/2019-08-30%2014.03.42.jpg?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Text Recognition Model
        &lt;ul&gt;
          &lt;li&gt;CNN Feature Extraction + Self Attention(transformer)&lt;/li&gt;
          &lt;li&gt;Connextionist Temporal Classification&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/tnd58b8bq8dkglc/2019-08-30%2014.04.14.jpg?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TensorRT
    &lt;ul&gt;
      &lt;li&gt;딥러닝 inference 최적화를 위한 NVIDIA 플랫폼&lt;/li&gt;
      &lt;li&gt;학습된 모델을 TensorRT로 가져와 Inference할 엔진 생성&lt;/li&gt;
      &lt;li&gt;최적화 방법
        &lt;ul&gt;
          &lt;li&gt;Precision Quantization
            &lt;ul&gt;
              &lt;li&gt;35 bit floating point -&amp;gt; 16 bit / 8 bit&lt;/li&gt;
              &lt;li&gt;inference 효율성 증가
                &lt;ul&gt;
                  &lt;li&gt;데이터 전송 효율 증가&lt;/li&gt;
                  &lt;li&gt;GPU 가속을 통한 연산 속도 향상&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;infenrece 정확도 감소
                &lt;ul&gt;
                  &lt;li&gt;Quantization-aware Training&lt;/li&gt;
                  &lt;li&gt;Network Calibration(INT8)&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Layer &amp;amp; Tensor Fusion
            &lt;ul&gt;
              &lt;li&gt;공유된 메모리로 연산 =&amp;gt; 하나로 합침&lt;/li&gt;
              &lt;li&gt;Dependency가 없는 연산도 합쳐서 수행&lt;/li&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/q1gy7ak45ha095l/2019-08-30%2014.07.32.jpg?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Kernel Auto-Tuning
            &lt;ul&gt;
              &lt;li&gt;GPU 종류, 배치 사이즈, Tensor shape 등을 기반으로 가장 효율적인 GPU 커널 선택&lt;/li&gt;
              &lt;li&gt;직접 Operation 구현해서 최적화 가능&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TensorRT 사용 방법
    &lt;ul&gt;
      &lt;li&gt;학습된 모델 가져오기
        &lt;ul&gt;
          &lt;li&gt;Createing a network definition from scratch
            &lt;ul&gt;
              &lt;li&gt;weight 파일 매핑&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;importing a model
            &lt;ul&gt;
              &lt;li&gt;모델을 파싱, 파싱할 수 있는 형태로 네트워크 구조 수정해야 함&lt;/li&gt;
              &lt;li&gt;이 부분 위주로 설명&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TensorFlow 모델을 Import
    &lt;ul&gt;
      &lt;li&gt;TensorFlow GRaph -&amp;gt; UFF Network -&amp;gt; TensorRT Engine -&amp;gt; Engine을 이용한 Inference&lt;/li&gt;
      &lt;li&gt;TensorFlow Model을 inference하기
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/7i6jlvuggcyfsie/2019-08-30%2014.10.18.jpg?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;모델 parsing을 위해서 확인할 사항들
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/qw0bfupfsjkd2k5/2019-08-30%2014.10.47.jpg?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TensorFlow 모델 그래프 확인
    &lt;ul&gt;
      &lt;li&gt;TensorRT에서 사용할 수 있는지 확인&lt;/li&gt;
      &lt;li&gt;shape  연산의 파라미터를 상수로 고정&lt;/li&gt;
      &lt;li&gt;즉, 가변 길이 Input이 아니라 고정 크기의 input&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;연산의 format 및 shape 확인
    &lt;ul&gt;
      &lt;li&gt;channel first format 사용&lt;/li&gt;
      &lt;li&gt;Dense / Conv1D 사용 힘듬&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Plugin Layer를 이용한 연산 구현
    &lt;ul&gt;
      &lt;li&gt;TensorRT에서 사용 가능한 연산 구현해 대체&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;후기
    &lt;ul&gt;
      &lt;li&gt;중간에 잠시 일이 있어서 나갔다 왔지만, 발표의 흐름이나 정보 획득 관점에서 유익했음!&lt;/li&gt;
      &lt;li&gt;나중에 직접 사용할 때 발표 자료 보면 더 도움이 될 듯&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;비주얼-컴퓨팅을-활용한-카카오맵&quot;&gt;비주얼 컴퓨팅을 활용한 카카오맵&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;박영욱님&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/yl8ud9ezfpneiuu/2019-08-30%2015.08.54.jpg?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/n5y3osphmcjqrie/2019-08-30%2015.11.28.jpg?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/v2kyhzgkrhidx6y/2019-08-30%2015.12.46.jpg?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/nm65rj7482lb2f8/2019-08-30%2015.19.44.jpg?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ghy7minb4ed2et8/2019-08-30%2015.20.56.jpg?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/lomsggv5tnh6cqu/2019-08-30%2015.24.54.jpg?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/nzcp2gubzfu9192/2019-08-30%2015.27.37.jpg?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/bmdgdlm9nbykz4s/2019-08-30%2015.28.11.jpg?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/yd9tbj9a6if8fhp/2019-08-30%2015.34.34.jpg?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;후기
    &lt;ul&gt;
      &lt;li&gt;맥북 배터리 문제로 메모하진 못했지만, 친절한 목소리톤이라 듣기 좋았음&lt;/li&gt;
      &lt;li&gt;카카오맵에 이런 다양한 기술이 있구나! 싶었던 세션&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;카카오-대리-시공간-데이터를-이용한-강화학습-및-최적화&quot;&gt;카카오 대리 시공간 데이터를 이용한 강화학습 및 최적화&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;조창민님&lt;/li&gt;
  &lt;li&gt;어떻게 문제해결을 했는지 그 과정을 공유하려고 함&lt;/li&gt;
  &lt;li&gt;카카오모빌리티 AI 파트 소개
    &lt;ul&gt;
      &lt;li&gt;엔지니어링 스킬이 중요
        &lt;ul&gt;
          &lt;li&gt;실서비스, ML, 통계 등&lt;/li&gt;
          &lt;li&gt;실 서비스 장애 0건, 0.1초 미만 Latency&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;서비스 고도화는 곧 성과
        &lt;ul&gt;
          &lt;li&gt;매출 얼마나 높이고, 전환율을 높여달라&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;딥러닝은 하나의 방법이고 항상 최고의 방법은 아님&lt;/li&gt;
      &lt;li&gt;실제 서비스에 모델을 적용하고 불가능한 KPI를 달성하는게 목표. 모델링의 정확도 뿐만 아니라 안정적인 서비스가 목표&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;카카오 T 대리 서포터즈
    &lt;ul&gt;
      &lt;li&gt;카카오 T에서 대리 서비스&lt;/li&gt;
      &lt;li&gt;승객의 호출이 자동 배정 되는, 기사님을 위한 서비스&lt;/li&gt;
      &lt;li&gt;승객에겐 보다 빠른 연결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이동 요청
    &lt;ul&gt;
      &lt;li&gt;어느 위치에서 어디까지 가달라&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 서비스가 좋은 이유
    &lt;ul&gt;
      &lt;li&gt;초보기사분들에겐 판단이 어려움. 계속 콜을 봐야되고.. 집으로 가는 것도 고려해서 콜을 받아야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;해결해야 될 문제
    &lt;ul&gt;
      &lt;li&gt;어떻게 이동 추천을 하지?&lt;/li&gt;
      &lt;li&gt;대리 기사님당 콜 수행 n건 이상 수익은 얼마 이상!&lt;/li&gt;
      &lt;li&gt;집 방향으로 이동을 어떻게 해야하지?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;수요 예측 모델
    &lt;ul&gt;
      &lt;li&gt;대리 데이터 EDA
        &lt;ul&gt;
          &lt;li&gt;연도 상관없이 비슷하고, 월에 따라 분포 차이. 요일에 따라 콜 차이 심함, 시간의 영향도 받음&lt;/li&gt;
          &lt;li&gt;오늘 휴일인지 아닌지는 큰 차이가 없음&lt;/li&gt;
          &lt;li&gt;다음날이 휴일이냐에 따라 콜이 확 달라짐
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/2b3ixargdzlpt41/2019-08-30%2016.07.34.jpg?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;지역&lt;/li&gt;
          &lt;li&gt;Kmeans로 클러스터링&lt;/li&gt;
          &lt;li&gt;콜의 분포에 따라 지역을 나눔&lt;/li&gt;
          &lt;li&gt;Auto correlation을 보니 1시간 30분 이전까지 사용하면 예측률이 오르겠구나!를 얻음
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/8ne0tf8w8u75j6b/2019-08-30%2016.09.16.jpg?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;일단 다양한 모델 다 돌림
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/mr0w0c2rqmhhjs8/2019-08-30%2016.10.06.jpg?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;10분 단위 과거 콜 데이터로 예측&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;갑자기 서비스 담당자분이 다른 쪽으로 이동…&lt;/li&gt;
  &lt;li&gt;어쩌다보니 이걸 다 함&lt;/li&gt;
  &lt;li&gt;시뮬레이터 RL 환경 만들기
    &lt;ul&gt;
      &lt;li&gt;예측은 그냥 있는 데이터 쓰면 됨&lt;/li&gt;
      &lt;li&gt;하지만 누군가 어디로 이동시킬 때 더 잘나올까?는 예측할 수 없음&lt;/li&gt;
      &lt;li&gt;우리 지도를 싹 그리고 대리 시장 그리고..! 대리 기사님처럼 뿅! (타다에도 이렇게 진행하고 있음)&lt;/li&gt;
      &lt;li&gt;행정구역단위의 시뮬레이터
        &lt;ul&gt;
          &lt;li&gt;읍면동 같은 것.. 행정 구역으로 기사님 보내기엔 너무.. 작고 등등&lt;/li&gt;
          &lt;li&gt;택시 또는 지하철이 끊길땐?&lt;/li&gt;
          &lt;li&gt;바로 옆에 조금만 가면 되는데 굳이 강남으로?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Geohash 기반 시뮬레이터
        &lt;ul&gt;
          &lt;li&gt;사각형으로 자를 수 있음 =&amp;gt; 모두 일정함&lt;/li&gt;
          &lt;li&gt;대리 수요에 따라 서비스지역 한정&lt;/li&gt;
          &lt;li&gt;Geohash 기반 시뮬레이터 각 거리가 좌우는 같음, 대각선은 기존보다 더 이동함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;H3 기반 시뮬레이터
        &lt;ul&gt;
          &lt;li&gt;어느 방향으로 가나 길이가 동일함&lt;/li&gt;
          &lt;li&gt;현재 이거로 만드는 중&lt;/li&gt;
          &lt;li&gt;랜덤하게 대리 기사를 출근. 어느 위치에&lt;/li&gt;
          &lt;li&gt;이동을 시킴. 여기로 가세요!&lt;/li&gt;
          &lt;li&gt;반경 검색! (몽고DB 사용)&lt;/li&gt;
          &lt;li&gt;그 후 배정&lt;/li&gt;
          &lt;li&gt;승객에게 가면 자동차를 몰고 목적지로 이동&lt;/li&gt;
          &lt;li&gt;가상 환경에선 과거 30분 수요 데이터, 미래 30분안에 도착 예정 Agent&lt;/li&gt;
          &lt;li&gt;Agent의 현재 위치 등등을 모두 가지고 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;모델링보다 시뮬레이터가 100배 더 어려움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Monte Carlo Tree Search
    &lt;ul&gt;
      &lt;li&gt;대리가 콜 받고 도착해서 또 콜받고.. 핵심은 콜 받는거 아닌가?&lt;/li&gt;
      &lt;li&gt;강릉까지 가서 내리면 집에 어케오지..? 택시타면 마이너스&lt;/li&gt;
      &lt;li&gt;계속 이어지도록 하는게 중요함&lt;/li&gt;
      &lt;li&gt;Tree구조
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/pw4itkyqk7r3sdd/2019-08-30%2016.17.40.jpg?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Tic Tac Toe 게임 만들었는데 비겼으면 비겼지 절대 지지 않음&lt;/li&gt;
      &lt;li&gt;문제는 경우의 수가 많아지면 학습 속도가 너무 느려짐
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/foqr18jxhjlnwmf/2019-08-30%2016.19.38.jpg?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;실제 적용까지 너무 힘듬.. 차원이 너무 많음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Tabular Learning
    &lt;ul&gt;
      &lt;li&gt;State가 있고 Action 존재&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/e7fxjeighznm8ub/2019-08-30%2016.21.56.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;random이랑 비교함&lt;/li&gt;
      &lt;li&gt;Q Learning 결론 : H3 위치만 넣었는데 의외로 잘됨&lt;/li&gt;
      &lt;li&gt;단, 많은 기사님들이 들어올 떄 argmax를 취하기 떄문에 몰려버림&lt;/li&gt;
      &lt;li&gt;이걸 해결해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Reinforce Method
    &lt;ul&gt;
      &lt;li&gt;강화학습이 아닌 다른 알고리즘&lt;/li&gt;
      &lt;li&gt;softmax를 넣어 확률값으로 방향마다 나옴
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/oud6gm3g1zasg69/2019-08-30%2016.24.11.jpg?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Policy learning에서 q value의 구현에 따라 알고리즘이 바뀜&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/att0zjl5oncelhs/2019-08-30%2016.24.59.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/qlra0zcb3lsbhnp/2019-08-30%2016.25.12.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;10.59 gradient가 클수록 학습을 많이 해야함. 상황은 좋은데 왼쪽으로 갈 확률은 적음&lt;/li&gt;
      &lt;li&gt;인싸이트는 얻었지만 모델의 업데이타 너무 느림! 게임이 끝날 때까지 기다려야 함&lt;/li&gt;
      &lt;li&gt;그리고 Blackbox&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Reinforcement with convex optimization
    &lt;ul&gt;
      &lt;li&gt;문제점
        &lt;ul&gt;
          &lt;li&gt;서비스 초기엔 딥러닝이 애매함&lt;/li&gt;
          &lt;li&gt;서비스 중후반엔 딥러닝 쓰고 AB Test 가능함&lt;/li&gt;
          &lt;li&gt;딥러닝이 디버깅이 힘듬&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;서비스 초기엔 더 명확한 것을 가지고, 빠르게 튜닝 가능한 알고리즘이 필요함&lt;/li&gt;
      &lt;li&gt;현실은 알 수 없음. 기사님들의 행동은?&lt;/li&gt;
      &lt;li&gt;시급제라 기사님들이 존버함 (ㅋㅋㅋㅋㅋㅋ아..진짜 똑같네…)&lt;/li&gt;
      &lt;li&gt;RL에서 사용하는 Future Discounted Reward의 개념을 사용하고 싶지만 딥러닝은 사용하고 싶지 않음
        &lt;ul&gt;
          &lt;li&gt;리워드는 그대로 사용하되 방법만 변경&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Convex Optimization! 수리적 모델
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/wwt07myqwtumap4/2019-08-30%2016.30.53.jpg?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;컨벡스는 마주치는 부분이 없어야 함&lt;/li&gt;
      &lt;li&gt;직선이면 리니어 프로그래밍&lt;/li&gt;
      &lt;li&gt;Simplex Optimization
        &lt;ul&gt;
          &lt;li&gt;인접한 근단점들의 목적함수의 값들을 계속 검토하며 최적해 구하는 방법&lt;/li&gt;
          &lt;li&gt;그냥 단순하게 최적점으로 이동하며 optimize&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/5yo5ln8pj000rpy/2019-08-30%2016.31.48.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;목표는 q value, 하루 끝났을 때 최대 수익을 maximize. 그걸 convex optimization&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최종 공식
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/f517maeii8dnc6y/2019-08-30%2016.32.18.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;특정 지역의 콜 평균 - 해당 지역의 Agent 수 - 이동 거리 =&amp;gt; 기사님들의 하루 수입을 최대화&lt;/li&gt;
      &lt;li&gt;beta들을 다 곱하고 beta를 최적화&lt;/li&gt;
      &lt;li&gt;콜이 나오는 지역으로 유도하고 다른 기사님들과 겹치지 않도록 최적화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시뮬레이션 결과
    &lt;ul&gt;
      &lt;li&gt;2배 이상, 실제로도 늘었다고 함&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/7u1zi8z5to05qps/2019-08-30%2016.33.32.jpg?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;N-Step A3C
    &lt;ul&gt;
      &lt;li&gt;앞으로 방향은?&lt;/li&gt;
      &lt;li&gt;N-Step
        &lt;ul&gt;
          &lt;li&gt;바로 앞단의 이익이 어떻게 되는가?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Temporal Difference&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/os1fhdliqyygsu8/2019-08-30%2016.34.35.jpg?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;n번째까지 진행&lt;/li&gt;
      &lt;li&gt;이 알고리즘으로 슈퍼마리오 구현&lt;/li&gt;
      &lt;li&gt;N-step 64로, 64 프레임 이후에 떨어져 죽느냐? 등등에 따라 값이 변함&lt;/li&gt;
      &lt;li&gt;이제 A3C, Curiosity 등을 적용할 예정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;질문
    &lt;ul&gt;
      &lt;li&gt;시뮬레이터 생성시 노드 단위까지 가는걸 했는지, geohash간 이동 거리 등으로 했는지 =&amp;gt; geohash간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;후기
    &lt;ul&gt;
      &lt;li&gt;제일 만족스러웠고, 재미있었던 세션&lt;/li&gt;
      &lt;li&gt;제가 회사에서 진행하고 있는 업무들이랑 너무 비슷하고, 문제 푸는 방식도 유사해서 잘 하고 있구나 생각했음. 따로 여쭤보니 시뮬레이터 만들대 SimPy 쓰셨다고 하셔서 동질감도.. (여기도 시급제라 이슈가..) 명함 주고받았는데 나중에 대화 한번 해봐도 좋을 것 같음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 30 Aug 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/etc/2019/08/30/ifkakao-2019-review/</link>
        <guid isPermaLink="true">http://localhost:4000/etc/2019/08/30/ifkakao-2019-review/</guid>
        
        <category>lecture</category>
        
        
        <category>etc</category>
        
      </item>
    
      <item>
        <title>최적화로 바라본 Knapsack Problem</title>
        <description>&lt;ul&gt;
  &lt;li&gt;최적화(Optimization) 관점에서 본 Knapsack 문제를 정리한 글입니다
    &lt;ul&gt;
      &lt;li&gt;Cousera Discrete Optimization 2주차 강의 내용입니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;greedy-algorithms&quot;&gt;Greedy Algorithms&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;가장 귀중한 아이템을 먼저 가져가고 다음 배낭에 들어갈 수 있는 다음 것을 가져가는 방식&lt;/li&gt;
  &lt;li&gt;Idea : Take the most valuable items first&lt;/li&gt;
  &lt;li&gt;다른 Greedy 알고리즘과 비교
    &lt;ul&gt;
      &lt;li&gt;디자인하는 방식에 따라 매우 복잡할 수 있고, 품질이 달라질 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실현 가능한(feasible) 솔루션을 쉽게 구축할 수 있다고 가정&lt;/li&gt;
  &lt;li&gt;한번에 하나의 항목을 선택&lt;/li&gt;
  &lt;li&gt;여기서 Greedy의 의미를 다르게 할 수 있음
    &lt;ul&gt;
      &lt;li&gt;1) 무게에 기반해, 작은 물건부터 가져감&lt;/li&gt;
      &lt;li&gt;2) 가치가 있는 것부터 가져감&lt;/li&gt;
      &lt;li&gt;3) 가치의 밀도를 측정. dollars per kilogram&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하나의 문제에 다양한 greedy 알고리즘이 존재할 수 있음
    &lt;ul&gt;
      &lt;li&gt;어떤 것이 다른 것보다 나을 수 있음&lt;/li&gt;
      &lt;li&gt;input에 의존적&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;빠르게 구현 가능&lt;/li&gt;
      &lt;li&gt;매우 빠를 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;보통 퀄리티를 보장할 수 없음&lt;/li&gt;
      &lt;li&gt;퀄리티가 input에 따라 크게 다를 수 있음&lt;/li&gt;
      &lt;li&gt;문제의 feasibility는 쉬워야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;항상 greedy로 시작할 수 있음&lt;/li&gt;
  &lt;li&gt;그 후
    &lt;ul&gt;
      &lt;li&gt;Constraint Programming&lt;/li&gt;
      &lt;li&gt;Local Search&lt;/li&gt;
      &lt;li&gt;mixed Integer Programming&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;방법
    &lt;ul&gt;
      &lt;li&gt;feasible solution을 확실하게 찾기&lt;/li&gt;
      &lt;li&gt;high quality 솔루션을 확실하게 만들기
        &lt;ul&gt;
          &lt;li&gt;다른 input에 로버스트한(이상치에 영향을 덜 받는) 솔루션&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;이상적으로 해당 솔루션이 최고임을 입증&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;knapsack-modeling&quot;&gt;Knapsack Modeling&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Knapsack 문제를 수학적 모델로 공식화하는 방법&lt;/li&gt;
  &lt;li&gt;item 조합 I이 있을 때
    &lt;ul&gt;
      &lt;li&gt;weight &lt;code class=&quot;MathJax_Preview&quot;&gt;w_{i}&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;w_{i}&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;value &lt;code class=&quot;MathJax_Preview&quot;&gt;v_{i}&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;v_{i}&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;capacity K for a Knapsack&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 조건을 만족하는 부분 집합 찾기
    &lt;ul&gt;
      &lt;li&gt;maximum value를 갖는&lt;/li&gt;
      &lt;li&gt;그러나 Knapsack의 capacity를 초과하지 않아야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모델링하는 방법
    &lt;ul&gt;
      &lt;li&gt;Decision Variable(결정 변수) 선택
        &lt;ul&gt;
          &lt;li&gt;의사 결정의 대상&lt;/li&gt;
          &lt;li&gt;목적함수 식이나 제약조건 식에서 미지수로 나타나는 변수&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;이 변수들의 constraint(제약 조건)을 표현
        &lt;ul&gt;
          &lt;li&gt;문제에 구체적으로 정의되어 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Objective function(목적 함수)을 표현
        &lt;ul&gt;
          &lt;li&gt;각 해답의 퀄리티가 결정됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Optimization model의 결과
    &lt;ul&gt;
      &lt;li&gt;declarative formulation
        &lt;ul&gt;
          &lt;li&gt;how가 아니라 what을 명시&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;최적화엔 많은 모델링 방법이 가능함(오픈 마인드!)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Decision Variables
    &lt;ul&gt;
      &lt;li&gt;
        &lt;pre class=&quot;MathJax_Preview&quot;&gt;&lt;code&gt;x_{i}&lt;/code&gt;&lt;/pre&gt;
        &lt;script type=&quot;math/tex; mode=display&quot;&gt;x_{i}&lt;/script&gt;
        &lt;ul&gt;
          &lt;li&gt;item i가 선택되었는지 아닌지(1이 선택, 0은 미선택)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Problem constraint
    &lt;ul&gt;
      &lt;li&gt;선택된 item은 knapsack의 capacity를 초과할 수 없음&lt;/li&gt;
      &lt;li&gt;
        &lt;pre class=&quot;MathJax_Preview&quot;&gt;&lt;code&gt;\sum_{i\in I}w_{i}x_{i} \le K&lt;/code&gt;&lt;/pre&gt;
        &lt;script type=&quot;math/tex; mode=display&quot;&gt;\sum_{i\in I}w_{i}x_{i} \le K&lt;/script&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Objective function
    &lt;ul&gt;
      &lt;li&gt;선택된 것들의 total value 추적&lt;/li&gt;
      &lt;li&gt;
        &lt;pre class=&quot;MathJax_Preview&quot;&gt;&lt;code&gt;\sum_{i\in I}v_{i}x_{i}&lt;/code&gt;&lt;/pre&gt;
        &lt;script type=&quot;math/tex; mode=display&quot;&gt;\sum_{i\in I}v_{i}x_{i}&lt;/script&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/qosgz63v0lxceh4/Screenshot%202019-08-19%2001.21.41.png?raw=1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Exponential Growth
    &lt;ul&gt;
      &lt;li&gt;가능한 솔루션이 얼마나 있는지?&lt;/li&gt;
      &lt;li&gt;Search space(Solution space)&lt;/li&gt;
      &lt;li&gt;모든 것이 feasible하진 않음(실현가능하진 않음)
        &lt;ul&gt;
          &lt;li&gt;Knapsack의 capacity를 초과할 수 없음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;How many are they? 2^∣I∣&lt;/li&gt;
      &lt;li&gt;탐색하는데 드는 시간은?
        &lt;ul&gt;
          &lt;li&gt;∣I∣=50일 때 1,285,273,866 centuries&lt;/li&gt;
          &lt;li&gt;너무 오래걸림&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dynamic-programming&quot;&gt;Dynamic Programming&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;어떻게 최고의 Knapsack 솔루션을 찾을 수 있을까
    &lt;ul&gt;
      &lt;li&gt;다이나믹 프로그래밍을 이용해서!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최적화 테크닉으로 많이 사용됨
    &lt;ul&gt;
      &lt;li&gt;다양한 종류의 문제에서 잘 작동하며 특히 생물학에 계산에서 잘 작동&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 원칙
    &lt;ul&gt;
      &lt;li&gt;분할하고 정복한다&lt;/li&gt;
      &lt;li&gt;bottom부터 계산한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Convetions and notations
    &lt;ul&gt;
      &lt;li&gt;I = {1,2,…n}&lt;/li&gt;
      &lt;li&gt;O(k,j)는 capacity k and items [1..j]의 optimal solution을 뜻함&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/tquerxj2ej277kf/Screenshot%202019-08-19%2013.07.24.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Recurrence Relations (Bellman 방정식)
    &lt;ul&gt;
      &lt;li&gt;우리가 해결하는 방법을 안다고 가정&lt;/li&gt;
      &lt;li&gt;O(k,j)를 풀고 싶음&lt;/li&gt;
      &lt;li&gt;만약 &lt;code class=&quot;MathJax_Preview&quot;&gt;w_{j} \le k&lt;/code&gt;&lt;script type=&quot;math/tex&quot;&gt;w_{j} \le k&lt;/script&gt;일 때, 2가지 케이스가 있음
        &lt;ul&gt;
          &lt;li&gt;j를 선택하지 않으면 O(k, j-1)가 best solution&lt;/li&gt;
          &lt;li&gt;j를 선택하면 best solution은 v_{j} + O(k-w_{j}, j-1)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;summary
        &lt;ul&gt;
          &lt;li&gt;O(k,j) = max(O(k, j-1), v_{j} + O(k-w_{j}, j-1)) if w_{j} &amp;lt;= k&lt;/li&gt;
          &lt;li&gt;O(k,j) = O(k,j-1) otherwise&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;당연히 O(k,0) = O for all k&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Simple program
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/is0cebi2s3m17w1/Screenshot%202019-08-19%2022.58.26.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;recursive&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;피보나치 수를 찾기 위해 간단한 프로그램을 짤 수 있음
    &lt;ul&gt;
      &lt;li&gt;fib(n-1)은 fib(n-2)가 이미 풀려있어야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Dynamic Programming
    &lt;ul&gt;
      &lt;li&gt;recursive 식으로 bottom up으로 연산함
        &lt;ul&gt;
          &lt;li&gt;start with zero items&lt;/li&gt;
          &lt;li&gt;continue with one item&lt;/li&gt;
          &lt;li&gt;then two tiems&lt;/li&gt;
          &lt;li&gt;then all items&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/dba17ggqbq4orzn/Screenshot%202019-08-19%2023.13.56.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 알고리즈의 복잡도
    &lt;ul&gt;
      &lt;li&gt;테이블을 모두 채워야 함 O(K n)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;polynomial?
    &lt;ul&gt;
      &lt;li&gt;how many bits does K need to be represented on a computer?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;relaxation-branch-and-bound&quot;&gt;Relaxation, branch and bound&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Introduce branch and bound&lt;/li&gt;
  &lt;li&gt;The value of relaxation&lt;/li&gt;
  &lt;li&gt;Exhausitive Search(완전 탐색)
    &lt;ul&gt;
      &lt;li&gt;가능한 방법을 전부 만들어보는 알고리즘&lt;/li&gt;
      &lt;li&gt;Brute Force Search라고도 함&lt;/li&gt;
      &lt;li&gt;총 몇가지 나오는지 파악 =&amp;gt; 너무 많으면 탐색 시간이 부족&lt;/li&gt;
      &lt;li&gt;경우의 세를 세어보고 완전 탐색해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Branch and Bound(분기 한정법)
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://www.aistudy.com/heuristic/branch_and_bound.htm&quot;&gt;참고 자료&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;Iterative two steps
        &lt;ul&gt;
          &lt;li&gt;branching
            &lt;ul&gt;
              &lt;li&gt;문제를 여러 하위 문제로 쪼갬&lt;/li&gt;
              &lt;li&gt;여러개의 작은 feasible subregion로 구성하고 그 과정이 subregion 각각에 대해 재귀 반복을 거쳐 tree 구조를 형성&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;bounding
            &lt;ul&gt;
              &lt;li&gt;하위 문제의 best solution을 찾고 optimistic estimate함&lt;/li&gt;
              &lt;li&gt;feasible subregion 내에서 최적해를 찾기 위해 upper and low bound를 빠르게 찾는 방법&lt;/li&gt;
              &lt;li&gt;maximization : upper bound&lt;/li&gt;
              &lt;li&gt;minimization : lower bound&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Relaxation
        &lt;ul&gt;
          &lt;li&gt;optimistic estimate를 찾는 방법&lt;/li&gt;
          &lt;li&gt;Optimization is the art of relaxation&lt;/li&gt;
          &lt;li&gt;capacity constraint를 relax할 수 있음&lt;/li&gt;
          &lt;li&gt;어려운 문제를 해결하기 쉬운 문제로 근사한 것&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_programming_relaxation&quot;&gt;Wikipedia : Linear programming relaxation&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Depth-First branch and Bound
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/gcb3dotbndzuudq/Screenshot%202019-08-20%2023.18.58.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;왼쪽 테이블에서 하나씩 선택하고 안하고를 분기해서 답을 찾아감&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;A Knapsack Model
    &lt;ul&gt;
      &lt;li&gt;초콜렛을 조각낼 수 있음&lt;/li&gt;
      &lt;li&gt;특정 결정 변수의 fractional value를 취할 수 있음&lt;/li&gt;
      &lt;li&gt;Linear relaxation
        &lt;ul&gt;
          &lt;li&gt;나중 수업에서 배울 예정&lt;/li&gt;
          &lt;li&gt;Integrality 요구 조건을 완화함&lt;/li&gt;
          &lt;li&gt;모든 value를 정수(integer number)로 바꾸고 그것들의 분수로 이완&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;푸는 방법
        &lt;ul&gt;
          &lt;li&gt;용량이 소진되지 않은 상태에서 아이템 선택&lt;/li&gt;
          &lt;li&gt;마지막 아이템의 분수 선택&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/0vburwxjrpggbvi/Screenshot%202019-08-20%2023.44.21.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/2zrwvwf79371auw/Screenshot%202019-08-20%2023.46.20.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;linear relaxation이 문제의 해답은 아님&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/k6avcle36xfqc4y/Screenshot%202019-08-21%2000.07.25.png?raw=1&quot; /&gt;
    &lt;ul&gt;
      &lt;li&gt;relaxation으로 9 / 6 / 11.7&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;search-strategies&quot;&gt;Search Strategies&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Branch and bound를 위한 탐색 전략&lt;/li&gt;
  &lt;li&gt;Search Strategies
    &lt;ul&gt;
      &lt;li&gt;트리를 탐색하기 위한 다양한 전략&lt;/li&gt;
      &lt;li&gt;Depth-first, best-first, least-discrepancy&lt;/li&gt;
      &lt;li&gt;many others&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Depth-first
    &lt;ul&gt;
      &lt;li&gt;노드 추정이 best found solution보다 나쁠때 처리&lt;/li&gt;
      &lt;li&gt;Go deep&lt;/li&gt;
      &lt;li&gt;when does is prune?
        &lt;ul&gt;
          &lt;li&gt;여태 찾은 best solution보다 나쁠 경우&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;is it memory efficient?
        &lt;ul&gt;
          &lt;li&gt;exaggerate(과장됨)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Best-First
    &lt;ul&gt;
      &lt;li&gt;best 추정일 때 node를 선택&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/zbqusjvq1exkl29/Screenshot%202019-08-21%2013.27.43.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;go for the best&lt;/li&gt;
      &lt;li&gt;when does is prune?
        &lt;ul&gt;
          &lt;li&gt;여태 찾은 solution보다 모든 노드들이 나쁠 경우&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;is it memory efficient?
        &lt;ul&gt;
          &lt;li&gt;exaggerate(과장됨)&lt;/li&gt;
          &lt;li&gt;모든 Tree를 탐색 =&amp;gt; eponential time, space&lt;/li&gt;
          &lt;li&gt;worst 사례&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Least-Discrepancy
    &lt;ul&gt;
      &lt;li&gt;Greedy heuristic을 신뢰&lt;/li&gt;
      &lt;li&gt;Good heuristic을 추정하면
        &lt;ul&gt;
          &lt;li&gt;실수가 적은&lt;/li&gt;
          &lt;li&gt;search tree가 binary&lt;/li&gt;
          &lt;li&gt;휴리스틱할 경우 branching이 왼쪽으로 분기&lt;/li&gt;
          &lt;li&gt;휴리스틱이 잘못되면 branching이 오른쪽으로 분기&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Limited Discrepancy Search(LDS)
        &lt;ul&gt;
          &lt;li&gt;실수를 줄인다&lt;/li&gt;
          &lt;li&gt;실수로 증가하는 search space 탐색&lt;/li&gt;
          &lt;li&gt;휴리스틱을 더 신뢰&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Explores the search space in waves
        &lt;ul&gt;
          &lt;li&gt;no mistake&lt;/li&gt;
          &lt;li&gt;one mistake&lt;/li&gt;
          &lt;li&gt;two mistakes..&lt;/li&gt;
          &lt;li&gt;이럴 때마다 search space가 줄어듬&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/5sf95hximtarho9/Screenshot%202019-08-21%2013.39.01.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/hnmnus3pjra3rgg/Screenshot%202019-08-21%2013.40.57.png?raw=1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;trust the greedy heuristics&lt;/li&gt;
      &lt;li&gt;when does it prune?
        &lt;ul&gt;
          &lt;li&gt;best-first와 동일&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;is it memory efficient?
        &lt;ul&gt;
          &lt;li&gt;depth-first와 best-first 대비&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Relaxation and Search
    &lt;ul&gt;
      &lt;li&gt;Discrete optimization heaven이 만든 match&lt;/li&gt;
      &lt;li&gt;relaxation을 어떻게 하냐에 따라 속도가 개선될지 결정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;assignments-getting-started&quot;&gt;Assignments Getting started&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/hy4mc5mv537ev0x/Screenshot%202019-08-21%2019.43.18.png?raw=1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;최적화에 silver bullet은 없음
    &lt;ul&gt;
      &lt;li&gt;다양하게 접근&lt;/li&gt;
      &lt;li&gt;High quality : 10*4+3*2=46&lt;/li&gt;
      &lt;li&gt;Scalable, lower quality solution 7*6=42&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Coursera &lt;a href=&quot;https://www.coursera.org/learn/discrete-optimization&quot;&gt;Discrete Optimization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 21 Aug 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/2019/08/21/knapsack_problem/</link>
        <guid isPermaLink="true">http://localhost:4000/data/2019/08/21/knapsack_problem/</guid>
        
        <category>optimization</category>
        
        
        <category>data</category>
        
      </item>
    
      <item>
        <title>파이콘(PyCon) 2019 세션 정리</title>
        <description>&lt;ul&gt;
  &lt;li&gt;파이콘 2019에서 세션을 들으며 메모한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;파이썬과-커뮤니티와-한국어-오픈데이터&quot;&gt;파이썬과 커뮤니티와 한국어 오픈데이터&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;박은정님 키노트&lt;/li&gt;
  &lt;li&gt;프로그래밍은 왜 하는가?&lt;/li&gt;
  &lt;li&gt;취미&lt;/li&gt;
  &lt;li&gt;먹고사니즘&lt;/li&gt;
  &lt;li&gt;개인의 성장&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;나의 커뮤니티에 기여하기 위해&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;팀포퐁
    &lt;ul&gt;
      &lt;li&gt;2011년&lt;/li&gt;
      &lt;li&gt;문제 의식 : 누구를 뽑을 것인가?&lt;/li&gt;
      &lt;li&gt;발견한 문제점
        &lt;ul&gt;
          &lt;li&gt;1) 객관적 자료 부족&lt;/li&gt;
          &lt;li&gt;2) 뽑은 국회의원을 잊고 지냄&lt;/li&gt;
          &lt;li&gt;국회정보 시스템에 정보는 다 있지만.. 어렵고 재미없음&lt;/li&gt;
          &lt;li&gt;어떤 일을 하는지, 누가 누군지 모르겠고.. 접근성 떨어지는 문서&lt;/li&gt;
          &lt;li&gt;검색 엔진이 접근할 수 없는 정책&lt;/li&gt;
          &lt;li&gt;국민 모두가 접근할 수 있어야 하지 않을까?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;팀포퐁은 정치적 중립성, 자동화, 개방성의 가치를 가지고 결정이 됨
        &lt;ul&gt;
          &lt;li&gt;기술로 대한민국 정치를 뒤흔들자&lt;/li&gt;
          &lt;li&gt;직접 서비스를 만들며 성장하자&lt;/li&gt;
          &lt;li&gt;프로토타입, 의원 네트워크 분석 등&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;대한민국 정치의 모든 것이란 웹서비스가 생김
        &lt;ul&gt;
          &lt;li&gt;타임라인을 위해 D3&lt;/li&gt;
          &lt;li&gt;NLP&lt;/li&gt;
          &lt;li&gt;PDF parsing&lt;/li&gt;
          &lt;li&gt;선거구 시각화를 위해 지도 데이터도 만듬
            &lt;ul&gt;
              &lt;li&gt;메르카토르 같은 투영법도 배움&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;국회의원/의안 데이터 REST API =&amp;gt; 데이터를 퍼블릭에 공개&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;좋은 개발 문화
        &lt;ul&gt;
          &lt;li&gt;문서화 : 팀 내외와 소통하는 방ㅇ법&lt;/li&gt;
          &lt;li&gt;Git의 좋은 프랙티스 : 매너있게 소통&lt;/li&gt;
          &lt;li&gt;새 프로젝트에 새 도구 도입&lt;/li&gt;
          &lt;li&gt;탁상공론을 벗어나 working prototype으로 보여주기&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;느낀점
        &lt;ul&gt;
          &lt;li&gt;나와 내 주변을 바꿈 =&amp;gt; 결국 세상을 바꾸게 되지 않을까&lt;/li&gt;
          &lt;li&gt;시간이 좀 걸려도 괜찮다. 모르는 건 배우면 된다&lt;/li&gt;
          &lt;li&gt;데이터를 가공해 오픈 데이터로 내놓는 것도 의미가 있다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;KoNLPy
    &lt;ul&gt;
      &lt;li&gt;한국어 분석을 편리하게 하기 위해 시작&lt;/li&gt;
      &lt;li&gt;오픈 소스는 있나? 성능은 어떻게 다르지?&lt;/li&gt;
      &lt;li&gt;처음부터 커뮤니티 기여하겠단 생각은 아니었음&lt;/li&gt;
      &lt;li&gt;파이콘이 한국에서 처음 열린대! =&amp;gt; 잘 패키징해서 공개!&lt;/li&gt;
      &lt;li&gt;사람들은 왜 KoNLPy를 사용했을까?
        &lt;ul&gt;
          &lt;li&gt;초보자 : 사용법이 쉬워서?&lt;/li&gt;
          &lt;li&gt;학생 : 보고 따라할 예시가 있어서?&lt;/li&gt;
          &lt;li&gt;실무자 : 다양한 구현체 간 성능 비교가 편해서?&lt;/li&gt;
          &lt;li&gt;외국인 : 문서가 영어로 쓰여 있어서?&lt;/li&gt;
          &lt;li&gt;환경적 요인 : 이 당시 파이썬이 한창 인기몰이&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;내가 필요한 도구는 내가 만들어 공유한다
        &lt;ul&gt;
          &lt;li&gt;생각지도 못한 도움을 주고 받을 수 있고, 가치있는 일이다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;두번째 PyCon KR
        &lt;ul&gt;
          &lt;li&gt;representation learning이 굉장히 핫해짐&lt;/li&gt;
          &lt;li&gt;word2vec, doc2vec을 파이썬 커뮤니티에 소개해볼까?&lt;/li&gt;
          &lt;li&gt;KoNLPy를 공개했지만 토이데이터가 별로 없다
            &lt;ul&gt;
              &lt;li&gt;nsmc라는 한국어 영화평 데이터&lt;/li&gt;
              &lt;li&gt;주어진 영화평을 긍정 또는 부정으로 분류하는 데이터셋&lt;/li&gt;
              &lt;li&gt;IMDB 데이터를 벤치마크&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;내가 가진 기술이 대단하지 않아도 커뮤니티에 기여할 수 있다!&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;한국어 오픈 데이터
    &lt;ul&gt;
      &lt;li&gt;꼭 하고 싶었던 이야기
        &lt;ul&gt;
          &lt;li&gt;알파벳은 영어가 아니다&lt;/li&gt;
          &lt;li&gt;한글은 한국어가 아니다!&lt;/li&gt;
          &lt;li&gt;한글은 문자, 한국어가 언어&lt;/li&gt;
          &lt;li&gt;한국어 NLP, Korean NLP&lt;/li&gt;
          &lt;li&gt;용어 정의를 명확히&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;한국어 오픈데이터
        &lt;ul&gt;
          &lt;li&gt;생각보다 굉장히 많음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;좋은 사례 1: KorQUAD
        &lt;ul&gt;
          &lt;li&gt;QnA 데이터셋&lt;/li&gt;
          &lt;li&gt;충분한 양의 데이터 공개&lt;/li&gt;
          &lt;li&gt;리더보드까지 공유&lt;/li&gt;
          &lt;li&gt;라이센스 부분은 공유되지 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;좋은 사례 2: KSS
        &lt;ul&gt;
          &lt;li&gt;Single Speark Speech Dataset&lt;/li&gt;
          &lt;li&gt;박규병님&lt;/li&gt;
          &lt;li&gt;국내 최초의 음성 오픈 데이터&lt;/li&gt;
          &lt;li&gt;제법 많은 분량&lt;/li&gt;
          &lt;li&gt;라이센스가 뚜렷하게 명시되어 있어서 무엇을 할 수 있고 없는지가 명확함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;왜 오픈 데이터가 중요한가요?
        &lt;ul&gt;
          &lt;li&gt;1) 벤치마크가 될 수 있음
            &lt;ul&gt;
              &lt;li&gt;머신러닝 모델들은 데이터와 지표가 같아야 모델간 서로 비교 가능&lt;/li&gt;
              &lt;li&gt;비교가 가능해지면 기술 발전이 옴&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;2) 누구나 바로 분석이나 모델링을 시작할 수 있음
            &lt;ul&gt;
              &lt;li&gt;프로그래밍에서 reinventing the wheel이 경계의 대상이 되듯 모두가 데이터 취득과 정제를 할 필요는 없음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;데이터를 공개할 때 확인하면 좋은 점
        &lt;ul&gt;
          &lt;li&gt;사용자가 바로 다운로드해서 사용할 수 있는가?&lt;/li&gt;
          &lt;li&gt;원문에 갱인정보/저작권 문제는 없는가?
            &lt;ul&gt;
              &lt;li&gt;오픈데이터는 기술 발전을 위해 매우 중요하지만 개인정보와 저작권도 존중받고 지켜져야 함&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;가급적이면 라이센스를 꼭 명시&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;오픈 데이터를 사용할 때 확인하면 좋은 점
        &lt;ul&gt;
          &lt;li&gt;데이터가 충분히 큰가?&lt;/li&gt;
          &lt;li&gt;라이센스가 무엇인가?
            &lt;ul&gt;
              &lt;li&gt;재배포가 가능한가?&lt;/li&gt;
              &lt;li&gt;상업용으로 이용해도 되는가?&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;한국어 같이! 공유 :)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;파이썬으로-구현하는-최적화-알고리즘&quot;&gt;파이썬으로 구현하는 최적화 알고리즘&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;차지원님&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/JiwonCha3/pyconkr-2019-164422872&quot;&gt;발표 자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ryuncha/python_lpqp_optimization_tutorial&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;에너지 스타트업 개발자로 취업하며 적응할 때 어려움이 있었음&lt;/li&gt;
  &lt;li&gt;백그라운드
    &lt;ul&gt;
      &lt;li&gt;넓고 넓은 최적화의 세계
        &lt;ul&gt;
          &lt;li&gt;수학적 계획법/최적화 기법&lt;/li&gt;
          &lt;li&gt;최신/비전통 최적화 기법&lt;/li&gt;
          &lt;li&gt;확률론적 과정 기법&lt;/li&gt;
          &lt;li&gt;통계적 방법&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최적화 문제 구성
    &lt;ul&gt;
      &lt;li&gt;목적 함수&lt;/li&gt;
      &lt;li&gt;제약 함수&lt;/li&gt;
      &lt;li&gt;변수&lt;/li&gt;
      &lt;li&gt;계수&lt;/li&gt;
      &lt;li&gt;상수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;변수, 목적 함수, 제약조건에 따라 문제 유형이 다름&lt;/li&gt;
  &lt;li&gt;최적화 유형의 난이도 랭킹
    &lt;ul&gt;
      &lt;li&gt;LP : 선형 계획법
        &lt;ul&gt;
          &lt;li&gt;목적함수, 제약함수가 모두 1차식이고 결정변수가 모두 실수&lt;/li&gt;
          &lt;li&gt;현실 문제는 비선형&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;NLP : 비선형 계획법
        &lt;ul&gt;
          &lt;li&gt;목적함수, 제약함수 중 비선형 표현. n차&lt;/li&gt;
          &lt;li&gt;이건 오픈소스가 거의 없음&lt;/li&gt;
          &lt;li&gt;오래 걸림&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모델링 라이브러리
    &lt;ul&gt;
      &lt;li&gt;유저 - 솔버의 통역사&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;솔버
    &lt;ul&gt;
      &lt;li&gt;연산 엔진&lt;/li&gt;
      &lt;li&gt;솔버 성능에 따라 최적 결과값이 다름&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기술적 해결법으로 문제 유형을 변겅하는게 좋음&lt;/li&gt;
  &lt;li&gt;모델링 라이브러리의 역할
    &lt;ul&gt;
      &lt;li&gt;상황에 맞는 솔버 선택 가능&lt;/li&gt;
      &lt;li&gt;쿼드라틱을 잘 푸는 솔버는 이거 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모델링 구현 방법
    &lt;ul&gt;
      &lt;li&gt;Matrix form (CVXOPT, lv_solve, scipy.solve)
        &lt;ul&gt;
          &lt;li&gt;계수를 뽑아서 c로, x로&lt;/li&gt;
          &lt;li&gt;쿼드라틱은 더 복잡해짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Symbolic form
        &lt;ul&gt;
          &lt;li&gt;PuLP&lt;/li&gt;
          &lt;li&gt;좀 더 직관적으로 표현&lt;/li&gt;
          &lt;li&gt;에러가 나면 어떤 제약식에서 나왔는지 말해줌&lt;/li&gt;
          &lt;li&gt;하지만 대부분 오픈소스 라이브러리가 LP만 지원.. symbolic은 거의 없음&lt;/li&gt;
          &lt;li&gt;cvxpy&lt;/li&gt;
          &lt;li&gt;수식 표현방법이 다름&lt;/li&gt;
          &lt;li&gt;정리된 목적함수가 작으면 심볼릭, 크면 매트릭스&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Matrix
    &lt;ul&gt;
      &lt;li&gt;효율적 메모리 관리&lt;/li&gt;
      &lt;li&gt;다양한 개발환경&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Symbolic
    &lt;ul&gt;
      &lt;li&gt;유지보수의 편리성&lt;/li&gt;
      &lt;li&gt;낮은 개발 난이도&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상황 1) 상업용 솔버를 사용하면
    &lt;ul&gt;
      &lt;li&gt;해당 인터페이스 자체 모델링 라이브러리 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상황 2) 오픈소스
    &lt;ul&gt;
      &lt;li&gt;잘 모르겠다면 CVXPY 추천&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;솔버 선택 팁
    &lt;ul&gt;
      &lt;li&gt;사용 용도에 따른 SW 라이센스 문제&lt;/li&gt;
      &lt;li&gt;성능, 연산 신뢰성 문제&lt;/li&gt;
      &lt;li&gt;내 최적화 문제 유형을 지원하는지 : LP, MILP, QP, NLP 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SW 라이센스 종류
    &lt;ul&gt;
      &lt;li&gt;GNU GPL
        &lt;ul&gt;
          &lt;li&gt;사용하면 코드 공개해야함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;GNU LGPL
        &lt;ul&gt;
          &lt;li&gt;소스코드 공개 안해도 됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실사용 리뷰
    &lt;ul&gt;
      &lt;li&gt;GLPK : GNU라 기업에서 쓰기엔 좀..&lt;/li&gt;
      &lt;li&gt;CLP/CBC&lt;/li&gt;
      &lt;li&gt;OSQP인 ADMM 기법을 쓴다면 이걸 사용하는게 좋음!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예산의 제한이 없으면 CLPEX
    &lt;ul&gt;
      &lt;li&gt;Industry Standard로 압도적 속도 및 성능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;대학생이라면 Gurobi
    &lt;ul&gt;
      &lt;li&gt;아카데믹 지원이 됨&lt;/li&gt;
      &lt;li&gt;미래를 길게 보면 구로비가 안좋을수도..&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스타트업이라면
    &lt;ul&gt;
      &lt;li&gt;외부 배포할 일이 없고 LP만 풀면 GLPK&lt;/li&gt;
      &lt;li&gt;성능만 기똥찬 CLP/CBC&lt;/li&gt;
      &lt;li&gt;OSQP&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최적화 모델 구현
    &lt;ul&gt;
      &lt;li&gt;전력시장을 예시&lt;/li&gt;
      &lt;li&gt;전력은 발전과 소비가 늘 동시에&lt;/li&gt;
      &lt;li&gt;전체의 총 수요와 발전을 잘 매치해야함&lt;/li&gt;
      &lt;li&gt;언밸런스라면 주파수가 안맞아서 큰일날 수 있음&lt;/li&gt;
      &lt;li&gt;각 발전기 최적 발전량 결정
        &lt;ul&gt;
          &lt;li&gt;3개의 발전기의 발전량 스케쥴링&lt;/li&gt;
          &lt;li&gt;조건 1 : 발전기 설비 상황&lt;/li&gt;
          &lt;li&gt;조건 2 : 수급 균형(발전량=수요량)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;목적 함수 : 비용 최소화
        &lt;ul&gt;
          &lt;li&gt;발전단가 최소화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;제약 조건
        &lt;ul&gt;
          &lt;li&gt;최소 용량 &amp;lt;= 발전량 &amp;lt;= 최대 용량&lt;/li&gt;
          &lt;li&gt;총 발전량 = 전력수요&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;변수가 너무 많아 일일히 하기 어렵&lt;/li&gt;
      &lt;li&gt;CVXPY와 numpy 호환이 좋음&lt;/li&gt;
      &lt;li&gt;문제가 더 복잡하고 커질수록 솔버마다 차이가 커짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;심화 예제 : 하지만 현실은 QP
    &lt;ul&gt;
      &lt;li&gt;사실 발전비용은 2차곡선&lt;/li&gt;
      &lt;li&gt;목적함수 변경 (QP)
        &lt;ul&gt;
          &lt;li&gt;제곱식을 추가&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;수십만개의 변수, 수많은 비선형 제약조건&lt;/li&gt;
      &lt;li&gt;발전기를 켤지/끌지도 결정해야 (IP)&lt;/li&gt;
      &lt;li&gt;선로제약, 전압안정도 고려해야함 (NLP)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;참고 자료
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://prod-ng.sandia.gov/techlib-noauth/access-control.cgi/2013/138847.pdf&quot;&gt;Comparison of Open-Source Linear
Programming Solvers&lt;/a&gt; : 62페이지&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.mat.univie.ac.at/~neum/ms/comparison.pdf&quot;&gt;A comparative analysis of optimization solvers&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최적화에 대해 이미 알고있어서 꽤 아는 내용이었음. 그래도 오픈소스를 한번 싹 정리해주셔서 매우 좋았음!&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;뚱뚱하고-굼뜬-판다pandas를-위한-효과적인-다이어트-전략&quot;&gt;뚱뚱하고 굼뜬 판다(Pandas)를 위한 효과적인 다이어트 전략&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;오성우님&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://drive.google.com/file/d/12faqaslFIF-Sg_sU3jeGyauW5ClRqS8D/view&quot;&gt;발표 자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Pandas는 관계형 데이터를 빠르고 유연하게 개발됨&lt;/li&gt;
  &lt;li&gt;흔히 맞닥뜨리는 문제
    &lt;ul&gt;
      &lt;li&gt;데이터를 읽지도 못하고&lt;/li&gt;
      &lt;li&gt;시간도 오래 걸리고&lt;/li&gt;
      &lt;li&gt;작성하는 코드 방식도 제각각&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;원인
    &lt;ul&gt;
      &lt;li&gt;Pandas Memory mapping issue&lt;/li&gt;
      &lt;li&gt;Python Auto Garvage Collectiong&lt;/li&gt;
      &lt;li&gt;Data processing in memory at once&lt;/li&gt;
      &lt;li&gt;using wrong syntax&lt;/li&gt;
      &lt;li&gt;using one CPU&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pandas way!
    &lt;ul&gt;
      &lt;li&gt;다이어트 전략&lt;/li&gt;
      &lt;li&gt;전략 1 : 식사량 조절, Memory Optimization&lt;/li&gt;
      &lt;li&gt;전략 2: 식이요법, Enhancing Performance&lt;/li&gt;
      &lt;li&gt;전략 3 : 습관, Adopting convension&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;국민건강보험공단(NHIS)에 제공하는 데이터 4억 중 일부를 전처리&lt;/li&gt;
  &lt;li&gt;1) 식사량 조절
    &lt;ul&gt;
      &lt;li&gt;큰 사이즈의 데이터 메모리 사용을 최적화
        &lt;ul&gt;
          &lt;li&gt;문자열로 된 데이터를 숫자/영어로 변환&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;데이터 형식 변환
        &lt;ul&gt;
          &lt;li&gt;판다스는 고정된 바이트 유지&lt;/li&gt;
          &lt;li&gt;데이터 형식을 알면 dtype에 형식 지정&lt;/li&gt;
          &lt;li&gt;데이터를 불러왔지만 크기를 줄이고 싶으면 astype&lt;/li&gt;
          &lt;li&gt;check_dtypes()&lt;/li&gt;
          &lt;li&gt;메모리 사용량이 줄어듬&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Category 데이터 형식 사용
        &lt;ul&gt;
          &lt;li&gt;R에서 factor가 python category&lt;/li&gt;
          &lt;li&gt;Object를 Category로 변환하면 메모리 사용량 크게 감소&lt;/li&gt;
          &lt;li&gt;범주가 무수히 많은 경우엔 object보다 비효율적일 수 있음&lt;/li&gt;
          &lt;li&gt;Object는 2.3초, Category는 0.3초&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;파일 저장 포맷 변경
        &lt;ul&gt;
          &lt;li&gt;CSV는 string 기반이라 IO 효율이 없음&lt;/li&gt;
          &lt;li&gt;Meta data가 없어 연속성 가지고 사용 불가&lt;/li&gt;
          &lt;li&gt;hdf5, parquet, pickle, feather 등을 사용함&lt;/li&gt;
          &lt;li&gt;parquet가 압축 형태로 제공되서 좋음&lt;/li&gt;
          &lt;li&gt;개인적으로 feather, pickle&lt;/li&gt;
          &lt;li&gt;프로젝트나 협업 목적은 parquet, hdf5&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;요약
        &lt;ul&gt;
          &lt;li&gt;데이터 타입 형식 지정&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2) 식이습관
    &lt;ul&gt;
      &lt;li&gt;2-1. Vectorization
        &lt;ul&gt;
          &lt;li&gt;벡터화 연산을 사용하면 반복문을 사용하지 않고도 모든 원소에 대해 반복연산이 가능&lt;/li&gt;
          &lt;li&gt;len(df)&lt;/li&gt;
          &lt;li&gt;.iterrows()&lt;/li&gt;
          &lt;li&gt;.apply&lt;/li&gt;
          &lt;li&gt;Pandas Series Vectorization&lt;/li&gt;
          &lt;li&gt;Numpy Array Vectorization&lt;/li&gt;
          &lt;li&gt;넘파이가 더 빠름&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@np.vectorize&lt;/code&gt;를 사용하면 Custom 함수를 vectorization해줌&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2-2. 효율적인 알고리즘
        &lt;ul&gt;
          &lt;li&gt;Pandas의 수백개 메소드를 어떻게 조합하냐에 따라 시간이 다름&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.sort_values(ascending=False).head(5)&lt;/code&gt; vs &lt;code class=&quot;highlighter-rouge&quot;&gt;.nlargest(5)&lt;/code&gt; : 후자가 속도 10개 넘게 빠름&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2-3. df.apply()는 만능이 아님
        &lt;ul&gt;
          &lt;li&gt;Custom 함수를 만들어 apply를 사용해 데이터 처리, 분석. lambda와 사용&lt;/li&gt;
          &lt;li&gt;List Comprehension&lt;/li&gt;
          &lt;li&gt;pd.Series.apply()&lt;/li&gt;
          &lt;li&gt;pd.DataFrame.isin&lt;/li&gt;
          &lt;li&gt;pd.DataFrame.query&lt;/li&gt;
          &lt;li&gt;np.isin&lt;/li&gt;
          &lt;li&gt;pd.DataFrame.merge&lt;/li&gt;
          &lt;li&gt;아래로 갈수록 더 빠름&lt;/li&gt;
          &lt;li&gt;merge는 Database에 익숙&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;요약
        &lt;ul&gt;
          &lt;li&gt;반복문 사용은 피하고 Vectorization 사용&lt;/li&gt;
          &lt;li&gt;수행 시간을 더 빠르게 하고 싶으면 좀 더 효율적 알고리즘을 고려&lt;/li&gt;
          &lt;li&gt;Custom 함수는 우선 apply, 오래 걸리면 Pandas built-in 함수를 찾아 조합해 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3) 생활 습관
    &lt;ul&gt;
      &lt;li&gt;Method Chaining
        &lt;ul&gt;
          &lt;li&gt;가독성이 좋고, 성능이 좋음&lt;/li&gt;
          &lt;li&gt;한계
            &lt;ul&gt;
              &lt;li&gt;DataFrame의 중간 체크가 어려움&lt;/li&gt;
              &lt;li&gt;진짜 성능이 좋아지는진 물음표&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;데이터를 줄일 경우 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;inplace parameter
        &lt;ul&gt;
          &lt;li&gt;inplace 선호나느 사용자
            &lt;ul&gt;
              &lt;li&gt;속도가 더 빠르고, 메모리를 더 효율적으로 사용한다&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;pandas Core 개발자는 inplace를 없앰. 실행 이후에 메모리에 데이터에 남음&lt;/li&gt;
          &lt;li&gt;데이터를 일부먼 수정할 경우 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기타 유의사항
    &lt;ul&gt;
      &lt;li&gt;Case by Case&lt;/li&gt;
      &lt;li&gt;Garbage collection
        &lt;ul&gt;
          &lt;li&gt;delete를 주기적으로 하고 gc.collect&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Not designed for Big Data?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스케일링
    &lt;ul&gt;
      &lt;li&gt;cuDF&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실질적으로 바로 활용할 수 있는 꿀팁이 가능했던 세션, in보다 merge해서 보는게 더 빠르다는건 (SQL에서 자주 보던 방식이었지만) 신기했음&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;파이썬-37-어찌-그렇게-빨라졌나&quot;&gt;파이썬 3.7 어찌 그렇게 빨라졌나&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;정겨울님&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://speakerdeck.com/jungwinter/why-is-python-3-dot-7-fastest&quot;&gt;발표 자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;사실 과거 버전에도 계속 성능 개선은 있었음&lt;/li&gt;
  &lt;li&gt;3.7은 릴리즈 노트에 Optimization을 꼭 집어서 말함
목표
    &lt;ul&gt;
      &lt;li&gt;성능 개선을 위한 아이디어&lt;/li&gt;
      &lt;li&gt;더 알고싶으면 어디를 볼지&lt;/li&gt;
      &lt;li&gt;그래도 완전 어렵지 않은 C 코드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 메소드 호출
    &lt;ul&gt;
      &lt;li&gt;표준 라이브러리에 속한 클래스에 있는 여러 메서드들을 최적화함&lt;/li&gt;
      &lt;li&gt;METH_FASTCALL 컨벤션을 따르도록 바꿈
        &lt;ul&gt;
          &lt;li&gt;생긴건 obcode처럼 생겼지만 사실 C 함수 선언 컨벤션&lt;/li&gt;
          &lt;li&gt;파이썬 tuple이 PyObject의 C 배열로 들어옴&lt;/li&gt;
          &lt;li&gt;더 알고싶으면 bpo-27810&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;python 3.8에 positional arguments 개념이 동입됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Argument Clinic
    &lt;ul&gt;
      &lt;li&gt;함수 변환과 생성을 도와주는 도구&lt;/li&gt;
      &lt;li&gt;CPython 내장 함수 인수 처리를 돕는 DSL&lt;/li&gt;
      &lt;li&gt;PEP-436 참고&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파이썬 시작 시간
    &lt;ul&gt;
      &lt;li&gt;인터프리터를 실행하는 시간이 감소함&lt;/li&gt;
      &lt;li&gt;맥 30%, Linux 10%&lt;/li&gt;
      &lt;li&gt;abc 모듈을 C로 다시 짬&lt;/li&gt;
      &lt;li&gt;site.py가 사용하는 sysconfig.py의 특정 함수를 import하지 않고 복사해서 사용하니 빨라짐
        &lt;ul&gt;
          &lt;li&gt;인터프리터를 실행할 때 자동으로 import, site-package 경로를 찾고 추가&lt;/li&gt;
          &lt;li&gt;sysconfig의 함수를 site.py로 가져오는데 이게 무거웠던 상황&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인스턴스 메서드 호출
    &lt;ul&gt;
      &lt;li&gt;positional argumnets 함수 호출에 대한 새로운 opcode 2개 추가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;asyncio.sleep
    &lt;ul&gt;
      &lt;li&gt;asyncio.sleep()이 2배 빨라짐 =&amp;gt; zero나 음수일 떄 빨라짐&lt;/li&gt;
      &lt;li&gt;기존엔 delay가 0이면 바로 리턴인데, delay가 음수면 future 만들고 루프에 스케쥴링 했는데 안하도록 바뀜&lt;/li&gt;
      &lt;li&gt;이 부분 생략하게 됨&lt;/li&gt;
      &lt;li&gt;sleep0은 그냥 yield만 있는 형태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이벤트 루프 만들기
    &lt;ul&gt;
      &lt;li&gt;asyncio.get_event_loop, get_running_loop 함수를 C로 짜서 4배 빨라짐&lt;/li&gt;
      &lt;li&gt;캐싱 사용은 미미하고 os.getpid()대신 getpid()를 사용(C쪽) =&amp;gt; 성능 향상 80%&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;동시에 실행하기
    &lt;ul&gt;
      &lt;li&gt;asynci.gather()가 15% 빨라짐&lt;/li&gt;
      &lt;li&gt;마이크로서비스에서 하나를 받아 다른걸 처리 =&amp;gt; 한번에 가져오도록 돌리게 해줌&lt;/li&gt;
      &lt;li&gt;코루틴 하나하나를 functools.partial을 제거&lt;/li&gt;
      &lt;li&gt;다 끝났을 때만 로직을 실행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;asyncio.ensure_future
    &lt;ul&gt;
      &lt;li&gt;1.17배 빨라짐&lt;/li&gt;
      &lt;li&gt;if문 순서를 바꿔서 성능이 개선됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;typing 모듈 가져오기
    &lt;ul&gt;
      &lt;li&gt;제네릭 형식을 더 잘 지원하기 위해 특수 메서드 추가&lt;/li&gt;
      &lt;li&gt;던더메소드는 경고없이 깨질 수 있다고 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;리스트 정렬
    &lt;ul&gt;
      &lt;li&gt;40~75% 개선&lt;/li&gt;
      &lt;li&gt;리스트를 정렬할 때 대부분 값들이 서로 동일한 타입이라 가정&lt;/li&gt;
      &lt;li&gt;매번 값을 비교할 때마다 타입 검사하지 말고 한번만 해두자가 아이디어&lt;/li&gt;
      &lt;li&gt;여러 가정을 세우고 pre-check stage를 만듬&lt;/li&gt;
      &lt;li&gt;아주 최악의 경우 pre-check 때문에 15% 느려짐(safe_object_compare로 넘어가기까지)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;딕셔너리 복사
    &lt;ul&gt;
      &lt;li&gt;dict.copy()가 5.5배 빨라짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정규표현식
    &lt;ul&gt;
      &lt;li&gt;case-insensitive matching이 20배 빨라짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파이썬 그 자체에 관심을 더 가지면 좋겠다고 생각하도록 만들어준 세션&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;머신러닝-및-데이터-과학-연구자를-위한-python-기반-컨테이너-분산처리-플랫폼-설계-및-개발&quot;&gt;머신러닝 및 데이터 과학 연구자를 위한 python 기반 컨테이너 분산처리 플랫폼 설계 및 개발&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;신정규님&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/inureyes/python-164418964&quot;&gt;발표 자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;2015년 리뷰
    &lt;ul&gt;
      &lt;li&gt;연구자 및 교육자를 위한 계산 및 분석 플랫폼 설계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;현대 과학 연구와 개선
    &lt;ul&gt;
      &lt;li&gt;학계와 업계, 사회의 간극이 존재한다 생각&lt;/li&gt;
      &lt;li&gt;재현 가능한 데이터 연구 플랫폼 만듬&lt;/li&gt;
      &lt;li&gt;논문용 코드가 쉽게 스케일업되는 서비스!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컨테이너 기반의 고밀도 분산처리 플랫폼 및 사용자 편의 기능 구현!!하자고 했음(프로토도 있으니..)&lt;/li&gt;
  &lt;li&gt;Backend AI
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/lablup/backend.ai&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;용어 설명
    &lt;ul&gt;
      &lt;li&gt;Baremetal
        &lt;ul&gt;
          &lt;li&gt;가상 머신. 안에 있는 VM은 격리된 환경에서 삼&lt;/li&gt;
          &lt;li&gt;Shared : OS, Container Layer, Container&lt;/li&gt;
          &lt;li&gt;컨테이너 : 호스트 운영체제 커널을 공유&lt;/li&gt;
          &lt;li&gt;구현
            &lt;ul&gt;
              &lt;li&gt;Container layer : LXC, runC, Jail&lt;/li&gt;
              &lt;li&gt;컨트롤 그룹을 사용해 구현&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;클라우드 매니저
            &lt;ul&gt;
              &lt;li&gt;클러스터에 VCM 또는 스토리지 생성&lt;/li&gt;
              &lt;li&gt;IaaS 구축을 위한 소프트웨어&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;컨테이너 관리 솔루션
            &lt;ul&gt;
              &lt;li&gt;컨테이너를 생성, 삭제, 배치, 관리하는 역할 담당&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;권불 10주
    &lt;ul&gt;
      &lt;li&gt;이 바닥은 10주마다 바뀐다&lt;/li&gt;
      &lt;li&gt;Rootless 컨테이너 및 특화 컨테이너 솔루션의 등장&lt;/li&gt;
      &lt;li&gt;마이크로서비스의 대두
        &lt;ul&gt;
          &lt;li&gt;어플리케이션을 작은 단위로 쪼갬&lt;/li&gt;
          &lt;li&gt;서비스 모듈 + 통신&lt;/li&gt;
          &lt;li&gt;빠른 버전업 및 지속적 통합&lt;/li&gt;
          &lt;li&gt;기반 언어의 변화, 프로토콜도 확장&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;비동기 시대
        &lt;ul&gt;
          &lt;li&gt;Asynchronous IO의 도래&lt;/li&gt;
          &lt;li&gt;마이크로서비스 : 지연 시간 예측 난도&lt;/li&gt;
          &lt;li&gt;많은 마이크로서비스들이 비동기로 동작&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;우공이산
    &lt;ul&gt;
      &lt;li&gt;기본 설계하기&lt;/li&gt;
      &lt;li&gt;오픈소스화 하다보니 다양한 사람들의 환경을 지원해야 함&lt;/li&gt;
      &lt;li&gt;머신러닝 모델 대비!
        &lt;ul&gt;
          &lt;li&gt;허나 Tensorflow 등장하고 난리남&lt;/li&gt;
          &lt;li&gt;하위호환성 안줘 ㅠ&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;nvidia-docker도 바뀜&lt;/li&gt;
      &lt;li&gt;PyTorch의 등장
        &lt;ul&gt;
          &lt;li&gt;버전마다 구현체가 다름&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;설상가상
    &lt;ul&gt;
      &lt;li&gt;문제를 해결하면 새로운 것이 또 따라옴&lt;/li&gt;
      &lt;li&gt;병렬화
        &lt;ul&gt;
          &lt;li&gt;GPU가 계속 놀아요 ㅠ_ㅠ&lt;/li&gt;
          &lt;li&gt;데이터 병렬화나 모델 병렬화&lt;/li&gt;
          &lt;li&gt;데이터 파이프라인도 싱글 노드 - 멀티 GPU, 멀티 노드 - 멀티 GPU에 맞춰 처리&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;연구분야
        &lt;ul&gt;
          &lt;li&gt;세상의 속도가 다르게 흐르는 곳&lt;/li&gt;
          &lt;li&gt;아직도 Python2… 2를 지원해야하네&lt;/li&gt;
          &lt;li&gt;TensorFlow Extended 이런거 최근까지 python2까지만 지원됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Python 2/3 징원
        &lt;ul&gt;
          &lt;li&gt;인터페이스를 어떻게 하지?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ZeroMQ
        &lt;ul&gt;
          &lt;li&gt;거의 모든 언어로 구현체가 존재!&lt;/li&gt;
          &lt;li&gt;지원 언어가 15개 이상 되니 대환장&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Kernel Runner
        &lt;ul&gt;
          &lt;li&gt;컨테이너의 운영체제만 영향을 줌&lt;/li&gt;
          &lt;li&gt;장점 : 백엔드 AI 에이전트는 3.6으로 하고 안에는 다른거도 가도 됨&lt;/li&gt;
          &lt;li&gt;배포할 떄 계속 문제..&lt;/li&gt;
          &lt;li&gt;그래서 Embeded Kernel Runner로 씀&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;화룡정점
    &lt;ul&gt;
      &lt;li&gt;언어별 SDK 구현. 기존 구현체들은 너무 방대&lt;/li&gt;
      &lt;li&gt;오프라인 환경
        &lt;ul&gt;
          &lt;li&gt;pip는 항상 온라인이..&lt;/li&gt;
          &lt;li&gt;Builder 만듬&lt;/li&gt;
          &lt;li&gt;Ansible로 배포 자동화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;GUI&lt;/li&gt;
      &lt;li&gt;코어
        &lt;ul&gt;
          &lt;li&gt;Webcomponent 기술 기반&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;메인 앱
        &lt;ul&gt;
          &lt;li&gt;장고 기반&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;파이프라인 앱
        &lt;ul&gt;
          &lt;li&gt;별도 개발해서 통합 예정&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;앱
        &lt;ul&gt;
          &lt;li&gt;Electron 기반&lt;/li&gt;
          &lt;li&gt;JavaScript ES6 코드 서빙&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;웹 콘솔 모드
        &lt;ul&gt;
          &lt;li&gt;Consoel-server와 결합&lt;/li&gt;
          &lt;li&gt;Manager 프록시&lt;/li&gt;
          &lt;li&gt;웹소켓 프록시&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;허브
        &lt;ul&gt;
          &lt;li&gt;전체 클러스터 관리용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;고가용성
        &lt;ul&gt;
          &lt;li&gt;매니저가 왜 3개씩 존재하지 않나?&lt;/li&gt;
          &lt;li&gt;로드 밸런서 구현&lt;/li&gt;
          &lt;li&gt;Fleet 운영시 Voting 알고리즘으로 대장 선정&lt;/li&gt;
          &lt;li&gt;웹소켓 프록시 터널링을 사용해서 ssh 터널링 쓰는데.. 자꾸 사용자 환경에 깔기 싫다! 해서 웹에서 아답터를 위해 프록시 터널링 설계해서 구현함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;홍익인간
    &lt;ul&gt;
      &lt;li&gt;GPU 가상화&lt;/li&gt;
      &lt;li&gt;fGPU 구현 및 테스트
        &lt;ul&gt;
          &lt;li&gt;하나를 가상화해서 여러개처럼 사용해보니 이게 더 빠르네?&lt;/li&gt;
          &lt;li&gt;우리의 코드는.. GPU를 괴롭히지 못함 나눠서 멀티로 하는게 더 빠름&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;어마어마하다..ㅋㅋㅋㅋㅋㅋㅋ 고생하신게 엄청 보였고, 그 기간에 다 하셨다는 것도 대단..&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;추천시스템-이제는-돈이-되어야-한다&quot;&gt;추천시스템, 이제는 돈이 되어야 한다&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;최규민님&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/ssuser2fe594/ss-164511610&quot;&gt;발표 자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;앞에 좀 못들음 ㅠ&lt;/li&gt;
  &lt;li&gt;어떤 MAB 알고리즘이 가장 좋은 성능을 내는가?
    &lt;ul&gt;
      &lt;li&gt;대부분 추천 시스템에서 TS-MAB가 가장 좋은 성ㅇ능을 발휘함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;엡실론 그리디 MAB
    &lt;ul&gt;
      &lt;li&gt;기본적 Bandit 알고리즘&lt;/li&gt;
      &lt;li&gt;작품별 CTR 예측&lt;/li&gt;
      &lt;li&gt;Best Arm 선택&lt;/li&gt;
      &lt;li&gt;탐색과 활용이 적절한가?&lt;/li&gt;
      &lt;li&gt;CTR이 낮은 작품의 impressions별 CTR 신뢰 구간을 보자&lt;/li&gt;
      &lt;li&gt;Impression이 많아질수록 CTR이 수렴함이 보임&lt;/li&gt;
      &lt;li&gt;10M Impressions&lt;/li&gt;
      &lt;li&gt;추천될 수 없는 작품, 즉 Optimal Arm이 아님에도 계속 Impressions을 소비함(regret:손실 증가)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;톰슨 샘플링
    &lt;ul&gt;
      &lt;li&gt;엡실론 방법은 작품별 impresson 양을 동일하게 부여했지만, 이건 작품별(Arm)별 베타 분포로 샘플링&lt;/li&gt;
      &lt;li&gt;a=click, b=unclick&lt;/li&gt;
      &lt;li&gt;1000개부터는 점점 CTR 수렴&lt;/li&gt;
      &lt;li&gt;추천될 수 있는 최소 CTR이 15%라 가정하면 작품 1번은 100 impressons까지만 trial되고 그 이후엔 서택되지 않음&lt;/li&gt;
      &lt;li&gt;적절히 신뢰할만한 impression이 모이면 탐색 -&amp;gt; 활용으로 전환&lt;/li&gt;
      &lt;li&gt;CTR이 25%이상 작품은 계속 탐색하고 수렴
        &lt;ul&gt;
          &lt;li&gt;빠르게 수렴 및 빠르게 engage&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;실제 웹툰 작품들의 베타 분포 변화
        &lt;ul&gt;
          &lt;li&gt;계속 탐색함&lt;/li&gt;
          &lt;li&gt;신뢰 구간이 점점 좁아지며 수렴하는 작품들이 생김&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;해석
        &lt;ul&gt;
          &lt;li&gt;CTR이 낮은 작품(Arm)들은 적당히 탐색하다가 추천을 하지 않고, CTR이 좋을 것 같으면 계속 탐색&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;TS MAB는 탐색&amp;amp;활용 Trade-off에서 적절힌 Reget(손실)을 최소화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;User Clustering
    &lt;ul&gt;
      &lt;li&gt;작품의 CTR은 유저 성향별로 다름
        &lt;ul&gt;
          &lt;li&gt;유저 A : 25% (30대 액션물 좋아함)&lt;/li&gt;
          &lt;li&gt;유저 B : 2.1% (순정 만화를 좋아하는 여성)&lt;/li&gt;
          &lt;li&gt;유저 C : 7.1% (모든 만화를 좋아하는 남자)&lt;/li&gt;
          &lt;li&gt;유저별로 CTR이 높을 작품을 추천하면!&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;모든 유저별 X 모든 작품에 대해 CTR 측정이 필요함&lt;/li&gt;
      &lt;li&gt;그런데 모든 경우에 대해 CTR 측정은 불가능&lt;/li&gt;
      &lt;li&gt;그래서 유저 클러스터링함&lt;/li&gt;
      &lt;li&gt;CTR이 비슷할 것 같은 유저끼리 모으고(8개)&lt;/li&gt;
      &lt;li&gt;그 내에서 CTR을 예측&lt;/li&gt;
      &lt;li&gt;어떻게 클러스터링하는가?
        &lt;ul&gt;
          &lt;li&gt;웹툰을 열람한 성향이 있다고 가정&lt;/li&gt;
          &lt;li&gt;유저가 최근 읽은 작품들&lt;/li&gt;
          &lt;li&gt;읽은 작품으로 CB(image, Text)를 Feature로 User Feature 생성 =&amp;gt; 유사한 유저끼리 클러스터링&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;이 8개의 클러스터가 유저의 성향을 적절히 반영하는가?
        &lt;ul&gt;
          &lt;li&gt;알려진 스코어가 잘 measure 안되서 정성적 탐색을 함&lt;/li&gt;
          &lt;li&gt;유저클러스터 결과
            &lt;ul&gt;
              &lt;li&gt;성별 분포
                &lt;ul&gt;
                  &lt;li&gt;각 클러스터별 성별 편향성이 뚜렷함&lt;/li&gt;
                  &lt;li&gt;여성 중심 / 남성 중심 / 여성 &amp;amp; 남성 혼합&lt;/li&gt;
                  &lt;li&gt;각 클러스터별 어떤 장르가 많이 소비되는지 파악&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;클러스터별 소비만화 Tag들 파악&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;개인화 홈 추천
    &lt;ul&gt;
      &lt;li&gt;클러스터 할당&lt;/li&gt;
      &lt;li&gt;추천할만한 작품 Targeter&lt;/li&gt;
      &lt;li&gt;MAB를 통해 후보 작품을 Ranking&lt;/li&gt;
      &lt;li&gt;광고 시스템과 비슷함&lt;/li&gt;
      &lt;li&gt;유저클러스터 + MAB 적용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;연관추천 - ViewerEnd 추천
    &lt;ul&gt;
      &lt;li&gt;목적 : 현재 읽고 있는 작품과 유사한 작품 중에서 열람수를 늘리기 위해 CTR(%)이 가장 높을 작품 추천&lt;/li&gt;
      &lt;li&gt;사용되는 추천 모델들
        &lt;ul&gt;
          &lt;li&gt;item feature&lt;/li&gt;
          &lt;li&gt;MAB&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;비슷한 작품 Targeter =&amp;gt; 작품 Ranker&lt;/li&gt;
      &lt;li&gt;현재 본 작품과 설명이 유사한, 썸네일이 유사한 것을 추천&lt;/li&gt;
      &lt;li&gt;item feature
        &lt;ul&gt;
          &lt;li&gt;대표 이미지, 작품 제목, 설명, 유저 Feedback으로 작품간 상관 특징 추출&lt;/li&gt;
          &lt;li&gt;Image로 Style 특징점을 추출해 스타일이 유사한 작품 추출&lt;/li&gt;
          &lt;li&gt;Image로 Object Detection Task를 통해 특징점을 추출해 Image Object가 유사한 작품을 뽑음&lt;/li&gt;
          &lt;li&gt;Word2Vec으로 작품의 제목, 설명으로 특징점을 추천&lt;/li&gt;
          &lt;li&gt;Matrix Factorization(ALS) with implicit feedback 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;유사 작품 + MAB&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구매 전환을 최대화하기 위한 실험들
    &lt;ul&gt;
      &lt;li&gt;열람 중심 =&amp;gt; 구매 중심&lt;/li&gt;
      &lt;li&gt;이제는 돈을 벌고 싶어요!&lt;/li&gt;
      &lt;li&gt;열람 중심은 전체 열람(Clicks) 합이 최대화하도록 구현&lt;/li&gt;
      &lt;li&gt;구매 중심은 유료 열람(Use Coin)합이 최대화&lt;/li&gt;
      &lt;li&gt;실험 1. 매출 중심 MAB
        &lt;ul&gt;
          &lt;li&gt;Rewardd : Use Coin&lt;/li&gt;
          &lt;li&gt;열람 전환율&lt;/li&gt;
          &lt;li&gt;구매 전환율&lt;/li&gt;
          &lt;li&gt;결과
            &lt;ul&gt;
              &lt;li&gt;폭망 ㅠ&lt;/li&gt;
              &lt;li&gt;실험군(Beta)는 대조군(Alpha) 대비 -20% 떨어짐 =&amp;gt; 실험 종료&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;왜 그럴까?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;실험 2. Conditional Bandit 실험
        &lt;ul&gt;
          &lt;li&gt;사건의 종속성 반영&lt;/li&gt;
          &lt;li&gt;첫번째 MAB : Reward=Click(무료 열람)&lt;/li&gt;
          &lt;li&gt;두번째 MAB : Rewardd=Use Coin&lt;/li&gt;
          &lt;li&gt;결과
            &lt;ul&gt;
              &lt;li&gt;실험군의 대조군 대비 유료 열람수의 변화는 없음&lt;/li&gt;
              &lt;li&gt;두번째 MAB의 수렴성이 보장되지 않음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;실험 3. Retention Model
        &lt;ul&gt;
          &lt;li&gt;리텐션이 높은 작품을 추천해보자&lt;/li&gt;
          &lt;li&gt;작품마다 열람지속 스코어 측정&lt;/li&gt;
          &lt;li&gt;열람지속 스코어가 높은 작품을 연관추천 추가해 MAB 수행&lt;/li&gt;
          &lt;li&gt;결과
            &lt;ul&gt;
              &lt;li&gt;열람 전환율(CTR)은 지표 상승&lt;/li&gt;
              &lt;li&gt;구매 전환율은 변화 없음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;실험 4. Seen decay
        &lt;ul&gt;
          &lt;li&gt;유저에게 노출했는데 클릭하지 않는다면 해당 작품에 대한 Negative Feedback&lt;/li&gt;
          &lt;li&gt;안보면 패널티를 주자&lt;/li&gt;
          &lt;li&gt;실험 결과&lt;/li&gt;
          &lt;li&gt;대조군 대비 실험군의 CTR은 상승했지만 구매 전환율은 변화 없음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;그물외 다양한 실험들 많이 해봄&lt;/li&gt;
      &lt;li&gt;다시 고민
        &lt;ul&gt;
          &lt;li&gt;왜 실험의 구매 지표 개선이 없지?&lt;/li&gt;
          &lt;li&gt;컨텐츠 사용자의 구매 패턴부터 다시 분석&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;독자들은 어떻게 유료 작품을 열람할까?
        &lt;ul&gt;
          &lt;li&gt;추천을 보고 - 클릭 - 무료 열람 - 지속 열람 - 유료 열람&lt;/li&gt;
          &lt;li&gt;엄청 긴 퍼널을 가지고 있음&lt;/li&gt;
          &lt;li&gt;노출 대비 유료 전환율은 0.1% 이하로 매우 낮음&lt;/li&gt;
          &lt;li&gt;무료에서 열람까지 걸리는 시간은 평균 4.56일.. 좀 길다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;구매 전환율은 매우 낮고 구매 Feedback은 매우 지연됨
        &lt;ul&gt;
          &lt;li&gt;구매 최적화를 위한 AB 실험의 지표&lt;/li&gt;
          &lt;li&gt;추적과 측정이 어려움&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;지금 개인화/연관 추천은 읽지 않은 작품을 추천
        &lt;ul&gt;
          &lt;li&gt;최초 열람 유도가 지속열람, 유료 열람에 상관관계 또는 인과관계가 있는가?&lt;/li&gt;
          &lt;li&gt;또 해봄&lt;/li&gt;
          &lt;li&gt;연속적 열람 전환율이 어떻게 되나?&lt;/li&gt;
          &lt;li&gt;추천과 비추천 로직의 변화가 있을까?
            &lt;ul&gt;
              &lt;li&gt;베이스(에디터픽) 대비 CTR 242%&lt;/li&gt;
              &lt;li&gt;4회 전환율은 42%&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;구매 전환율은 추천에 인과관계가 있지만 작품의 품질과 유료 결제 경험에 의존적임&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;목적
    &lt;ul&gt;
      &lt;li&gt;개인화/연관 추천은? 열람 작품 늘리기
        &lt;ul&gt;
          &lt;li&gt;초급&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;타켓팅 푸시? 지속 열람장의 유료 전환
        &lt;ul&gt;
          &lt;li&gt;중급&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;현재 소프트 클러스터 방법 쓰고 있음
    &lt;ul&gt;
      &lt;li&gt;내가 드라마 좋아할 확률 30%, 액션 20% 여러 토픽을 가진 클러스터로 구성함&lt;/li&gt;
      &lt;li&gt;정성적으로 하고 AB Test용으로&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;추천 안되는건 어떻게?
    &lt;ul&gt;
      &lt;li&gt;작품의 다이버시티를 이용하고, 여러 풀을 섞음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;implicit als&lt;/li&gt;
  &lt;li&gt;앞 극초반부는 못들었지만 이미 알던 내용들이라 다행, 전반적으로 매우 좋았음. 국내에서 추천, MAB를 잘하는 팀은 이 팀이 아닐까 생각된다..! 따로 시간내서 규민님이랑 오랜만에 담소했는데, 역시 즐거운 시간이었음&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;꼬마-모차르트가-되어보자&quot;&gt;꼬마 모차르트가 되어보자&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;김준우님, 한상곤님&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/datakun/StudyMagenta&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;인간과 기계가 차이가 없는 느낌&lt;/li&gt;
  &lt;li&gt;재미있는 프로젝트를 하고 싶었음
    &lt;ul&gt;
      &lt;li&gt;TensorFlow의 Magenta&lt;/li&gt;
      &lt;li&gt;이것도 알리고 예술적인 것들을 해봅시다!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구글에서 바흐 탄생 기념일에 뭔가를 만듬
    &lt;ul&gt;
      &lt;li&gt;소프라노 악보를 만들면 코드를 배치해줌&lt;/li&gt;
      &lt;li&gt;미디 파일을 찾아보자!
        &lt;ul&gt;
          &lt;li&gt;www.vgmusic.ocm 8bit 음악이 많음. 학습용 이외엔 쓰면 안되요..!&lt;/li&gt;
          &lt;li&gt;8bit midi 파일을 만듬&lt;/li&gt;
          &lt;li&gt;상용 불가&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;미디파일을 합법적으로 구하는 방법을 시작하겠습니다
    &lt;ul&gt;
      &lt;li&gt;발표 톤 너무 웃겨욬ㅋㅋㅋㅋㅋ&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://magenta.tensorflow.org/demos/colab/&quot;&gt;magenta colab&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;latent loops
        &lt;ul&gt;
          &lt;li&gt;멜로디 4개를 학습, 새로운 패턴이 나옴&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;피아노징
        &lt;ul&gt;
          &lt;li&gt;8개의 버튼으로 그럴듯한 연주를 하게 해줌&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Neural Drum
        &lt;ul&gt;
          &lt;li&gt;4박자만 패턴 입력하면 나머지 기계까 완성&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;PIANO scribe
        &lt;ul&gt;
          &lt;li&gt;피아노 들려주면 midi로 바꿔줌&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;마젠타는 파이썬으로 해볼 수 있겠다!
    &lt;ul&gt;
      &lt;li&gt;윈도우에선 잘 안되서 WSL 선택&lt;/li&gt;
      &lt;li&gt;단점
        &lt;ul&gt;
          &lt;li&gt;토이 프로젝트엔 괜찮지만 WSL1은 커널이 위에 올라가서 느림. WSL2는 성능이 좋아질거라 보임&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Onsets and Frames 모델을 이용해 추론&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;마주친 문제와 해결
    &lt;ul&gt;
      &lt;li&gt;파이썬 2.7 ㅋ&lt;/li&gt;
      &lt;li&gt;소리내기 위한 pyfluidsynth가 2점대만 지원&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Demo 보여줌&lt;/li&gt;
  &lt;li&gt;마젠타 라이브러리가 신기했고, 새로운 분야에 대해 알 수 있어서 좋았음&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;advanced-python-testing-techniques&quot;&gt;Advanced Python testing techniques&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;안재만님&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jaeman-static.s3.ap-northeast-2.amazonaws.com/pyconkr2019_AdvancedPythonTestingTechniques.pdf&quot;&gt;발표 자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;테스트 코드
    &lt;ul&gt;
      &lt;li&gt;내가 쓴 코드가 잘 자동하는지 확인하는 코드&lt;/li&gt;
      &lt;li&gt;프로젝트의 규모가 커지고, 참여하는 사람이 늘어날수록 반드시 필요&lt;/li&gt;
      &lt;li&gt;마음의 안정감을 가지고 프로젝트 유지보수가 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pytest
    &lt;ul&gt;
      &lt;li&gt;조금 더 powerful&lt;/li&gt;
      &lt;li&gt;assert문 사용 가능&lt;/li&gt;
      &lt;li&gt;더 자유로운 fixtur e사용 지원&lt;/li&gt;
      &lt;li&gt;테스트 실패할 때 uniitest보다 유용한 정보 제공&lt;/li&gt;
      &lt;li&gt;315+개의 플러그인 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;function 베이스로 테스트&lt;/li&gt;
  &lt;li&gt;Fixture 사용하기
    &lt;ul&gt;
      &lt;li&gt;다른 곳에서 정의하면 테스트 코드에서 사용할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기본적인 API 테스트 구현
    &lt;ul&gt;
      &lt;li&gt;유저가 가입하고 실제로 성공했는지 확인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;복잡한 API
    &lt;ul&gt;
      &lt;li&gt;response가 200이고 유저가 있고 아이디가 있고 등등… 테스트 코드가 읽기 어려워짐&lt;/li&gt;
      &lt;li&gt;어려워서 주석을 달았지만.. 도움은 안됨&lt;/li&gt;
      &lt;li&gt;관리자가 ban시키고 되는지 확인하는 테스트는?
        &lt;ul&gt;
          &lt;li&gt;아까보다 더 복잡함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;유저가 가입한 후 관리자가 승인하고 밴 시키고 로그인 안되는데 탈퇴 시도 성공하는데 재가입시 24시간동안 가입이 되지 않는것 테스트&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Sure를 이용해 더 직관적으로 테스트코드 구현
    &lt;ul&gt;
      &lt;li&gt;Assertion을 쓰기 쉽게 해주는 라이브러리&lt;/li&gt;
      &lt;li&gt;CPython에서만 사용 가능&lt;/li&gt;
      &lt;li&gt;Number, String, Collection, Callable 등에 대한 assertion 지원&lt;/li&gt;
      &lt;li&gt;가입한 후 관리자가 승인해야만 제대로 로그인되는지 테스트하는걸 더 직관적으로 가능&lt;/li&gt;
      &lt;li&gt;should.have.key&lt;/li&gt;
      &lt;li&gt;which.should&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BDD를 이용해 더 간단하고 재미있게 테스트 코드 구현하기
    &lt;ul&gt;
      &lt;li&gt;Behavior Driven Development&lt;/li&gt;
      &lt;li&gt;TDD와 유사&lt;/li&gt;
      &lt;li&gt;테스트 코드보다 비즈니스 요구사항에 집중하자&lt;/li&gt;
      &lt;li&gt;지원되는 Library
        &lt;ul&gt;
          &lt;li&gt;behave, lettuce, pytest-bdd&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;먼저 자연어로 테스트 코드를 작성&lt;/li&gt;
      &lt;li&gt;Feature : 테스트할 대상 기능&lt;/li&gt;
      &lt;li&gt;시나리오 : 테스트 상황 설명&lt;/li&gt;
      &lt;li&gt;Given : 테스트에서 사용할 데이터 컨텍스트
        &lt;ul&gt;
          &lt;li&gt;Backgoround : 공통적으로 사용되는 데이터, 컨텍스트&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;When : 수행할 조건&lt;/li&gt;
      &lt;li&gt;Then : 결과&lt;/li&gt;
      &lt;li&gt;login.feature를 정의하고 시나리오 작성&lt;/li&gt;
      &lt;li&gt;Parametrized testing in BDD
        &lt;ul&gt;
          &lt;li&gt;어떤 name의 약은 색이 뭐고, 어떤 결과엔 True, False 등&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;BDD 사용시 유의점
        &lt;ul&gt;
          &lt;li&gt;지금 발표 보면 오 BDD 짱! 이지만 단점이 있음
            &lt;ul&gt;
              &lt;li&gt;자연어로 define된 시나리오와 python 테스트 코드가 분리되어 있어 찾기 어려움
                &lt;ul&gt;
                  &lt;li&gt;IDE 도움을 받자&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;최대한 재사용 가능한 문장으로 테스트 구성
                &lt;ul&gt;
                  &lt;li&gt;예 : 가입에 성공하고 로그인을 한 유저가 있다 =&amp;gt; 정상 가입을 한 유저가 있다. 유저가 로그인을 한다&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;When에서 동작을 수행한 return 값은 Then에서 가져올 수 없음
                &lt;ul&gt;
                  &lt;li&gt;Given에서 context 만들어놓고, When에서 수행한 동작을 context에 저장하고 Then에서 확인&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;오늘부터 인증 서버를 분리해 새로 구현합니다
    &lt;ul&gt;
      &lt;li&gt;로직 변경
        &lt;ul&gt;
          &lt;li&gt;테스트 코드의 존재로 리팩토링을 안정감 가지고 진행할 수 있음&lt;/li&gt;
          &lt;li&gt;1) 테스트용 인증 서버를 올려야겠다&lt;/li&gt;
          &lt;li&gt;2) 항상 떠있는 개발 서버?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;HTTP Mocking
        &lt;ul&gt;
          &lt;li&gt;Mocking : 가장의&lt;/li&gt;
          &lt;li&gt;HTTP Mocking : 발생하는 HTTP Call을 interrupt하여 실제로 HTTP Call을 보내지 않고, 정해진 동작을 수행해 response를 반환하도록 함&lt;/li&gt;
          &lt;li&gt;Python : HTTPretty&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Monkey patching
        &lt;ul&gt;
          &lt;li&gt;런탕임에 정ㅇ의되어 있는 클래스나 모듈의 attribute를 바꿈&lt;/li&gt;
          &lt;li&gt;테스트 코드에서 많이 활용
            &lt;ul&gt;
              &lt;li&gt;A 모듈을 테스트, B 모듈에서 나온 결과는 항상 같은 값으로 고정&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;HTTPretty도 Monkey patching을 이용해 구현되어 있음&lt;/li&gt;
          &lt;li&gt;B는 import하지 않고 고정된 값을 가져오고 싶은 경우 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;데이터를 받아 예측하는 코드 예시&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모든 경우
    &lt;ul&gt;
      &lt;li&gt;수동으로 모든 경우를 테스트할 수 없음&lt;/li&gt;
      &lt;li&gt;랜덤한 input에 대해 function이 리턴해야할 값이나 수행할 동작을 테스트
        &lt;ul&gt;
          &lt;li&gt;어떤 input이 들어와도 error가 나면 안됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;QuickCheck : Randomized testing(하스켈)
        &lt;ul&gt;
          &lt;li&gt;python은 hypothesis library&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;given으로 랜덤한 input을 받도록 만들어주는 데코레이터&lt;/li&gt;
      &lt;li&gt;strategies는 랜덤하게 주어질 input의 규칙&lt;/li&gt;
      &lt;li&gt;머신러닝 모델
        &lt;ul&gt;
          &lt;li&gt;나이 예측 ML 모델에서 나온 나이 값이 0에서 100 사이인지, contribution이 0에서 1사이인지&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;너무 오래 걸리는 것 같아요
    &lt;ul&gt;
      &lt;li&gt;Benchmark test
        &lt;ul&gt;
          &lt;li&gt;함수를 수행하는데 걸린 시간 측정&lt;/li&gt;
          &lt;li&gt;1초에 몇개의 요청을 처리할 수 있는지 근사&lt;/li&gt;
          &lt;li&gt;다수아 사용하는 실 서비스 환경에서 반드시 필요&lt;/li&gt;
          &lt;li&gt;많이 노출될 API&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Basic 패턴 : start.time 사용하곤 함&lt;/li&gt;
      &lt;li&gt;benchmark로 감싸주면 더 편하게 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그 외 유용한 툴
    &lt;ul&gt;
      &lt;li&gt;벤치마크가 부족하면 Profiling 툴 사용(pytest-profiling)
        &lt;ul&gt;
          &lt;li&gt;함수별 execution graph와 실행시간 보여줌&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;N대의 서버들이 부하를 얼마나 버티는지 알고싶어요
        &lt;ul&gt;
          &lt;li&gt;http://locust.io&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;간단한 pytest plugin 만들기
    &lt;ul&gt;
      &lt;li&gt;goconvey
        &lt;ul&gt;
          &lt;li&gt;로직을 바꾸면 실시간으로 테스트 성공 실패를 웹으로 알려주는 툴&lt;/li&gt;
          &lt;li&gt;python으로 구현하려고 하는데 아직 못만듬! 내년에 꼭 소개드리겠습니다&lt;/li&gt;
          &lt;li&gt;pytest-convey
            &lt;ul&gt;
              &lt;li&gt;pytest-watch로 감지, pytest-json-report로 포맷팅&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정리
    &lt;ul&gt;
      &lt;li&gt;테스트 코드를 작성하기 쉽게 만들어 두는 것이 굉장히 중요&lt;/li&gt;
      &lt;li&gt;테스트코드 리팩토링
        &lt;ul&gt;
          &lt;li&gt;Top-down 방식으로 일단 코드 작성&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;테스트에 유용한 라이브러리 상용
        &lt;ul&gt;
          &lt;li&gt;Sure - assertion 알아보기 쉽게 작성 가능&lt;/li&gt;
          &lt;li&gt;BDD&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;기타 방법
        &lt;ul&gt;
          &lt;li&gt;HTTPPretty, Randomized, Monkey Patch&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;꿀팁을 많이 얻을 수 있어서 매우 좋았음!!&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;grpc와-python을-활용한-microservice-개발기&quot;&gt;gRPC와 python을 활용한 Microservice 개발기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;송지형님&lt;/li&gt;
  &lt;li&gt;MSA, gRPC 등&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://drive.google.com/file/d/14eYzUySeW5n1n0u7r0IYUqwsK75F_W2V/view&quot;&gt;발표 자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;클라우드 엔지니어로 시작&lt;/li&gt;
  &lt;li&gt;메가존 클라우드의 고민
    &lt;ul&gt;
      &lt;li&gt;고객들에게 좀 더 가치를 전해줄 수 있는 것이 없을까?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;안정적이고 확장 가능한 플랫폼&lt;/li&gt;
  &lt;li&gt;MSA
    &lt;ul&gt;
      &lt;li&gt;새로운 Feature가 느슨하게 연결되어야 함&lt;/li&gt;
      &lt;li&gt;MSA : 하나의 어플리케이션을 작은 서비스로 나누고, 프로세스를 가지고 가벼운 메커니즘을 사용해 HTTP resource API&lt;/li&gt;
      &lt;li&gt;서비스간 독립적 형태로 존재&lt;/li&gt;
      &lt;li&gt;유연한 대처가 가능&lt;/li&gt;
      &lt;li&gt;서비스별 별도 기술 적용 가능&lt;/li&gt;
      &lt;li&gt;자바, 파이썬, 노드 모두 가능&lt;/li&gt;
      &lt;li&gt;대부분 RESTful API를 통한 서비스 통신&lt;/li&gt;
      &lt;li&gt;단, Service간 Network를 통한 통신
        &lt;ul&gt;
          &lt;li&gt;통신 Overhead 증가&lt;/li&gt;
          &lt;li&gt;서비스별 다른 언어 사용 가능이 진짜일까? 생각보다 쉽지 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;gRPC
    &lt;ul&gt;
      &lt;li&gt;High performance, open-source universal RPC framework&lt;/li&gt;
      &lt;li&gt;통신 오버헤드를 최대한 줄이려는게 목적&lt;/li&gt;
      &lt;li&gt;pluggable support : 여러 플러그인을 사용 가능&lt;/li&gt;
      &lt;li&gt;구글이 개발한 RPC 기반 Framework&lt;/li&gt;
      &lt;li&gt;MSA와 같은 분산 구조에 적합한 효율적인 통신 프로토콜에 대한 고민&lt;/li&gt;
      &lt;li&gt;Remote Procedure Call
        &lt;ul&gt;
          &lt;li&gt;원격지의 프로그램을 로컬에서 실행하는 것처럼!&lt;/li&gt;
          &lt;li&gt;Code의 간결함&lt;/li&gt;
          &lt;li&gt;RESTful의 HTTP 규격 불필요&lt;/li&gt;
          &lt;li&gt;다시 돌아온&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;특징
        &lt;ul&gt;
          &lt;li&gt;프로토콜 버퍼
            &lt;ul&gt;
              &lt;li&gt;구조화된 데이터를 시리얼라이즈하기 위한 flexible, efficient, automated 메커니즘&lt;/li&gt;
              &lt;li&gt;메세지 처리 기술인데 더 작고 빠르고 심플&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;서버 클라이언트간 메시지를 정의하는 역할
            &lt;ul&gt;
              &lt;li&gt;실제 통신시 byte stream으로 데이터를 인코딩해 통신&lt;/li&gt;
              &lt;li&gt;XML보다 3~10배 작고 20~100배 빠름&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;HTTP/2&lt;/li&gt;
          &lt;li&gt;커뮤니케이션, 양방향&lt;/li&gt;
          &lt;li&gt;response도 정의 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Server Implementation&lt;/li&gt;
      &lt;li&gt;MSA에 특화된 Service간 Message 성능 향상에 집중한 RPC Framework&lt;/li&gt;
      &lt;li&gt;Protobuf 관리가 쉽지 않음&lt;/li&gt;
      &lt;li&gt;gRPC를 잘 좀 써보자
        &lt;ul&gt;
          &lt;li&gt;API&lt;/li&gt;
          &lt;li&gt;Pkg -&amp;gt; proto -&amp;gt; Build -&amp;gt; Dist -&amp;gt; Template&lt;/li&gt;
          &lt;li&gt;Protobuf 관리
            &lt;ul&gt;
              &lt;li&gt;API source 받아서&lt;/li&gt;
              &lt;li&gt;/proto 디렉토리에 작성&lt;/li&gt;
              &lt;li&gt;makefile 작성&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비즈니스 로직에 맞도록 진행&lt;/li&gt;
  &lt;li&gt;마이크로서비스, gRPC에 대한 깔끔한 설명을 해주셔서 좋았음&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;온라인-뉴스-댓글은-정말-사람들의-목소리일까---part2&quot;&gt;온라인 뉴스 댓글은 정말 사람들의 목소리일까? - PART2&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;이준범님&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://speakerdeck.com/beomi/pyconkr-2019-onrain-nyuseu-daesgeuleun-jeongmal-saramdeulyi-mogsoriilgga-part2&quot;&gt;발표 자료&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;데이터 크롤링 : 10분 단위&lt;/li&gt;
  &lt;li&gt;AWS 클라우드 위에서 처리&lt;/li&gt;
  &lt;li&gt;직접 데이터 수집 - 처리 - 가설 - 라벨링 등에 대해 잘 나와있음&lt;/li&gt;
  &lt;li&gt;역시 준범님!&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;더-읽은-자료&quot;&gt;더 읽은 자료&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://speakerdeck.com/codertimo/paikon-2019-100eoggeonyi-kakaotog-deiteoro-ddogddoghan-ilsangdaehwa-ingongjineung-mandeulgi&quot;&gt;100억건의 카카오톡 데이터로 똑똑한 일상대화 인공지능 만들기&lt;/a&gt; : 연구 시작 ~ 진행 과정을 잘 알려줌. NLP에 큰 흥미는 없지만 재미있게 읽을 수 있었음&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/YongseonLee1/pycon-korea-2019-rest-api-document-generation-164504789&quot;&gt;파이썬 웹서버 REST API 문서 쉽고 빠르게 작성하기&lt;/a&gt; : 언젠가 API 문서화를 고민할 때 다시 읽어보면 좋을 것 같은 문서&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://speakerdeck.com/sunghyunzz/from-banksalad-import-python&quot;&gt;from banksalad import python&lt;/a&gt; : 뱅크샐러드가 파이썬을 활용해 어떻게 발전해왔는지 알 수 있는 문서&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/YoungSeokKim8/pycon-kr-2019-pickle-custom-binary-serializer&quot;&gt;Pickle &amp;amp; Custom Binary Serializer&lt;/a&gt; : Serialize에 대해 알 수 있는 문서&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;튜토리얼-자료&quot;&gt;튜토리얼 자료&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;pytest로 파이썬 코드 테스트하기
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/ssuser80e030/pytest-164575856&quot;&gt;슬라이드쉐어&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;Tutorial 자료, pytest를 사용한 기본에 대해 잘 나와있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Python으로 지리공간데이터 다루기
    &lt;ul&gt;
      &lt;li&gt;아직 발표자료 미공개인듯. 추후 확인해보기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;행사-부스&quot;&gt;행사 부스&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;프로그래머스 구구단 구현 이벤트
    &lt;ul&gt;
      &lt;li&gt;올해는 프로그래머스 구구단 구현 이벤트에 참여함&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://nbviewer.jupyter.org/github/zzsza/funny-pycon2019/blob/master/gugudan/gugudan.ipynb&quot;&gt;코드&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;초반엔 1등했으나 마감일에 갑자기 다크호스분의 등장으로 2등
        &lt;ul&gt;
          &lt;li&gt;1등분은 파이썬 로고를 만드셔서 리스펙.. 저도 좋아요 눌렀음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;그리고 에어팟 받아서 만족 :)&lt;/li&gt;
      &lt;li&gt;오랜만에 본 광고동아리 선배님도 계셔서 반가웠음-!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스캐터랩 연애 시뮬레이션
    &lt;ul&gt;
      &lt;li&gt;쿼리와 센텐스, 감정 결과가 주어지면 어떤 답을 해야하는지 문제가 있었음&lt;/li&gt;
      &lt;li&gt;사실 약간 시도하다가 막혔지만, 영상이 매우 고퀄이라 재미있게 시도해봄&lt;/li&gt;
      &lt;li&gt;확실히 자연어쪽을 세련되게 잘 한다는 느낌을 받았음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 18 Aug 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/etc/2019/08/18/pycon2019/</link>
        <guid isPermaLink="true">http://localhost:4000/etc/2019/08/18/pycon2019/</guid>
        
        <category>lecture</category>
        
        
        <category>etc</category>
        
      </item>
    
      <item>
        <title>Discrete Optimization 입문</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Discrete Optimization 입문에 대해 작성한 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;discrete-optimization&quot;&gt;Discrete Optimization&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;냅색 문제
    &lt;ul&gt;
      &lt;li&gt;NP hard, 다루기 어려운 문제&lt;/li&gt;
      &lt;li&gt;대신 근사 알고리즘(Approximate)이 존재함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Optimization
    &lt;ul&gt;
      &lt;li&gt;컴퓨터 사이언스에서 어려운 문제중 하나&lt;/li&gt;
      &lt;li&gt;Supply chains, sport scheduling, logistics, eletrical power system, manufacturing 등에서 사용됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NP-Complete 문제의 2가지 속성
    &lt;ul&gt;
      &lt;li&gt;답을 매우 빠르게 확인할 수 있음&lt;/li&gt;
      &lt;li&gt;NP-Complete 문제 하나를 빠르게 푼다면, 모든 것을 풀 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Exponential time이 가장 worst case라고 믿음&lt;/li&gt;
  &lt;li&gt;항구
    &lt;ul&gt;
      &lt;li&gt;항구의 각각 요소가 계속 움직임 =&amp;gt; 최적화 문제&lt;/li&gt;
      &lt;li&gt;일반적으로 매일 해결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Energy
    &lt;ul&gt;
      &lt;li&gt;에너지는 load와 demand가 계속 만남&lt;/li&gt;
      &lt;li&gt;이걸 잘 매칭시키고 싶어함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Sport Scheduling
    &lt;ul&gt;
      &lt;li&gt;스포츠 스케쥴링&lt;/li&gt;
      &lt;li&gt;누가 누구랑 대결할 것인가&lt;/li&gt;
      &lt;li&gt;여러 제약조건
        &lt;ul&gt;
          &lt;li&gt;같은 경기장을 사용할 수 없음&lt;/li&gt;
          &lt;li&gt;베이스볼, 축구 등&lt;/li&gt;
          &lt;li&gt;시즌도 맞춰야 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Exponential Runtime
    &lt;ul&gt;
      &lt;li&gt;지수로 상승함&lt;/li&gt;
      &lt;li&gt;문제 사이즈가 커지면서 점점 풀리지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Optimization Problems
    &lt;ul&gt;
      &lt;li&gt;어디에나 있음&lt;/li&gt;
      &lt;li&gt;엄청나게 풀기 어려움&lt;/li&gt;
      &lt;li&gt;그러나 풀어야 함&lt;/li&gt;
      &lt;li&gt;재미있음&lt;/li&gt;
      &lt;li&gt;푸는 것이 중요함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예시
    &lt;ul&gt;
      &lt;li&gt;Kidney(신장) Exchanges
        &lt;ul&gt;
          &lt;li&gt;Basic Facts
            &lt;ul&gt;
              &lt;li&gt;우리는 1개의 신장이 필요&lt;/li&gt;
              &lt;li&gt;80,000명의 환자&lt;/li&gt;
              &lt;li&gt;미국에서 매년 4,000명이 죽음&lt;/li&gt;
              &lt;li&gt;호환 이슈가 존재&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;주는 사람, 받는 사람의 그래프가 생김
            &lt;ul&gt;
              &lt;li&gt;사이클이 생김&lt;/li&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/u2rrup6rel6tc5o/Screenshot%202019-08-12%2021.26.55.png?raw=1&quot; /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;이건 매우 작은 문제지만, 가지수가 많아지면 풀기 어려워짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Disaster Management
        &lt;ul&gt;
          &lt;li&gt;허리케인의 Damages 금액을 산정&lt;/li&gt;
          &lt;li&gt;어떤 지역에 문제가 있고, 그 이후 빠르게 복원(예를 들면 전기)&lt;/li&gt;
          &lt;li&gt;이럴 경우 정전의 크기를 줄이려고 노력하고, 빠르게 복구하고 싶음&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/t50pz8w1dta1p76/Screenshot%202019-08-12%2021.30.41.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;Routing Aspect 관점(어디부터 복구할 것인가)과 Power Flow Aspect 관점(blackout size를 줄임)&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/yxv8j5exdkk3z0x/Screenshot%202019-08-12%2021.31.56.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Coursera &lt;a href=&quot;https://www.coursera.org/learn/discrete-optimization&quot;&gt;Discrete Optimization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 13 Aug 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/data/2019/08/13/discrete-optimization-intro/</link>
        <guid isPermaLink="true">http://localhost:4000/data/2019/08/13/discrete-optimization-intro/</guid>
        
        <category>optimization</category>
        
        
        <category>data</category>
        
      </item>
    
      <item>
        <title>Python에서 Auth를 사용해 Google Spreadsheets 연동하기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Python에서 Google Spreadsheets 연동하는 방법을 작성한 글입니다&lt;/li&gt;
  &lt;li&gt;구유림님의 &lt;a href=&quot;https://yurimkoo.github.io/python/2019/07/20/link-with-googlesheets-for-Python.html&quot;&gt;gspread를 이용하여 Python에서 구글 시트 연동하기
&lt;/a&gt;에 gspread를 사용하는 방법에 대해 자세히 작성되어 있습니다 :)
    &lt;ul&gt;
      &lt;li&gt;이번 글은 Service Account Key 없이 Web Auth를 이용해 구글 시트를 연동하는 방법을 다룹니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;google-sheets&quot;&gt;Google Sheets&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사용할 라이브러리
    &lt;ul&gt;
      &lt;li&gt;gspread&lt;/li&gt;
      &lt;li&gt;pydata_google_auth&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pydata_google_auth
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://pypi.org/project/pydata-google-auth/&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;이 라이브러리는 Google API 인증을 위한 헬퍼 패키지&lt;/li&gt;
      &lt;li&gt;BigQuery를 사용할 경우에도 사용함 : [&lt;a href=&quot;https://zzsza.github.io/gcp/2019/03/17/pandas-gbq-auth/&quot;&gt;pandas-gbq에서 인증(Authentication) 설정하기&lt;/a&gt;] 참고&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;원리
    &lt;ul&gt;
      &lt;li&gt;원리는 생각보다 간단&lt;/li&gt;
      &lt;li&gt;pydata_google_auth를 통해 credentials를 생성&lt;/li&gt;
      &lt;li&gt;거기에 존재하는 access_token을 통해 gspread에 인증&lt;/li&gt;
      &lt;li&gt;단, pydata의 access_token은 &lt;code class=&quot;highlighter-rouge&quot;&gt;token&lt;/code&gt;에 저장되고 gspread는 &lt;code class=&quot;highlighter-rouge&quot;&gt;access_token&lt;/code&gt;이 필요함&lt;/li&gt;
      &lt;li&gt;이 부분을 덮어쓰는 코드 추가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;코드&quot;&gt;코드&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import pydata_google_auth
import gspread

SCOPES = [
  'https://www.googleapis.com/auth/drive',
  'https://www.googleapis.com/auth/spreadsheets'
]

credentials = pydata_google_auth.get_user_credentials(SCOPES, auth_local_webserver=True)
credentials.access_token = credentials.token

gc = gspread.authorize(credentials)

gc.list_spreadsheet_files()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;참고&quot;&gt;참고&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;한번만 인증하면 그 다음은 웹이 뜨지 않아서 왜 그런가? 하고 소스를 뜯어봄&lt;/li&gt;
  &lt;li&gt;(Mac 기준) &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.config/pydata/pydata_google_credentials.json&lt;/code&gt;에 전에 사용한 credentials를 저장하기 때문
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://pydata-google-auth.readthedocs.io/en/latest/api.html#pydata_google_auth.default&quot;&gt;공식 문서&lt;/a&gt;의 credentials_cache를 참고하면 저장함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;만약 다른 계정으로 로그인하고 싶으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;$HOME/.config/pydata/pydata_google_credentials.json&lt;/code&gt;(Mac) 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;$APPDATA/.config/pydata/pydata_google_credentials.json&lt;/code&gt;(윈도우)를 삭제&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://pydata-google-auth.readthedocs.io/en/latest/index.html&quot;&gt;pydata-google-auth 공식 문서&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://yurimkoo.github.io/python/2019/07/20/link-with-googlesheets-for-Python.html&quot;&gt;gspread를 이용하여 Python에서 구글 시트 연동하기
&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zzsza.github.io/gcp/2019/03/17/pandas-gbq-auth/&quot;&gt;pandas-gbq에서 인증(Authentication) 설정하기
&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 09 Aug 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/development/2019/08/09/spreadsheet-with-auth/</link>
        <guid isPermaLink="true">http://localhost:4000/development/2019/08/09/spreadsheet-with-auth/</guid>
        
        <category>python</category>
        
        
        <category>development</category>
        
      </item>
    
      <item>
        <title>Sacred와 Omniboard를 활용한 실험 및 로그 모니터링</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Python Sacred를 더 잘 활용하기 위해 Omniboard를 붙이는 과정을 작성한 글입니다
    &lt;ul&gt;
      &lt;li&gt;Sacred는 &lt;a href=&quot;https://zzsza.github.io/mlops/2019/07/21/python-sacred/&quot;&gt;머신러닝 실험을 도와줄 Python Sacred 소개&lt;/a&gt;를 참고하시면 좋을 것 같습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;omniboard&quot;&gt;Omniboard&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Omniboard는 머신러닝 실험 관리 도구인 Sacred를 위한 웹 대시보드&lt;/li&gt;
  &lt;li&gt;MongoDB에 연결해 Sacred의 실험, Metric, 로그를 시각화해줌&lt;/li&gt;
  &lt;li&gt;React, Node.js, Express와 Bootstrap을 사용해 만들어짐&lt;/li&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;Experiment management
        &lt;ul&gt;
          &lt;li&gt;모든 실험을 Tabular 형태로 저장&lt;/li&gt;
          &lt;li&gt;특정 컬럼을 show / hide 가능&lt;/li&gt;
          &lt;li&gt;Rolled up metric value를 컬럼으로 추가 가능(minimum validation loss, maximum training accuracy 등)&lt;/li&gt;
          &lt;li&gt;각종 실험에 Tag나 Note를 작성할 수 있음&lt;/li&gt;
          &lt;li&gt;Metric column을 제외한 모든 컬럼으로 필터 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Experiment Drill Down
        &lt;ul&gt;
          &lt;li&gt;Metric Graph를 볼 수 있음&lt;/li&gt;
          &lt;li&gt;Console Output을 보여줌&lt;/li&gt;
          &lt;li&gt;모든 런타임 라이브러리 dependencies를 보여줌&lt;/li&gt;
          &lt;li&gt;소스 파일을 보거나 다운로드 가능&lt;/li&gt;
          &lt;li&gt;Artifacts(인공 산물? 파일물?)을 보거나 다운로드 가능&lt;/li&gt;
          &lt;li&gt;호스트의 하드웨어 스펙을 볼 수 있음&lt;/li&gt;
          &lt;li&gt;Git hash/version control 정보를 볼 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;스크린샷&quot;&gt;스크린샷&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Tabular 형태의 데이터
    &lt;ul&gt;
      &lt;li&gt;Tags, 메모, 각종 파라미터 저장됨&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://raw.githubusercontent.com/vivekratnavel/omniboard/master/docs/assets/screenshots/table.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Metric Plot
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://raw.githubusercontent.com/vivekratnavel/omniboard/master/docs/assets/screenshots/metric-graphs.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Metric Column 관리
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://raw.githubusercontent.com/vivekratnavel/omniboard/master/docs/assets/screenshots/adding-metrics.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Output Log
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://raw.githubusercontent.com/vivekratnavel/omniboard/master/docs/assets/screenshots/console.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Experiment Details
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://raw.githubusercontent.com/vivekratnavel/omniboard/master/docs/assets/screenshots/experiment-details.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Host Info
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://raw.githubusercontent.com/vivekratnavel/omniboard/master/docs/assets/screenshots/host-info.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;설치&quot;&gt;설치&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;MongoDB 설치
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Mac&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  brew install mongodb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Linux(Ubuntu 16.04)&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 9DA31620334BD75D9DCB49F368818C72E52529D4
  echo &quot;deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/4.0 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-4.0.list
  sudo apt-get update
  sudo apt-get install -y mongodb-org
  echo &quot;mongodb-org hold&quot; | sudo dpkg --set-selections
  echo &quot;mongodb-org-server hold&quot; | sudo dpkg --set-selections
  echo &quot;mongodb-org-shell hold&quot; | sudo dpkg --set-selections
  echo &quot;mongodb-org-mongos hold&quot; | sudo dpkg --set-selections
  echo &quot;mongodb-org-tools hold&quot; | sudo dpkg --set-selections
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MongoDB 실행
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Mac&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  brew services start mongodb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Linux(Ubuntu 16.04)&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo service mongod start
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pymongo 설치&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pip3 install pymongo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;omniboard 설치
    &lt;ul&gt;
      &lt;li&gt;npm이 설치되어 있어야 함(Node.js v8 이후 버전)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  npm install -g omniboard
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Docker나 Docker Composer를 사용하는 방법은 &lt;a href=&quot;https://vivekratnavel.github.io/omniboard/#/quick-start?id=docker&quot;&gt;공식 문서&lt;/a&gt; 참조!&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;omniboard-실행&quot;&gt;Omniboard 실행&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;omniboard -m hostname:port:database -u username:password:secret
로 실행&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  omniboard -m localhost:27017:sacred
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Advanced connection properties를 셋팅하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;--mu&lt;/code&gt; 옵션을 사용하면 됨
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/connection-string/&quot;&gt;MongoDB connection URI&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  omniboard --mu &quot;mongodb://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;host&amp;gt;/&amp;lt;database&amp;gt;[?options]&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Omniboard 대시보드 실행
    &lt;ul&gt;
      &lt;li&gt;Omniboard is listening on port 9000! 라는 멘트가 나오면 웹브라우저에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;localhost:9000&lt;/code&gt;을 입력하면 대시보드가 실행됨&lt;/li&gt;
      &lt;li&gt;처음엔 실험을 하지 않아서 아무 창이 뜨지 않으나, 실험을 하면 하나씩 추가됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;sacred-experiment-실행&quot;&gt;Sacred Experiment 실행&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://zzsza.github.io/mlops/2019/07/21/python-sacred/&quot;&gt;머신러닝 실험을 도와줄 Python Sacred 소개&lt;/a&gt;의 예제에 있던 rf, svc 실험을 FileStorageObserver가 아닌 MongoObserver로 변경해 다시 실행함&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from sacred.observers import MongoObserver

  ex = Experiment('svc')
  ex.observers.append(MongoObserver.create(url='localhost:27017', db_name='sacred'))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그 후 Metric Plot을 그리기 위해 &lt;a href=&quot;https://github.com/maartjeth/sacred-example-pytorch&quot;&gt;Sacred Example Code Pytorch&lt;/a&gt;를 Clone 후 실행함&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git clone https://github.com/maartjeth/sacred-example-pytorch.git
  cd sacred-example-pytorch
  # train_nn.py의 DATABASE_NAME 변수를 sacred로 수정한 후 실행
  python3 train_nn.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;대시보드로 이동(localhost:9000)
    &lt;ul&gt;
      &lt;li&gt;실험 이름, Tags, 메모 등이 보임
        &lt;ul&gt;
          &lt;li&gt;Tags나 Notes는 그냥 입력하면 됨&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/wby7a3581htrrt8/Screenshot%202019-07-21%2023.09.46.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;우측엔 Result나 각종 파라미터가 저장됨
        &lt;ul&gt;
          &lt;li&gt;빈칸인 공간은 해당 실험이 그 파라미터를 사용하지 않아서!&lt;/li&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/zjgaz1r0nteqc32/Screenshot%202019-07-21%2023.10.45.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;맨 좌측의 파란색 삼각형 클릭하면 자세한 정보가 나옴
    &lt;ul&gt;
      &lt;li&gt;Metrics Plot을 보면 Steps이 지나며 loss가 감소하는 것을 볼 수 있음&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/82jq9gwatvrb02f/Screenshot%202019-07-21%2023.15.40.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Captured Out
    &lt;ul&gt;
      &lt;li&gt;Print한 로그가 나타나는 공간&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/ds4nsks9ygd2tnj/Screenshot%202019-07-21%2023.17.09.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Experiment Details
    &lt;ul&gt;
      &lt;li&gt;실험 디테일 정보가 저장되는 곳&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/uchvng4rspq77yl/Screenshot%202019-07-21%2023.17.48.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Host Info
    &lt;ul&gt;
      &lt;li&gt;OS, CPU, Python version 등을 볼 수 있음&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/gkyda7ozr1silkc/Screenshot%202019-07-21%2023.18.39.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Config
    &lt;ul&gt;
      &lt;li&gt;Config 설정값을 볼 수 있음&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/1t9rf2ewkk6zeu4/Screenshot%202019-07-21%2023.19.02.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;활용-방안&quot;&gt;활용 방안&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사용하고 있는 머신과 MongoDB를 연결해, 다양한 실험을 돌리고 Omniboard로 결과를 모니터링할 수 있음&lt;/li&gt;
  &lt;li&gt;이 문서는 local에 설치했지만, Docker를 사용해 설치하면 더 편리할 것 같음&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/IDSIA/sacred/tree/master/examples&quot;&gt;Sacred 공식 Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/maartjeth/sacred-example-pytorch/blob/master/train_nn.py&quot;&gt;Sacred-example-pytorch&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://vivekratnavel.github.io/omniboard/&quot;&gt;Omniboard Document&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 22 Jul 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/mlops/2019/07/22/sacred-with-omniboard/</link>
        <guid isPermaLink="true">http://localhost:4000/mlops/2019/07/22/sacred-with-omniboard/</guid>
        
        <category>version</category>
        
        
        <category>mlops</category>
        
      </item>
    
      <item>
        <title>머신러닝 실험을 도와줄 Python Sacred 소개</title>
        <description>&lt;ul&gt;
  &lt;li&gt;머신러닝 실험에서 사용되는 Config, Parameter 등을 더 손쉽게 저장할 수 있도록 도와주는 Python Library Sacred에 대한 글입니다
    &lt;ul&gt;
      &lt;li&gt;Sacred 대시보드 관련 내용은 &lt;a href=&quot;https://zzsza.github.io/mlops/2019/07/22/sacred-with-omniboard/&quot;&gt;Sacred와 Omniboard를 활용한 로그 모니터링&lt;/a&gt;에 작성했습니다!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;python-sacred&quot;&gt;Python Sacred&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;머신러닝을 하다보면 각종 파라미터에 따라 결과가 어떻게 나오는지 기록해야함
    &lt;ul&gt;
      &lt;li&gt;처음엔 .log 파일에 작성해두다가, 점점 방대해지는 모습을 보게됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Sacred는 환경 설정을 다시 reproduce할 수 있도록 도와주는 도구
    &lt;ul&gt;
      &lt;li&gt;실험의 모든 파라미터 추적&lt;/li&gt;
      &lt;li&gt;여러 설정에 대해 쉽게 실험을 할 수 있음&lt;/li&gt;
      &lt;li&gt;DB에 각 실행의 설정을 저장&lt;/li&gt;
      &lt;li&gt;결과를 reproduce&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Omniboard 등을 통해 저장된 값을 시각화할 수 있음
    &lt;ul&gt;
      &lt;li&gt;Omniboard란?
        &lt;ul&gt;
          &lt;li&gt;Sacred에서 저장된 파라미터를 더 쉽게 볼 수 없을까?에 대한 고민으로 시작된 프로젝트&lt;/li&gt;
          &lt;li&gt;Sacred에서 저장된 파라미터를 Table로 보여주고, 성능도 알려줌&lt;/li&gt;
          &lt;li&gt;Sacred + Omniboard 조합을 사용하는 것을 매우 추천!&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Omniboard 설치 및 실행은 &lt;a href=&quot;https://zzsza.github.io/mlops/2019/07/22/sacred-with-omniboard/&quot;&gt;Sacred와 Omniboard를 활용한 로그 모니터링&lt;/a&gt; 참고 :)&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;공식 문서에 작성된 내용&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Every experiment is sacred
  Every experiment is great
  If an experiment is wasted
  God gets quite irate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Sacred의 Main mechanisms
    &lt;ul&gt;
      &lt;li&gt;ConfigScopes : 함수의 local 변수를 편리하게 다룰 수 있음.&lt;code class=&quot;highlighter-rouge&quot;&gt;@ex.config&lt;/code&gt; 데코레이터로 사용&lt;/li&gt;
      &lt;li&gt;Config Injection : 모든 함수에 있는 설정을 접근할 수 있음&lt;/li&gt;
      &lt;li&gt;Command-line interface : 커맨드 라인으로 파라미터를 바꿔서 실행할 수 있음&lt;/li&gt;
      &lt;li&gt;Observers : 실험의 모든 정보를 Observers에게 제공해 저장함. 이것들은 MongoDB에 저장&lt;/li&gt;
      &lt;li&gt;Automatic seeding : 실험의 무작위를 컨트롤할 때 도와줌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예시
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/29dqic2lhohl60g/Screenshot 2019-07-21 14.31.20.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;설치&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pip3 install sacred
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Dependency 설치&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  pip3 install numpy, pymongo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;first-experiment&quot;&gt;First Experiment&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;샘플 코드를 통해 Sacred에 대해 알아보기
    &lt;ul&gt;
      &lt;li&gt;first_config.py 파일 생성&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from sacred import Experiment
	    
  ex = Experiment('hello_config')
  # Notebook일 경우 
  # ex = Experiment('hello_config', interactive=True)
	    
  @ex.config
  def my_config():
      recipient = &quot;world&quot;
      message = &quot;Hello %s!&quot; % recipient
	    
  @ex.automain
  def my_main(message):
      print(message)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;ex = Experiment(‘실험 이름’)
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@ex.config&lt;/code&gt;로 파라미터를 저장함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@ex.automain&lt;/code&gt; 을 사용해 command line으로 실행할 수 있도록 설정&lt;/li&gt;
      &lt;li&gt;Jupyter Notebook에선 &lt;code class=&quot;highlighter-rouge&quot;&gt;@ex.main&lt;/code&gt;을 사용하고, 실험을 만들 때 interactive=True로 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;실행&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  python3 first_config.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;터미널에서 config 출력&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; python3 first_config.py print_config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;여러번 실행하면 seed값이 달라지는 것을 알 수 있음&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/t6ygfinmwmn4vlc/Screenshot 2019-07-21 14.43.30.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Command Line에서 파라미터 injection
    &lt;ul&gt;
      &lt;li&gt;with [파라미터]=”value” 로 넣을 수 있음&lt;/li&gt;
    &lt;/ul&gt;

  	&lt;code class=&quot;highlighter-rouge&quot;&gt;
  	python3 first_config.py with recipient=&quot;that is cool&quot;
  	&lt;/code&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/llwsv70ieq1tbve/Screenshot%202019-07-21%2014.51.27.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Experiment를 import해서 실행하는 방법&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from first_config import ex
    
  r = ex.run()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Python에서 파라미터 injection
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;run할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;config_updates&lt;/code&gt; 를 설정&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from first_config import ex
		    
  r = ex.run(config_updates={'recipient': 'awesome'})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Capture Functions&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from sacred import Experiment
  ex = Experiment('my_experiment')
    
    
  @ex.config
  def my_config():
      foo = 42
      bar = 'baz'
    
    
  @ex.capture
  def some_function(a, foo, bar=10):
      print(a, foo, bar)
    
    
  @ex.automain
  def my_main():
      some_function(1, 2, 3)  # 1 2 3
      some_function(1)        # 1 42 'baz'
      some_function(1, bar=12)  # 1 42 12
      some_function()  # TypeError : missing value for 'a'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/276kmssacwu1dp5/Screenshot 2019-07-21 15.12.58.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;experiment-관찰하기&quot;&gt;Experiment 관찰하기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Experiments는 실행할 때 다양한 정보를 수집함
    &lt;ul&gt;
      &lt;li&gt;시작 시간, 중단 시간&lt;/li&gt;
      &lt;li&gt;사용된 환경 설정&lt;/li&gt;
      &lt;li&gt;발생한 에러나 결과물&lt;/li&gt;
      &lt;li&gt;머신의 기본 information&lt;/li&gt;
      &lt;li&gt;그 버전과 의존적인 패키지&lt;/li&gt;
      &lt;li&gt;import한 모든 local source files&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ex.open_resource&lt;/code&gt;로 file을 오픈하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;ex.add_artifact&lt;/code&gt;로 파일을 추가함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Observer는 MongoObserver, File Storage Observer, TinyDB Observer, SQL observer 등이 있습니다
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://sacred.readthedocs.io/en/latest/observers.html&quot;&gt;공식 문서&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MongoObserver에 연결하기&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from sacred import Experiment
  from sacred.observers import MongoObserver
    
  ex = Experiment('hello_config')
  ex.observers.append(MongoObserver.create(url='your_server:27017',
                                           db_name='My_DB'))
    
  @ex.config
  def my_config():
      recipient = &quot;world&quot;
      message = &quot;Hello %s!&quot; % recipient
    
  @ex.automain
  def my_main(message):
      print(message)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FileStorageObserver 연결하기&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from sacred import Experiment
  from sacred.observers import FileStorageObserver
  ex = Experiment('hello_config')
  ex.observers.append(FileStorageObserver.create('my_runs'))
    
  @ex.config
  def my_config():
      recipient = &quot;world&quot;
      message = &quot;Hello %s!&quot; % recipient
    
  @ex.automain
  def my_main(message):
      print(message)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Auth를 붙이고 싶은 경우 &lt;a href=&quot;https://api.mongodb.com/python/current/examples/authentication.html&quot;&gt;authentication protocol&lt;/a&gt;을 참고&lt;/li&gt;
  &lt;li&gt;Docker로 설정하고 싶은 경우 &lt;a href=&quot;https://sacred.readthedocs.io/en/latest/examples.html#docker-setup&quot;&gt;Docker Setup&lt;/a&gt; 참고&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;seed-관리&quot;&gt;Seed 관리&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Automatic Seed&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  python3 first_config.py with seed=123
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Global Seed
    &lt;ul&gt;
      &lt;li&gt;글로벌 시드 random, np.random이 설정되있는 경우 그걸 자동으로 설정&lt;/li&gt;
      &lt;li&gt;main 함수 안에서 수동으로 seed를 설정하면 모두 적용됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Special Arguments
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_rnd&lt;/code&gt; 와 &lt;code class=&quot;highlighter-rouge&quot;&gt;_seed&lt;/code&gt;  인자를 통해 random number를 생성할 수 있음&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  @ex.capture
  def do_random_stuff(_rnd, _seed):
      print(_seed)
      print(_rnd.randint(1, 100))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;logging&quot;&gt;Logging&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Sacred는 Python logging 모듈을 사용해 정보를 저장함&lt;/li&gt;
  &lt;li&gt;Command Line에서 실행할 때 -l ERROR 를 추가해 실행하면 ERROR 아래 로그를 출력하지 않음
    &lt;ul&gt;
      &lt;li&gt;CRITICAL, ERROR, WARNING, INFO, DEBUG 등이 있음&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/him64bdm46dr3vk/Screenshot 2019-07-21 15.50.54.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Experiment에 로그 추가하기
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;실험에 로그를 추가하고 싶을 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;_log&lt;/code&gt; 인자를 사용해 로그를 추가할 수 있음&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from sacred import Experiment
  from sacred.observers import FileStorageObserver
  ex = Experiment('hello_config')
  ex.observers.append(FileStorageObserver.create('my_runs'))
        
  @ex.config
  def my_config():
      recipient = &quot;world&quot;
      message = &quot;Hello %s!&quot; % recipient
        
  @ex.capture
  def some_function(_log):
      _log.info('Custom Info message!')
        
  @ex.automain
  def my_main(message):
      some_function()
      print(message)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Logger 커스텀하기
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Logger를 커스텀하고 싶은 경우, experiment 정의한 후, logger를 재정의하면 됨&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # custom_logger.py
  import logging
  from sacred import Experiment
        
  ex = Experiment('log_example')
        
  # set up a custom logger
  logger = logging.getLogger('mylogger')
  logger.handlers = []
  ch = logging.StreamHandler()
  formatter = logging.Formatter('[%(levelname).1s] %(name)s &amp;gt;&amp;gt; &quot;%(message)s&quot;')
  ch.setFormatter(formatter)
  logger.addHandler(ch)
  logger.setLevel('INFO')
        
  ex.logger = logger
        
  @ex.config
  def my_config():
      recipient = &quot;world&quot;
      message = &quot;Hello %s!&quot; % recipient
        
  @ex.capture
  def some_function(_log):
      _log.info('Custom Info message!')
        
  @ex.automain
  def my_main(message):
      some_function()
      print(message)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;실행&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  python3 custom_logger.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;img src=&quot;https://www.dropbox.com/s/u6dmhkckvb3c6ho/Screenshot 2019-07-21 16.03.17.png?raw=1&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ingredients&quot;&gt;Ingredients&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;어떤 Task는 다양한 실험을 실행해야 할 수 있음&lt;/li&gt;
  &lt;li&gt;코드 중복을 피하는 방법은 함수를 추출해 가져오는 것
    &lt;ul&gt;
      &lt;li&gt;이런 작업을 구성해야 하면 구성 값을 모든 실험에 복사해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Ingredients는 연관된 함수의 설정을 정의하고 다른 실험에 재사용할 수 있는 방법
    &lt;ul&gt;
      &lt;li&gt;특정 hook을 사용해 실험을 실행시킬 수도 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;예제&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from sacred import Ingredient, Experiment
    
  # ================== Dataset Ingredient =======================================
  # could be in a separate file
    
  data_ingredient = Ingredient('dataset')
    
    
  @data_ingredient.config
  def cfg1():
      filename = 'my_dataset.npy'  
      normalize = True 
    
    
  @data_ingredient.capture
  def load_data(filename, normalize):
      print(&quot;loading dataset from '{}'&quot;.format(filename))
      if normalize:
          print(&quot;normalizing dataset&quot;)
          return 1
      return 42
    
    
  @data_ingredient.command
  def stats(filename, foo=12):
      print('Statistics for dataset &quot;{}&quot;:'.format(filename))
      print('mean = 42.23')
      print('foo=', foo)
    
    
  # ================== Experiment ===============================================
    
  @data_ingredient.config
  def cfg2():
      filename = 'foo.npy'
  # 이 config가 덮어쓰기됨
    
  # add the Ingredient while creating the experiment
  ex = Experiment('my_experiment', ingredients=[data_ingredient])
    
  @ex.config
  def cfg3():
      a = 12
      b = 42
    
  @ex.named_config
  def fbb():
      a = 22
      dataset = {&quot;filename&quot;: &quot;AwwwJiss.py&quot;}
    
  @ex.automain
  def run():
      data = load_data()  
  		# foo.npy
      print('data={}'.format(data))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;custom-command&quot;&gt;Custom command&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Command 실행에 따라 다른 함수가 실행되도록 할 수 있음
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@ex.command&lt;/code&gt; 로 함수를 감싸주면 됨&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # my_command.py
  from sacred import Experiment
        
  ex = Experiment('my_commands')
        
        
  @ex.config
  def cfg():
      name = 'kyle'
        
        
  @ex.command
  def greet(name):
      print('Hello {}! Nice to greet you!'.format(name))
        
        
  @ex.command
  def shout():
      print('WHAZZZUUUUUUUUUUP!!!????')
        
        
  @ex.automain
  def main():
      print('This is just the main command. Try greet or shout.')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;실행&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  python3 my_command.py greet
  # Hello kyle! Nice to greet you!
        
  python3 my_command.py shout
  # WHAZZZUUUUUUUUUUP!!!????
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;실전-적용&quot;&gt;실전 적용&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;위에서 나온 Sacred 예제는 모두 공식 홈페이지를 참고했는데, 이번엔 직접 머신러닝 예제를 구현
    &lt;ul&gt;
      &lt;li&gt;코드는 &lt;a href=&quot;https://github.com/zzsza/TIL/tree/master/python/sacred/actual_use&quot;&gt;Github&lt;/a&gt;에 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Folder Structure&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ├── experiments : 실험 스크립트가 존재하는 폴더
  │   ├── random_forest.py
  │   └── svc.py
  └── main.py : 실험을 실행하는 main.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;random_forest.py&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from sklearn import datasets, model_selection
  from sklearn.ensemble import RandomForestClassifier
  from sacred import Experiment
  from sacred.observers import FileStorageObserver
  from sklearn import metrics
    
  ex = Experiment('rf')
  ex.observers.append(FileStorageObserver.create('my_runs'))
    
    
  @ex.config
  def cfg():
      n_estimators=100
      seed = 42
    
    
  @ex.capture
  def get_model(n_estimators):
      return RandomForestClassifier(n_estimators)
    
    
  @ex.automain
  def run(_log):
      X, y = datasets.load_breast_cancer(return_X_y=True)
      _log.info(&quot;[INFO] Now split dataset in RF&quot;)
      X_train, X_test, y_train, y_test = model_selection.train_test_split(X, y, test_size=0.2)
      clf = get_model()
      clf.fit(X_train, y_train)
      y_pred = clf.predict(X_test)
      _log.info(&quot;[INFO] End Predict!&quot;)
    
      return metrics.accuracy_score(y_test, y_pred)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;svc.py&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from sklearn import svm, datasets, model_selection
  from sacred import Experiment
  from sacred.observers import FileStorageObserver
    
  ex = Experiment('svc')
  ex.observers.append(FileStorageObserver.create('my_runs'))
    
    
  @ex.config
  def cfg():
      C = 1.0
      gamma = 0.7
      kernel = &quot;rbf&quot;
      seed = 42
    
    
  @ex.capture
  def get_model(C, gamma, kernel):
      return svm.SVC(C=C, kernel=kernel, gamma=gamma)
    
    
  @ex.automain
  def run(_log):
      X, y = datasets.load_breast_cancer(return_X_y=True)
      _log.info(&quot;[INFO] Now split dataset&quot;)
      X_train, X_test, y_train, y_test = model_selection.train_test_split(X, y, test_size=0.2)
      clf = get_model()
      clf.fit(X_train, y_train)
      _log.info(&quot;[INFO] End Fit!&quot;)
      return clf.score(X_test, y_test)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;main.py&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  from experiments.random_forest import ex as rf_ex
  from experiments.svc import ex as svc_ex
    
  rf_run = rf_ex.run()
  print(rf_run.config)
  print(rf_run.result)
  print(rf_run.info.keys())
  print(&quot;New experiment run!&quot;)
  rf_run2 = rf_ex.run(config_updates={&quot;n_estimators&quot;: 10})
  print(rf_run2.config)
  print(rf_run2.result)
    
  svc_run = svc_ex.run()
  print(svc_run.config)
  print(svc_run.result)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;실행&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  python3 main.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/x80agaw90m018ig/Screenshot 2019-07-21 17.25.00.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Metric
    &lt;ul&gt;
      &lt;li&gt;_run.log_scalar(metric_name, value, step) 이런식으로 metric을 생성해 추가할 수 있음
        &lt;ul&gt;
          &lt;li&gt;자세한 내용은 &lt;a href=&quot;https://sacred.readthedocs.io/en/latest/collected_information.html#metrics-api&quot;&gt;Metrics API&lt;/a&gt; 참고&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 글은 Omniboard와 연결해 설정 및 파라미터 시각화 하는 방법에 대해 소개하겠습니다 :)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/IDSIA/sacred/tree/master/examples&quot;&gt;Sacred 공식 Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;많은 실험을 저장해 사용한 예제는 &lt;a href=&quot;https://github.com/gereleth/kaggle-telstra&quot;&gt;Kaggle telstra Github&lt;/a&gt; 참고&lt;/li&gt;
  &lt;li&gt;Pytorch에서 사용한 예제는 &lt;a href=&quot;https://github.com/maartjeth/sacred-example-pytorch/blob/master/train_nn.py&quot;&gt;Github&lt;/a&gt; 참고&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/AAbercrombie0492/Sacred_Deep_Learning&quot;&gt;Sacred_Deep_Learning&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 21 Jul 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/mlops/2019/07/21/python-sacred/</link>
        <guid isPermaLink="true">http://localhost:4000/mlops/2019/07/21/python-sacred/</guid>
        
        <category>version</category>
        
        
        <category>mlops</category>
        
      </item>
    
      <item>
        <title>Google Spreadsheets(Sheets)에서 BigQuery 사용하기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;스프레드시트에서 BigQuery를 사용해 데이터를 추출하는 방법에 대해 작성한 글입니다
    &lt;ul&gt;
      &lt;li&gt;OWOX를 사용하는 방법&lt;/li&gt;
      &lt;li&gt;Data Connectors를 사용하는 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;bigquery&quot;&gt;BigQuery&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;BigQuery는 Google Cloud Platform의 Data Warehouse 제품&lt;/li&gt;
  &lt;li&gt;관련된 내용은 &lt;a href=&quot;https://www.slideshare.net/zzsza/bigquery-147073606&quot;&gt;BigQuery의 모든 것&lt;/a&gt; 발표 자료에 많이 나와있음&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;spreadsheet&quot;&gt;Spreadsheet&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;스프레드시트는 구글의 제품으로 우리가 친숙한 엑셀과 비슷한 구조를 가지고 있음&lt;/li&gt;
  &lt;li&gt;스프레드시트에서 간단한 시각화, 피벗 테이블 등 데이터를 가공할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;bigquery--spreadsheet&quot;&gt;BigQuery + Spreadsheet&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;매일 특정 쿼리를 날려 데이터를 추출하고 싶을 경우 BigQuery의 스케쥴 쿼리를 사용하거나, Python를 사용해 데이터를 추출할 수 있음
    &lt;ul&gt;
      &lt;li&gt;개발에 친화적인 사람이라면 위 방법도 편리하지만, 개발에 친화적이지 않은 사람들은 스프레드시트를 사용하는 방법이 더 친숙&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2가지 방법
    &lt;ul&gt;
      &lt;li&gt;OWOX를 사용하는 방법 (부가기능, Add-ons)&lt;/li&gt;
      &lt;li&gt;Data Connectors를 사용하는 방법
        &lt;ul&gt;
          &lt;li&gt;G Suite Business 고객만 사용할 수 있음&lt;/li&gt;
          &lt;li&gt;결과를 10,000행까지 받을 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;owox-사용-방법&quot;&gt;OWOX 사용 방법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1) 스프레드시트에서 부가기능(Add-ons) 추가
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;sheet.new&quot;&gt;sheet.new&lt;/a&gt;로 새로운 스프레드시트로 접속한 후, 상단의 부가기능을 클릭&lt;/li&gt;
      &lt;li&gt;부가기능 검색창에 &lt;code class=&quot;highlighter-rouge&quot;&gt;OWOX&lt;/code&gt;를 검색&lt;/li&gt;
      &lt;li&gt;&lt;img width=&quot;1015&quot; alt=&quot;스크린샷 2019-07-20 13 52 39&quot; src=&quot;https://user-images.githubusercontent.com/18207755/61578383-15dc0a00-ab31-11e9-8c99-a152de0f8baa.png&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;OWOX BI BigQuery Reports의 오른쪽에 있는 추가 버튼 클릭(+ 무료)&lt;/li&gt;
      &lt;li&gt;&lt;img width=&quot;1010&quot; alt=&quot;스크린샷 2019-07-20 13 53 15&quot; src=&quot;https://user-images.githubusercontent.com/18207755/61578387-23918f80-ab31-11e9-9f5c-b5c2fe1bba66.png&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;Google 로그인 후, OWOX BI BigQuery Reports이(가) 내 Google 계정에 액세스하려고 합니다 라는 부분에서 허용을 클릭
        &lt;ul&gt;
          &lt;li&gt;만약 BigQuery API가 활성화되어 있지 않다면 확인창이 추가로 뜨는데, 확인 누르면 됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2) 부가기능 활성화
    &lt;ul&gt;
      &lt;li&gt;스프레드시트에서 부가기능 - 부가기능 관리 클릭&lt;/li&gt;
      &lt;li&gt;부가기능 - OWOX BI BigQuery Reports이 보인는지 확인&lt;/li&gt;
      &lt;li&gt;&lt;img width=&quot;854&quot; alt=&quot;스크린샷 2019-07-20 13 55 18&quot; src=&quot;https://user-images.githubusercontent.com/18207755/61578394-49b72f80-ab31-11e9-8fc6-bf8273e8f5ab.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3) 쿼리 날리기(=데이터 추출하기)
    &lt;ul&gt;
      &lt;li&gt;부가기능 - OWOX BI BigQuery Reports - Add a report 클릭&lt;/li&gt;
      &lt;li&gt;&lt;img width=&quot;647&quot; alt=&quot;스크린샷 2019-07-20 20 06 17&quot; src=&quot;https://user-images.githubusercontent.com/18207755/61578399-52a80100-ab31-11e9-912c-7a1eb28be497.png&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;create 클릭&lt;/li&gt;
      &lt;li&gt;&lt;img width=&quot;848&quot; alt=&quot;스크린샷 2019-07-20 20 08 11&quot; src=&quot;https://user-images.githubusercontent.com/18207755/61578400-53d92e00-ab31-11e9-829d-ab9534b9838e.png&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;이 부분에 쿼리를 작성! 단, 쿼리를 작성할 때 #stadardSQL인지 #legacySQL인지 명시해줘야 함&lt;/li&gt;
      &lt;li&gt;Save &amp;amp; Run 클릭&lt;/li&gt;
      &lt;li&gt;결과가 스프레드시트의 새로운 시트로 저장됨&lt;/li&gt;
      &lt;li&gt;쿼리의 결과를 Report라고 부름&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4) 쿼리 수정하기
    &lt;ul&gt;
      &lt;li&gt;Select a query에 있는 쿼리를 선택한 후 Edit 클릭해 수정할 수 있음&lt;/li&gt;
      &lt;li&gt;Revision history를 확인하면 예전에 사용한 쿼리를 볼 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;5) 파라미터 설정하기
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://support.owox.com/hc/en-us/articles/217491007=no_parameters&quot;&gt;How to add parameters?&lt;/a&gt;를 클릭하면 파라미터를 동적으로 사용하는 방법에 대해 알려줌&lt;/li&gt;
      &lt;li&gt;Input 입력하는 방식, 날짜를 선택하는 방식, 리스트에서 선택하는 방식이 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;6) 이미 작성된 레포트를 수정하고 싶은 경우
    &lt;ul&gt;
      &lt;li&gt;Edit current report 클릭 후 수정&lt;/li&gt;
      &lt;li&gt;&lt;img width=&quot;945&quot; alt=&quot;스크린샷 2019-07-20 21 20 29&quot; src=&quot;https://user-images.githubusercontent.com/18207755/61578574-42ddec00-ab34-11e9-800b-a9639781834d.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;7) 데이터를 최신화하고 싶은 경우
    &lt;ul&gt;
      &lt;li&gt;Refresh currernt report 클릭 (현재 레포트만 수정)&lt;/li&gt;
      &lt;li&gt;Refresh all reports 클릭 (모든 레포트 수정)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;8) 쿼리를 주기적으로 돌리고 싶은 경우(스케쥴링)
    &lt;ul&gt;
      &lt;li&gt;Schedule reports 클릭&lt;/li&gt;
      &lt;li&gt;Enable reports to run automatically 클릭&lt;/li&gt;
      &lt;li&gt;Schedule reports to run &lt;code class=&quot;highlighter-rouge&quot;&gt;every day&lt;/code&gt; between &lt;code class=&quot;highlighter-rouge&quot;&gt;4 am - 5am&lt;/code&gt; 에서 빈도와 시간대를 설정
        &lt;ul&gt;
          &lt;li&gt;이 시간대는 스프레드시트의 시간대에 따라 달라지는데, 파일 - 스프레드시트 설정을 통해 현재 스프레드시트의 시간대를 확인할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Execute all configured reports 클릭을 해제하면 여러 Report 중 어떤 것을 스케쥴링할지 선택할 수 있음&lt;/li&gt;
      &lt;li&gt;Receive email notification을 실패할 때 메일 받거나 매번 메일을 받는 옵션을 설정할 수 있음&lt;/li&gt;
      &lt;li&gt;I understand Google BigQuery query pricing policy를 체크해야 함
        &lt;ul&gt;
          &lt;li&gt;BigQuery는 쿼리를 날릴 때마다 비용이 부과되기 때문에 이 점을 꼭 유의해야함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;img width=&quot;694&quot; alt=&quot;스크린샷 2019-07-20 20 44 37&quot; src=&quot;https://user-images.githubusercontent.com/18207755/61578584-6acd4f80-ab34-11e9-8fbe-540977afa47b.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;data-connector-사용-방법&quot;&gt;Data Connector 사용 방법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;이건 일반 계정에선 보이지 않고 G Suite Business를 사용하는 계정에서만 보임(19.7.20 기준이며, 추후에 변경될 수 있습니다)&lt;/li&gt;
  &lt;li&gt;1) 데이터 연결
    &lt;ul&gt;
      &lt;li&gt;데이터 - 데이터 커넥터 클릭&lt;/li&gt;
      &lt;li&gt;&lt;img width=&quot;734&quot; alt=&quot;스크린샷 2019-07-20 20 46 45&quot; src=&quot;https://user-images.githubusercontent.com/18207755/61578408-5dfb2c80-ab31-11e9-9691-864facacc5ff.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2) 쿼리 날리기(=데이터 추출하기)
    &lt;ul&gt;
      &lt;li&gt;데이터 연결할 프로젝트 선택한 후, 쿼리 작성 클릭&lt;/li&gt;
      &lt;li&gt;&lt;img width=&quot;871&quot; alt=&quot;스크린샷 2019-07-20 20 49 21&quot; src=&quot;https://user-images.githubusercontent.com/18207755/61578407-5dfb2c80-ab31-11e9-84e7-df1e7f1f2460.png&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;결과 미리보기를 진행한 후, 결과 삽입을 클릭하면 데이터가 추가됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3) 쿼리 수정
    &lt;ul&gt;
      &lt;li&gt;데이터 하단에 있는 새로고침이나 버튼을 클릭하면 수정할 수 있음&lt;/li&gt;
      &lt;li&gt;&lt;img width=&quot;680&quot; alt=&quot;스크린샷 2019-07-20 20 51 19&quot; src=&quot;https://user-images.githubusercontent.com/18207755/61578409-5e93c300-ab31-11e9-9d04-9c274c1827e5.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;뭘-사용할까&quot;&gt;뭘 사용할까?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;취향의 차이가 존재할 수 있으나 아직(19.07.20 기준) OWOX가 조금 더 기능이 우세(스케쥴링 기능, 메일 전송)&lt;/li&gt;
  &lt;li&gt;Data Connector는 추출할 Row 수가 아직 최대 10,000개까지만 가능한 점이 아쉬움(OWOX는 메모리 상황에 따라 다르지만 10,000개 이상도 가능)
    &lt;ul&gt;
      &lt;li&gt;또한 Data Connector는 G Suite를 사용해야 생기는 기능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;따라서 보통의 경우엔 OWOX를 사용하는 것을 추천드립니다 :)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/blog/products/g-suite/connecting-bigquery-and-google-sheets-to-help-with-hefty-data-analysis&quot;&gt;Connecting BigQuery and Google Sheets to help with hefty data analysis&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.sheetgo.com/google-sheets-features/bigquery-data-connector-get-more-than-10000-rows/&quot;&gt;BigQuery Data Connector for Google Sheets: how to get more than 10,000 rows&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 20 Jul 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/gcp/2019/07/20/bigquery-with-spreadsheet/</link>
        <guid isPermaLink="true">http://localhost:4000/gcp/2019/07/20/bigquery-with-spreadsheet/</guid>
        
        <category>BigQuery</category>
        
        
        <category>gcp</category>
        
      </item>
    
      <item>
        <title>Google Cloud Functions과 Cloud Scheduler를 사용해 Python 스크립트 주기적으로 실행하기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;Google Cloud Functions과 Cloud Scheduler를 사용해 Python 스크립트를 주기적으로 실행하는 방법에 대해 설명한 글입니다&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sdk/install?authuser=2&amp;amp;hl=ko&quot;&gt;Google Cloud SDK&lt;/a&gt;를 설치한 후 아래 글을 읽어주세요&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;사용할-도구&quot;&gt;사용할 도구&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Cloud Functions으로 함수를 클라우드에 올리고, 그 함수를 Cloud Scheduler로 주기적으로 돌릴 예정&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/functions/&quot;&gt;Google Cloud Functions&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;클라우드에서 코드를 간단히 실행할 수 있음&lt;/li&gt;
      &lt;li&gt;AWS의 Lambda와 유사함&lt;/li&gt;
      &lt;li&gt;과거엔 자바스크립트(Node.js 런타임)만 있었으나, 최근에 Go(1.11), Python(3.7)도 추가됨 : 2019년 7월 6일 기준&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/functions/docs/writing/http?hl=ko&quot;&gt;HTTP 함수&lt;/a&gt;와 &lt;a href=&quot;https://cloud.google.com/functions/docs/writing/background?hl=ko&quot;&gt;백그라운드 함수&lt;/a&gt;로 나뉨
        &lt;ul&gt;
          &lt;li&gt;전자는 HTTP를 통해 함수를 직접 호출&lt;/li&gt;
          &lt;li&gt;후자는 Google Cloud Pub/Sub의 메세지 또는 Google Cloud Storage 버킷의 변경 사항을 통해 Cloud Functions를 간접적으로 호출&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;가격은 호출 횟수, 코드가 실행되는 컴퓨팅 리소스 사용 시간, 네트워크 사용량에 따라 결정되며 무료 사용량은 월 200만회까지 무료, 리소스 사용은 메모리는 400,000GB-seconds, 컴퓨팅 시간은 200,000 GHz까지 무료이며 자세한 내용은 &lt;a href=&quot;https://cloud.google.com/functions/pricing&quot;&gt;Pricing 문서&lt;/a&gt; 참고&lt;/li&gt;
      &lt;li&gt;Reference 코드를 보고싶은 경우엔 &lt;a href=&quot;https://github.com/GoogleCloudPlatform/python-docs-samples/tree/master/functions&quot;&gt;python-docs-samples&lt;/a&gt; 참고&lt;/li&gt;
      &lt;li&gt;용도
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/xbka8brnlf1w23h/Screenshot%202019-07-06%2000.51.11.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/scheduler/&quot;&gt;Cloud Scheduler&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;App Engine 트리거, Pub/Sub을 통해 메세지 보내기, Compute Engine에 HTTP 엔드포인트 호출 등 다양하게 가능&lt;/li&gt;
      &lt;li&gt;crontab보다 쉽게 사용 가능&lt;/li&gt;
      &lt;li&gt;AWS의 클라우드 워치와 유사&lt;/li&gt;
      &lt;li&gt;월 3개의 Job까지 무료(횟수가 아니고 Job의 개수에 비용 부과 : Job이 20번 돌아도 상관 없음)&lt;/li&gt;
      &lt;li&gt;단, 기본적으로 1분에 최대 60개의 Cron이 가능하고 하루 최대 만건의 CronJob 실행이 가능한데 더 필요할 경우 Quota Request를 해두면 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;작업-흐름&quot;&gt;작업 흐름&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Cloud Functions 포맷에 맞게 Python으로 함수를 만든다&lt;/li&gt;
  &lt;li&gt;Cloud Functions에 배포한다&lt;/li&gt;
  &lt;li&gt;Cloud Scheduler에서 주기적으로 Cloud Functions의 함수를 실행시킨다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;hello-world&quot;&gt;Hello World&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;우선 아무것도 모르는 상태에서 Hello World를 찍어보며 진행하겠습니다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;main.py 작성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  def hello_world(request):
      return 'Hello, World!\n'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배포&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud beta functions deploy hello_world --runtime python37 --trigger-http
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;배포시 아래 메세지가 나타남
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/edzm4hod0fbds1b/Screenshot%202019-07-06%2001.24.03.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://console.cloud.google.com/functions/&quot;&gt;Cloud Functions Console&lt;/a&gt;에서 확인해보면 아래와 같이 배포된 것을 알 수 있음
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/moxbvlof7uhnklz/Screenshot%202019-07-06%2001.27.28.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최근 배포 시간 우측의 세로로 3개의 점을 클릭한 후, 함수 테스트 클릭하면 아래와 같이 나옴
    &lt;ul&gt;
      &lt;li&gt;함수 테스트 버튼을 통해 테스트 가능&lt;/li&gt;
      &lt;li&gt;위에서 배포를 한번 더 진행해서 버전: 2로 나옴&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/9s32qljoszgfhpy/Screenshot%202019-07-06%2001.32.34.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;python으로-cloud-functions-만들기&quot;&gt;Python으로 Cloud Functions 만들기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;간단하게 로컬에서 파이썬 스크립트를 만든 후, gcloud functions를 사용해서 올리면 끝!&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Python에서 함수를 만들 경우엔 아래와 같은 구조로 생성&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  folder/
  ├── main.py : main.py 아래에 있는 함수를 Cloud Functions에서 사용 가능
  └── requirements.txt : 설치할 패키지
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;만약 개인이 만든 패키지도 같이 올리고 싶은 경우&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  folder/
  ├── main.py
  ├── requirements.txt 	
  └── mypackage/
      ├── __init__.py
      └── myscript.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Cloud Functions의 Python 3 Runtime에 설치된 시스템 패키지는 &lt;a href=&quot;https://cloud.google.com/functions/docs/reference/python-system-packages?hl=ko&quot;&gt;링크&lt;/a&gt;를 참고하면 알 수 있음 : git, wget 등이 설치되어 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;cloud-functions-배포하기&quot;&gt;Cloud Functions 배포하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;배포는 다양한 방식이 존재하는데 크게 아래와 같이 나눌 수 있음
    &lt;ul&gt;
      &lt;li&gt;1) 로컬에서 파일을 업로드한 후, 배포하는 경우&lt;/li&gt;
      &lt;li&gt;2) Github나 Bitbucket 같은 소스 저장소의 코드를 배포하는 경우&lt;/li&gt;
      &lt;li&gt;두 방법 모두 gcloud 도구를 사용할 예정이며, 콘솔에서 진행하고 싶으면 &lt;a href=&quot;https://cloud.google.com/functions/docs/deploying/console?hl=ko&quot;&gt;Console 문서&lt;/a&gt; 참고&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;여기선 1) 위주로 진행&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gcloud 명령어 구조&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud beta functions deploy &amp;lt;NAME&amp;gt; &amp;lt;TRIGGER&amp;gt; --stage-bucket &amp;lt;STORAGE_BUCKET&amp;gt; --entry-point &amp;lt;FUNCTION_NAME&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;NAME&gt; : Cloud Functions의 이름으로 문자, 숫자, 밑줄, 하이프만 포함할 수 있음. entry-point 옵션을 지정하지 않는한 모듈에서 같은 이름의 함수를 내보내야 함
&lt;/NAME&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;TRIGGER&gt; : 트리거의 종류로, 자세한 내용은 [링크](https://cloud.google.com/functions/docs/calling/?hl=ko) 참고. `--trigger-http`, `--trigger-topic`, `--trigger-bucket`, `--trigger-event`, `--trigger-resource` 등이 있음
&lt;/TRIGGER&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--stage-bucket&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;--entry-point&lt;/code&gt;는 선택적 인자! (없어도 상관 없음)
        &lt;ul&gt;
          &lt;li&gt;–stage-bucket : 함수의 코드를 저장하는 Google Storage 버킷. 이 인자를 생략할 경우 별도의 storage에 저장해서 활용&lt;/li&gt;
          &lt;li&gt;–entry-point : 배포시 사용하는 &lt;NAME&gt;과 다른 이름을 가지는 경우 사용&lt;/NAME&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;그 외에도 &lt;code class=&quot;highlighter-rouge&quot;&gt;--allow-unauthenticated&lt;/code&gt; 등의 인자도 있음&lt;/li&gt;
      &lt;li&gt;더 자세한 명령어는 &lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/beta/functions/deploy?hl=ko&quot;&gt;gcloud beta functions deploy 링크&lt;/a&gt; 참고&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예시
    &lt;ul&gt;
      &lt;li&gt;위에서 처음 진행할 때 사용한 코드&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud beta functions deploy helloworld --trigger-http
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;entry point를 지정한 경우
        &lt;ul&gt;
          &lt;li&gt;Cloud Functions의 이름은 hello고, 함수 사용시엔 helloworld라는 이름으로 사용함
            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud beta functions deploy hello --entry-point helloworld --trigger-http
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;cloud-scheduler로-주기적으로-실행하기&quot;&gt;Cloud Scheduler로 주기적으로 실행하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;콘솔에서 &lt;a href=&quot;https://console.cloud.google.com/cloudscheduler?project=geultto&quot;&gt;Cloud Scheduler&lt;/a&gt;로 이동&lt;/li&gt;
  &lt;li&gt;작업 만들기 클릭
    &lt;ul&gt;
      &lt;li&gt;지역 설정. Cloud Functions에서 만든 Region과 동일하게 설정
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/6r1xu8dybcvdocy/Screenshot%202019-07-06%2011.56.06.png?raw=1&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;작업 만들기
        &lt;ul&gt;
          &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/r4pwhx154havkm7/Screenshot%202019-07-06%2012.00.03.png?raw=1&quot; /&gt;&lt;/li&gt;
          &lt;li&gt;빈도는 crontab 형식으로 작성&lt;/li&gt;
          &lt;li&gt;시간대는 기준 시간대를 설정. 대한민국도 존재&lt;/li&gt;
          &lt;li&gt;대상에 HTTP를 설정&lt;/li&gt;
          &lt;li&gt;Cloud Functions에서 나온 URL을 입력
            &lt;ul&gt;
              &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/tki7pepqbvtvaez/Screenshot%202019-07-06%2012.01.02.png?raw=1&quot; /&gt;&lt;/li&gt;
              &lt;li&gt;예시 : https://us-central1-{project}.cloudfunctions.net/{entry_point}&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Body가 필요하면 작성한 후, 만들기&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;생성한 후, Cloud Scheduler 화면을 보면 아래와 같이 스케쥴 Job들이 나타남
    &lt;ul&gt;
      &lt;li&gt;&lt;img src=&quot;https://www.dropbox.com/s/gy7v6bbdsvqvxfn/Screenshot%202019-07-06%2012.04.20.png?raw=1&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gcloud로도 가능한데, &lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/beta/scheduler/jobs/create/http&quot;&gt;gcloud beta scheduler jobs create http&lt;/a&gt;를 참고하면 볼 수 있음&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gcloud beta scheduler jobs create http
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;앞으로-고민할-내용들&quot;&gt;앞으로 고민할 내용들&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;앞에서 진행한 Cloud Functions는 앞에 인증하는 과정이 없기 때문에 아무나 request할 수 있음. 이 점은 실제 서비스엔 치명적이기 때문에 보안을 신경써야 함
    &lt;ul&gt;
      &lt;li&gt;AWS에선 GATEWAY를 사용해 API_KEY 값을 같이 물고 들어가는 방식으로 사용했는데, 아직 Cloud Functions는 그런 작업이 잘 발달하지 않고, 레퍼런스도 적은 느낌(제가 잘못 알고있다면 제보 부탁드립니다!)&lt;/li&gt;
      &lt;li&gt;Firebase를 사용하는 예시가 있긴한데, 굳이? 라는 생각이 들고, Cloud Endpoints 를 사용한다는 말도 있는데, Python 예제는 거의 없음&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://medium.com/google-cloud/wrapping-google-cloud-functions-http-triggers-in-endpoints-666e141e5e3b&quot;&gt;Wrapping Google Cloud Functions HTTP Triggers in Endpoints&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CloudSQL를 어떻게 연결할 수 있는지?
    &lt;ul&gt;
      &lt;li&gt;우선 &lt;a href=&quot;https://cloud.google.com/functions/docs/sql?hl=ko&quot;&gt;공식 문서&lt;/a&gt;에 나와있긴 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Terraform을 사용해 인프라를 코드로 관리&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/GoogleCloudPlatform/python-docs-samples/tree/master/functions&quot;&gt;Python-docs-samples Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/functions/docs/&quot;&gt;Cloud Functions 공식 Document&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/calmlake79/serverless-architecture-with-cloud-function&quot;&gt;Serverless Architecture with Cloud Function&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cloud.google.com/scheduler/docs/start-and-stop-compute-engine-instances-on-a-schedule&quot;&gt;Cloud 스케줄러로 Compute 인스턴스 예약하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://rominirani.com/google-cloud-functions-tutorial-using-the-cloud-scheduler-to-trigger-your-functions-756160a95c43&quot;&gt;Google Cloud Functions Tutorial : Using the Cloud Scheduler to trigger your functions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 07 Jul 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/gcp/2019/07/07/google-cloud-functions-python/</link>
        <guid isPermaLink="true">http://localhost:4000/gcp/2019/07/07/google-cloud-functions-python/</guid>
        
        <category>cloud-functions</category>
        
        
        <category>gcp</category>
        
      </item>
    
      <item>
        <title>2019년 상반기 회고 및 글또 3기 시작</title>
        <description>&lt;ul&gt;
  &lt;li&gt;2019년 상반기 회고 및 글또 3기에 대한 생각을 담은 글입니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;2019년--저번-회고-리뷰&quot;&gt;2019년 + 저번 회고 리뷰&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;2019년이 되고 30살이다! 라고 생각하던게 엊그제 같은데, 벌써 절반이 끝났습니다. 시간이 정말 너무 빠른 것 같아요&lt;/li&gt;
  &lt;li&gt;특히 상반기는 더 더 더 빠르게 지나간 것 같습니다&lt;/li&gt;
  &lt;li&gt;회고에 앞서 저번 회고엔 어떤 내용을 작성했는지 &lt;a href=&quot;https://zzsza.github.io/diary/2018/12/22/2018-retrospect/&quot;&gt;2018년 회고, 2019년 다짐&lt;/a&gt;을 다시 보고 왔습니다. 2019년 다짐은 아래와 같네요
    &lt;ul&gt;
      &lt;li&gt;독서
        &lt;ul&gt;
          &lt;li&gt;개발 서적 외에도 다양하게 읽자 =&amp;gt; 개발 서적이 아닌 책은 리디북스에서 월 1권정도 읽고 있네요..! 돌이켜보니 리디셀렉트를 적극적으로 이용하고 있지 않은 느낌? 더 독서해야겠네요&lt;/li&gt;
          &lt;li&gt;개발 서적은.. 일단 보이면 다 지르고 천천히 읽고 있습니다. 개발 서적은 월 3권 정도는 보는 것 같네요&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;요리
        &lt;ul&gt;
          &lt;li&gt;1도 안하네요ㅋㅋㅋㅋㅋㅋㅋㅋㅋ 아 음… 내 다짐은 어디로… 요리를 꼭 해야되나? 라고 생각이 변하고 있네요(그 시간에 코딩을 하지..!) 음.. 이건 좀 더 지켜보고 어떻게 할지 고민해야겠습니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;책 집필
        &lt;ul&gt;
          &lt;li&gt;상반기에 데이터 사이언스를 공부하고 싶은 분들을 위한 책을 내자! 가격도 그냥 거의 만원? 이렇게 생각했습니다. 관련 내용은 &lt;a href=&quot;https://github.com/Team-Neighborhood/I-want-to-study-Data-Science/wiki&quot;&gt;Github&lt;/a&gt;에 이미 꽤 있어서 쉬울거라 판단했습니다&lt;/li&gt;
          &lt;li&gt;하지만 글을 작성하려니 생각보다 어려웠는데, 그 이유는
            &lt;ul&gt;
              &lt;li&gt;
                &lt;ol&gt;
                  &lt;li&gt;제가 모든 분야를 자세히 알진 못한다. 얕게만 알고 있음 =&amp;gt; 그 사이에 비전, 자연어 등 계속 발전하고 있는데 제가 팔로업을 하지 못해서 과연 쓸 수 있을까? 고민했습니다&lt;/li&gt;
                &lt;/ol&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;ol&gt;
                  &lt;li&gt;블로그 글 작성과 책 쓰는 것은 완전 다른 일. 글 자주 쓴다고 책을 잘 쓰는 것은 아님&lt;/li&gt;
                &lt;/ol&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;ol&gt;
                  &lt;li&gt;팔리는 책을 만들기 위해선 생각보다 더 디테일을 잡아야 한다&lt;/li&gt;
                &lt;/ol&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;이런 생각 + 사내 SQL 강의, 외부 발표(한빛미디어 데브그라운드), Edwith 컨텐츠 작업, 스타트업 머신러닝 플레이어 모임  등을 하다보니 시간이 지났고, 아마 이 내용은 함께 쓸까? 라는 생각이 듭니다&lt;/li&gt;
          &lt;li&gt;생각보다 제가 BigQuery 책을 더 쓰고 싶어한다는 점을 깨달았습니다. 약 300쪽이 되는 &lt;a href=&quot;https://www.slideshare.net/zzsza/bigquery-147073606&quot;&gt;BigQuery의 모든 것&lt;/a&gt; 자료 만들 때 즐거웠습니다. 아마 책을 쓴다면 하반기에 빅쿼리를 써볼까 고민하고 있습니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;회사에서 다짐
        &lt;ul&gt;
          &lt;li&gt;회사에서 시간이 정말 빨리간 이유는 3월 ~ 5월에 두 팀의 팀장을 겸직해서 정말 시간이 빨리 지나갔고, 타다가 성장하면서 할 일들도 많아져서 더 몰입하며 일했습니다&lt;/li&gt;
          &lt;li&gt;6월 부터는 두 팀의 팀장이 아닌 한 팀의 팀장만 맡기로 했고, 여유가 다시 돌아오고 있습니다&lt;/li&gt;
          &lt;li&gt;팀원의 성장, 데이터 그룹의 성장 등 어떻게 구성원들과 함께 더 성장할까?를 매번 고민하고 있습니다&lt;/li&gt;
          &lt;li&gt;데이터 그룹이 아닌 기획, 마케팅 등 다양한 부서에서 SQL를 배우고 싶다는 욕구가 있어 사내 SQL 강의도 진행했습니다. 유튜브 라이브방송으로 지방에 계신 분들도 수강하셨어요&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;글또
        &lt;ul&gt;
          &lt;li&gt;글또 3기는 밑에서 따로 이야기를!&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;강화학습
        &lt;ul&gt;
          &lt;li&gt;강화학습을 재미로 꼭 공부하려고 하는데, 현재 하는 일이 많아서 하반기 또는 내년으로 미루려고 합니다!&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;GDE
        &lt;ul&gt;
          &lt;li&gt;이건 회고에만 있는데 실질적으로 아무 행동도 하지 않았네요. 클라우드 스터디잼은 종종 참여했고, 기존에 제가 자주 사용하지 않았던 내용에 대해 테스트해보고 있습니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그리고 상반기에 작성했던 &lt;a href=&quot;https://zzsza.github.io/diary/2019/04/05/how-to-study-datascience/&quot;&gt;데이터 사이언티스트가 되기 위해 진행한 다양한 노력들&lt;/a&gt;이란 글이 구글에서 데이터 사이언티스트란 검색 결과에 상위 노출되는 것을 보고 뿌듯했었네요 :)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;상반기-평가만족스러운가&quot;&gt;상반기 평가(만족스러운가?)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;전반적으로 만족하고 있습니다. 상반기는 고요하고 평온하게 제가 할 일을 묵묵히 해온 시간이라고 생각합니다
    &lt;ul&gt;
      &lt;li&gt;제품의 성장을 더 부스팅할 수 있도록, 하반기엔 조금 더 집중해 성과를 내보려고 합니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;외부 발표도 진행했고, 제가 배운 것들을 나눌 수 있어서 만족스럽습니다&lt;/li&gt;
  &lt;li&gt;최근 회사에 조인하신 인턴분들을 보며 더 자극되고, 저도 더! 성장하려고 다짐하고 있습니다&lt;/li&gt;
  &lt;li&gt;Discrete Optimization, GIS 등 완전 새로운 내용들을 익히며 즐겁게 지내고 있습니다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;글또-3기&quot;&gt;글또 3기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;글또는 아마 제가 꾸준히 가져갈 모임이라고 생각하는데, 이번엔 지원자가 60명이었습니다
    &lt;ul&gt;
      &lt;li&gt;총 합격자는 44분으로, 직전 기수인 2기 대비 2배 증가한 인원입니다&lt;/li&gt;
      &lt;li&gt;매 기수마다 약 2배씩 늘고 있는데, 그럼 4기엔 80분인가..(설마)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;많은 분들이 있어 좋은 시너지가 더 나올거라 생각하고 있습니다
    &lt;ul&gt;
      &lt;li&gt;아이디어를 다양하게 내주셔서 &lt;a href=&quot;https://github.com/geultto&quot;&gt;글또 Github&lt;/a&gt;도 만들고, 기존에 수동으로 했던 작업들을 자동화할 수 있도록 진행하고 있습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;좋은 분들과 함께인 만큼 저도 열심히 좋은 커뮤니티를 유지하고 글을 잘 쓸 수 있도록 서포트하겠습니다
    &lt;ul&gt;
      &lt;li&gt;(강제 상호 리뷰 시스템으로 아마 더 많은 긍정적 효과가 나오길 기대하고 있어요!)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;하반기&quot;&gt;하반기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;하반기가 끝나면 또 2019년이 벌써 끝났구나.. 하면서 회고할 것 같네요. 그 때 돌이켜볼 때 제가 기대하는 것들은 아래와 같습니다
    &lt;ul&gt;
      &lt;li&gt;전문성을 놓지 말기
        &lt;ul&gt;
          &lt;li&gt;팀장 포지션이 되면 관리직이 되기 쉬운데, 아직은 관리직과 실무를 같이 겸하는 사람이 되고 싶습니다. 매우 빡빡하고 어렵지만, 그래도 노력하면!!! 가능할 것이라고 생각하고 있어요 :)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;건강
        &lt;ul&gt;
          &lt;li&gt;이제 슬슬 건강을 매우 신경쓸 나이라고 생각하고 있어요(사실 나이 상관없이 건강은 언제나 중요)&lt;/li&gt;
          &lt;li&gt;글또처럼 꾸준히 운동하는 그런 환경을 만들어 제게 테스트해볼 생각입니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;좋은 영향력
        &lt;ul&gt;
          &lt;li&gt;요새 꼭 개발이나 머신러닝이 아니어도 다른 사람에게 긍정적인 영향을 끼치고 싶다는 생각을 많이 하고 있습니다. 좋은 영향을 끼칠 수 있도록 다양하게 노력해볼 예정이에요 :)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하반기엔 더 즐거운 일 가득하길 바라며 상반기 회고를 끝냅니다-!&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 07 Jul 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/diary/2019/07/07/2019-half-retrospect/</link>
        <guid isPermaLink="true">http://localhost:4000/diary/2019/07/07/2019-half-retrospect/</guid>
        
        <category>diary</category>
        
        
        <category>diary</category>
        
      </item>
    
  </channel>
</rss>
